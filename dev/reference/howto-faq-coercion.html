<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>FAQ - How to implement ptype2 and cast methods? — howto-faq-coercion • vctrs</title><!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png"><link rel="icon" type="”image/svg+xml”" href="../favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png"><link rel="icon" sizes="any" href="../favicon.ico"><link rel="manifest" href="../site.webmanifest"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.10/font.css" rel="stylesheet"><link href="../deps/Source_Code_Pro-0.4.10/font.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="FAQ - How to implement ptype2 and cast methods? — howto-faq-coercion"><meta name="description" content="This guide illustrates how to implement vec_ptype2() and vec_cast()
methods for existing classes. Related topics:
For an overview of how these generics work and their roles in vctrs,
see ?theory-faq-coercion.
For an example of implementing coercion methods for data frame
subclasses, see
?howto-faq-coercion-data-frame.
For a tutorial about implementing vctrs classes from scratch, see
vignette(&quot;s3-vector&quot;)


The natural number class


We’ll illustrate how to implement coercion methods with a simple class
that represents natural numbers. In this scenario we have an existing
class that already features a constructor and methods for print() and
subset.
#' @export
new_natural &amp;lt;- function(x) {
  if (is.numeric(x) || is.logical(x)) {
    stopifnot(is_whole(x))
    x &amp;lt;- as.integer(x)
  } else {
    stop(&quot;Can't construct natural from unknown type.&quot;)
  }
  structure(x, class = &quot;my_natural&quot;)
}
is_whole &amp;lt;- function(x) {
  all(x %% 1 == 0 | is.na(x))
}

#' @export
print.my_natural &amp;lt;- function(x, ...) {
  cat(&quot;&amp;lt;natural&amp;gt;\n&quot;)
  x &amp;lt;- unclass(x)
  NextMethod()
}
#' @export
`[.my_natural` &amp;lt;- function(x, i, ...) {
  new_natural(NextMethod())
}

new_natural(1:3)
#&amp;gt; &amp;lt;natural&amp;gt;
#&amp;gt; [1] 1 2 3
new_natural(c(1, NA))
#&amp;gt; &amp;lt;natural&amp;gt;
#&amp;gt; [1]  1 NA




Roxygen workflow


To implement methods for generics, first import the generics in your
namespace and redocument:
#' @importFrom vctrs vec_ptype2 vec_cast
NULL

Note that for each batches of methods that you add to your package, you
need to export the methods and redocument immediately, even during
development. Otherwise they won’t be in scope when you run unit tests
e.g. with testthat.
Implementing double dispatch methods is very similar to implementing
regular S3 methods. In these examples we are using roxygen2 tags to
register the methods, but you can also register the methods manually in
your NAMESPACE file or lazily with s3_register().



Implementing vec_ptype2()


The self-self method


The first method to implement is the one that signals that your class is
compatible with itself:
#' @export
vec_ptype2.my_natural.my_natural &amp;lt;- function(x, y, ...) {
  x
}

vec_ptype2(new_natural(1), new_natural(2:3))
#&amp;gt; &amp;lt;natural&amp;gt;
#&amp;gt; integer(0)

vec_ptype2() implements a fallback to try and be compatible with
simple classes, so it may seem that you don’t need to implement the
self-self coercion method. However, you must implement it explicitly
because this is how vctrs knows that a class that is implementing vctrs
methods (for instance this disable fallbacks to base::c()). Also, it
makes your class a bit more efficient.



The parent and children methods


Our natural number class is conceptually a parent of &amp;lt;logical&amp;gt; and a
child of &amp;lt;integer&amp;gt;, but the class is not compatible with logical,
integer, or double vectors yet:
vec_ptype2(TRUE, new_natural(2:3))
#&amp;gt; Error:
#&amp;gt; ! Can't combine `TRUE` &amp;lt;logical&amp;gt; and `new_natural(2:3)` &amp;lt;my_natural&amp;gt;.

vec_ptype2(new_natural(1), 2:3)
#&amp;gt; Error:
#&amp;gt; ! Can't combine `new_natural(1)` &amp;lt;my_natural&amp;gt; and `2:3` &amp;lt;integer&amp;gt;.

We’ll specify the twin methods for each of these classes, returning the
richer class in each case.
#' @export
vec_ptype2.my_natural.logical &amp;lt;- function(x, y, ...) {
  # The order of the classes in the method name follows the order of
  # the arguments in the function signature, so `x` is the natural
  # number and `y` is the logical
  x
}
#' @export
vec_ptype2.logical.my_natural &amp;lt;- function(x, y, ...) {
  # In this case `y` is the richer natural number
  y
}

Between a natural number and an integer, the latter is the richer class:
#' @export
vec_ptype2.my_natural.integer &amp;lt;- function(x, y, ...) {
  y
}
#' @export
vec_ptype2.integer.my_natural &amp;lt;- function(x, y, ...) {
  x
}

We no longer get common type errors for logical and integer:
vec_ptype2(TRUE, new_natural(2:3))
#&amp;gt; &amp;lt;natural&amp;gt;
#&amp;gt; integer(0)

vec_ptype2(new_natural(1), 2:3)
#&amp;gt; integer(0)

We are not done yet. Pairwise coercion methods must be implemented for
all the connected nodes in the coercion hierarchy, which include double
vectors further up. The coercion methods for grand-parent types must be
implemented separately:
#' @export
vec_ptype2.my_natural.double &amp;lt;- function(x, y, ...) {
  y
}
#' @export
vec_ptype2.double.my_natural &amp;lt;- function(x, y, ...) {
  x
}




Incompatible attributes


Most of the time, inputs are incompatible because they have different
classes for which no vec_ptype2() method is implemented. More rarely,
inputs could be incompatible because of their attributes. In that case
incompatibility is signalled by calling stop_incompatible_type().
In the following example, we implement a self-self ptype2 method for a
hypothetical subclass of &amp;lt;factor&amp;gt; that has stricter combination
semantics. The method throws an error when the levels of the two factors
are not compatible.
#' @export
vec_ptype2.my_strict_factor.my_strict_factor &amp;lt;- function(x, y, ..., x_arg = &quot;&quot;, y_arg = &quot;&quot;) {
  if (!setequal(levels(x), levels(y))) {
    stop_incompatible_type(x, y, x_arg = x_arg, y_arg = y_arg)
  }

  x
}

Note how the methods need to take x_arg and y_arg parameters and
pass them on to stop_incompatible_type(). These argument tags help
create more informative error messages when the common type
determination is for a column of a data frame. They are part of the
generic signature but can usually be left out if not used.






Implementing vec_cast()


Corresponding vec_cast() methods must be implemented for all
vec_ptype2() methods. The general pattern is to convert the argument
x to the type of to. The methods should validate the values in x
and make sure they conform to the values of to.
Please note that for historical reasons, the order of the classes in the
method name is in reverse order of the arguments in the function
signature. The first class represents to, whereas the second class
represents x.
The self-self method is easy in this case, it just returns the target
input:
#' @export
vec_cast.my_natural.my_natural &amp;lt;- function(x, to, ...) {
  x
}

The other types need to be validated. We perform input validation in the
new_natural() constructor, so that’s a good fit for our vec_cast()
implementations.
#' @export
vec_cast.my_natural.logical &amp;lt;- function(x, to, ...) {
  # The order of the classes in the method name is in reverse order
  # of the arguments in the function signature, so `to` is the natural
  # number and `x` is the logical
  new_natural(x)
}
vec_cast.my_natural.integer &amp;lt;- function(x, to, ...) {
  new_natural(x)
}
vec_cast.my_natural.double &amp;lt;- function(x, to, ...) {
  new_natural(x)
}

With these methods, vctrs is now able to combine logical and natural
vectors. It properly returns the richer type of the two, a natural
vector:
vec_c(TRUE, new_natural(1), FALSE)
#&amp;gt; &amp;lt;natural&amp;gt;
#&amp;gt; [1] 1 1 0

Because we haven’t implemented conversions from natural, it still
doesn’t know how to combine natural with the richer integer and double
types:
vec_c(new_natural(1), 10L)
#&amp;gt; Error in `vec_c()`:
#&amp;gt; ! Can't convert `..1` &amp;lt;my_natural&amp;gt; to &amp;lt;integer&amp;gt;.
vec_c(1.5, new_natural(1))
#&amp;gt; Error in `vec_c()`:
#&amp;gt; ! Can't convert `..2` &amp;lt;my_natural&amp;gt; to &amp;lt;double&amp;gt;.

This is quick work which completes the implementation of coercion
methods for vctrs:
#' @export
vec_cast.logical.my_natural &amp;lt;- function(x, to, ...) {
  # In this case `to` is the logical and `x` is the natural number
  attributes(x) &amp;lt;- NULL
  as.logical(x)
}
#' @export
vec_cast.integer.my_natural &amp;lt;- function(x, to, ...) {
  attributes(x) &amp;lt;- NULL
  as.integer(x)
}
#' @export
vec_cast.double.my_natural &amp;lt;- function(x, to, ...) {
  attributes(x) &amp;lt;- NULL
  as.double(x)
}

And we now get the expected combinations.
vec_c(new_natural(1), 10L)
#&amp;gt; [1]  1 10

vec_c(1.5, new_natural(1))
#&amp;gt; [1] 1.5 1.0


"><meta property="og:description" content="This guide illustrates how to implement vec_ptype2() and vec_cast()
methods for existing classes. Related topics:
For an overview of how these generics work and their roles in vctrs,
see ?theory-faq-coercion.
For an example of implementing coercion methods for data frame
subclasses, see
?howto-faq-coercion-data-frame.
For a tutorial about implementing vctrs classes from scratch, see
vignette(&quot;s3-vector&quot;)


The natural number class


We’ll illustrate how to implement coercion methods with a simple class
that represents natural numbers. In this scenario we have an existing
class that already features a constructor and methods for print() and
subset.
#' @export
new_natural &amp;lt;- function(x) {
  if (is.numeric(x) || is.logical(x)) {
    stopifnot(is_whole(x))
    x &amp;lt;- as.integer(x)
  } else {
    stop(&quot;Can't construct natural from unknown type.&quot;)
  }
  structure(x, class = &quot;my_natural&quot;)
}
is_whole &amp;lt;- function(x) {
  all(x %% 1 == 0 | is.na(x))
}

#' @export
print.my_natural &amp;lt;- function(x, ...) {
  cat(&quot;&amp;lt;natural&amp;gt;\n&quot;)
  x &amp;lt;- unclass(x)
  NextMethod()
}
#' @export
`[.my_natural` &amp;lt;- function(x, i, ...) {
  new_natural(NextMethod())
}

new_natural(1:3)
#&amp;gt; &amp;lt;natural&amp;gt;
#&amp;gt; [1] 1 2 3
new_natural(c(1, NA))
#&amp;gt; &amp;lt;natural&amp;gt;
#&amp;gt; [1]  1 NA




Roxygen workflow


To implement methods for generics, first import the generics in your
namespace and redocument:
#' @importFrom vctrs vec_ptype2 vec_cast
NULL

Note that for each batches of methods that you add to your package, you
need to export the methods and redocument immediately, even during
development. Otherwise they won’t be in scope when you run unit tests
e.g. with testthat.
Implementing double dispatch methods is very similar to implementing
regular S3 methods. In these examples we are using roxygen2 tags to
register the methods, but you can also register the methods manually in
your NAMESPACE file or lazily with s3_register().



Implementing vec_ptype2()


The self-self method


The first method to implement is the one that signals that your class is
compatible with itself:
#' @export
vec_ptype2.my_natural.my_natural &amp;lt;- function(x, y, ...) {
  x
}

vec_ptype2(new_natural(1), new_natural(2:3))
#&amp;gt; &amp;lt;natural&amp;gt;
#&amp;gt; integer(0)

vec_ptype2() implements a fallback to try and be compatible with
simple classes, so it may seem that you don’t need to implement the
self-self coercion method. However, you must implement it explicitly
because this is how vctrs knows that a class that is implementing vctrs
methods (for instance this disable fallbacks to base::c()). Also, it
makes your class a bit more efficient.



The parent and children methods


Our natural number class is conceptually a parent of &amp;lt;logical&amp;gt; and a
child of &amp;lt;integer&amp;gt;, but the class is not compatible with logical,
integer, or double vectors yet:
vec_ptype2(TRUE, new_natural(2:3))
#&amp;gt; Error:
#&amp;gt; ! Can't combine `TRUE` &amp;lt;logical&amp;gt; and `new_natural(2:3)` &amp;lt;my_natural&amp;gt;.

vec_ptype2(new_natural(1), 2:3)
#&amp;gt; Error:
#&amp;gt; ! Can't combine `new_natural(1)` &amp;lt;my_natural&amp;gt; and `2:3` &amp;lt;integer&amp;gt;.

We’ll specify the twin methods for each of these classes, returning the
richer class in each case.
#' @export
vec_ptype2.my_natural.logical &amp;lt;- function(x, y, ...) {
  # The order of the classes in the method name follows the order of
  # the arguments in the function signature, so `x` is the natural
  # number and `y` is the logical
  x
}
#' @export
vec_ptype2.logical.my_natural &amp;lt;- function(x, y, ...) {
  # In this case `y` is the richer natural number
  y
}

Between a natural number and an integer, the latter is the richer class:
#' @export
vec_ptype2.my_natural.integer &amp;lt;- function(x, y, ...) {
  y
}
#' @export
vec_ptype2.integer.my_natural &amp;lt;- function(x, y, ...) {
  x
}

We no longer get common type errors for logical and integer:
vec_ptype2(TRUE, new_natural(2:3))
#&amp;gt; &amp;lt;natural&amp;gt;
#&amp;gt; integer(0)

vec_ptype2(new_natural(1), 2:3)
#&amp;gt; integer(0)

We are not done yet. Pairwise coercion methods must be implemented for
all the connected nodes in the coercion hierarchy, which include double
vectors further up. The coercion methods for grand-parent types must be
implemented separately:
#' @export
vec_ptype2.my_natural.double &amp;lt;- function(x, y, ...) {
  y
}
#' @export
vec_ptype2.double.my_natural &amp;lt;- function(x, y, ...) {
  x
}




Incompatible attributes


Most of the time, inputs are incompatible because they have different
classes for which no vec_ptype2() method is implemented. More rarely,
inputs could be incompatible because of their attributes. In that case
incompatibility is signalled by calling stop_incompatible_type().
In the following example, we implement a self-self ptype2 method for a
hypothetical subclass of &amp;lt;factor&amp;gt; that has stricter combination
semantics. The method throws an error when the levels of the two factors
are not compatible.
#' @export
vec_ptype2.my_strict_factor.my_strict_factor &amp;lt;- function(x, y, ..., x_arg = &quot;&quot;, y_arg = &quot;&quot;) {
  if (!setequal(levels(x), levels(y))) {
    stop_incompatible_type(x, y, x_arg = x_arg, y_arg = y_arg)
  }

  x
}

Note how the methods need to take x_arg and y_arg parameters and
pass them on to stop_incompatible_type(). These argument tags help
create more informative error messages when the common type
determination is for a column of a data frame. They are part of the
generic signature but can usually be left out if not used.






Implementing vec_cast()


Corresponding vec_cast() methods must be implemented for all
vec_ptype2() methods. The general pattern is to convert the argument
x to the type of to. The methods should validate the values in x
and make sure they conform to the values of to.
Please note that for historical reasons, the order of the classes in the
method name is in reverse order of the arguments in the function
signature. The first class represents to, whereas the second class
represents x.
The self-self method is easy in this case, it just returns the target
input:
#' @export
vec_cast.my_natural.my_natural &amp;lt;- function(x, to, ...) {
  x
}

The other types need to be validated. We perform input validation in the
new_natural() constructor, so that’s a good fit for our vec_cast()
implementations.
#' @export
vec_cast.my_natural.logical &amp;lt;- function(x, to, ...) {
  # The order of the classes in the method name is in reverse order
  # of the arguments in the function signature, so `to` is the natural
  # number and `x` is the logical
  new_natural(x)
}
vec_cast.my_natural.integer &amp;lt;- function(x, to, ...) {
  new_natural(x)
}
vec_cast.my_natural.double &amp;lt;- function(x, to, ...) {
  new_natural(x)
}

With these methods, vctrs is now able to combine logical and natural
vectors. It properly returns the richer type of the two, a natural
vector:
vec_c(TRUE, new_natural(1), FALSE)
#&amp;gt; &amp;lt;natural&amp;gt;
#&amp;gt; [1] 1 1 0

Because we haven’t implemented conversions from natural, it still
doesn’t know how to combine natural with the richer integer and double
types:
vec_c(new_natural(1), 10L)
#&amp;gt; Error in `vec_c()`:
#&amp;gt; ! Can't convert `..1` &amp;lt;my_natural&amp;gt; to &amp;lt;integer&amp;gt;.
vec_c(1.5, new_natural(1))
#&amp;gt; Error in `vec_c()`:
#&amp;gt; ! Can't convert `..2` &amp;lt;my_natural&amp;gt; to &amp;lt;double&amp;gt;.

This is quick work which completes the implementation of coercion
methods for vctrs:
#' @export
vec_cast.logical.my_natural &amp;lt;- function(x, to, ...) {
  # In this case `to` is the logical and `x` is the natural number
  attributes(x) &amp;lt;- NULL
  as.logical(x)
}
#' @export
vec_cast.integer.my_natural &amp;lt;- function(x, to, ...) {
  attributes(x) &amp;lt;- NULL
  as.integer(x)
}
#' @export
vec_cast.double.my_natural &amp;lt;- function(x, to, ...) {
  attributes(x) &amp;lt;- NULL
  as.double(x)
}

And we now get the expected combinations.
vec_c(new_natural(1), 10L)
#&amp;gt; [1]  1 10

vec_c(1.5, new_natural(1))
#&amp;gt; [1] 1.5 1.0


"><meta property="og:image" content="https://vctrs.r-lib.org/logo.png"><meta name="robots" content="noindex"><script defer data-domain="vctrs.r-lib.org,all.tidyverse.org" src="https://plausible.io/js/plausible.js"></script></head><body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-none" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">vctrs</a>

    <small class="nav-text text-danger me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="In-development version">0.6.5.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/pillar.html">Printing vectors nicely in tibbles</a></li>
    <li><a class="dropdown-item" href="../articles/s3-vector.html">S3 vectors</a></li>
    <li><a class="dropdown-item" href="../articles/stability.html">Type and size stability</a></li>
    <li><a class="dropdown-item" href="../articles/type-size.html">Prototypes and sizes</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/r-lib/vctrs/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic" id="container">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>FAQ - How to implement ptype2 and cast methods?</h1>
      <small class="dont-index">Source: <a href="https://github.com/r-lib/vctrs/blob/main/R/faq-developer.R" class="external-link"><code>R/faq-developer.R</code></a></small>
      <div class="d-none name"><code>howto-faq-coercion.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>This guide illustrates how to implement <code><a href="vec_ptype2.html">vec_ptype2()</a></code> and <code><a href="vec_cast.html">vec_cast()</a></code>
methods for existing classes. Related topics:</p><ul><li><p>For an overview of how these generics work and their roles in vctrs,
see <code><a href="theory-faq-coercion.html">?theory-faq-coercion</a></code>.</p></li>
<li><p>For an example of implementing coercion methods for data frame
subclasses, see
<code><a href="howto-faq-coercion-data-frame.html">?howto-faq-coercion-data-frame</a></code>.</p></li>
<li><p>For a tutorial about implementing vctrs classes from scratch, see
<code><a href="../articles/s3-vector.html">vignette("s3-vector")</a></code></p></li>
</ul><div class="section">
<h3 id="the-natural-number-class">The natural number class<a class="anchor" aria-label="anchor" href="#the-natural-number-class"></a></h3>


<p>We’ll illustrate how to implement coercion methods with a simple class
that represents natural numbers. In this scenario we have an existing
class that already features a constructor and methods for <code><a href="https://rdrr.io/r/base/print.html" class="external-link">print()</a></code> and
subset.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">new_natural</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">is.numeric</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">||</span> <span class="fu"><a href="https://rdrr.io/r/base/logical.html" class="external-link">is.logical</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/stopifnot.html" class="external-link">stopifnot</a></span><span class="op">(</span><span class="fu">is_whole</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/integer.html" class="external-link">as.integer</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop</a></span><span class="op">(</span><span class="st">"Can't construct natural from unknown type."</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/structure.html" class="external-link">structure</a></span><span class="op">(</span><span class="va">x</span>, class <span class="op">=</span> <span class="st">"my_natural"</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="va">is_whole</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/all.html" class="external-link">all</a></span><span class="op">(</span><span class="va">x</span> <span class="op"><a href="https://rdrr.io/r/base/Arithmetic.html" class="external-link">%%</a></span> <span class="fl">1</span> <span class="op">==</span> <span class="fl">0</span> <span class="op">|</span> <span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">print.my_natural</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"&lt;natural&gt;\n"</span><span class="op">)</span></span>
<span>  <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/class.html" class="external-link">unclass</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/UseMethod.html" class="external-link">NextMethod</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">`[.my_natural`</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">i</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">new_natural</span><span class="op">(</span><span class="kw"><a href="https://rdrr.io/r/base/UseMethod.html" class="external-link">NextMethod</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu">new_natural</span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#&gt; &lt;natural&gt;</span></span>
<span><span class="co">#&gt; [1] 1 2 3</span></span>
<span><span class="fu">new_natural</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="cn">NA</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; &lt;natural&gt;</span></span>
<span><span class="co">#&gt; [1]  1 NA</span></span></code></pre><p></p></div>
</div>

<div class="section">
<h3 id="roxygen-workflow">Roxygen workflow<a class="anchor" aria-label="anchor" href="#roxygen-workflow"></a></h3>


<p>To implement methods for generics, first import the generics in your
namespace and redocument:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @importFrom vctrs vec_ptype2 vec_cast</span></span>
<span><span class="cn">NULL</span></span></code></pre><p></p></div>
<p>Note that for each batches of methods that you add to your package, you
need to export the methods and redocument immediately, even during
development. Otherwise they won’t be in scope when you run unit tests
e.g. with testthat.</p>
<p>Implementing double dispatch methods is very similar to implementing
regular S3 methods. In these examples we are using roxygen2 tags to
register the methods, but you can also register the methods manually in
your NAMESPACE file or lazily with <code><a href="s3_register.html">s3_register()</a></code>.</p>
</div>

<div class="section">
<h3 id="implementing-vec-ptype-">Implementing <code><a href="vec_ptype2.html">vec_ptype2()</a></code><a class="anchor" aria-label="anchor" href="#implementing-vec-ptype-"></a></h3>

<div class="section">
<h4 id="the-self-self-method">The self-self method<a class="anchor" aria-label="anchor" href="#the-self-self-method"></a></h4>


<p>The first method to implement is the one that signals that your class is
compatible with itself:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.my_natural.my_natural</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">x</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_ptype2.html">vec_ptype2</a></span><span class="op">(</span><span class="fu">new_natural</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, <span class="fu">new_natural</span><span class="op">(</span><span class="fl">2</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; &lt;natural&gt;</span></span>
<span><span class="co">#&gt; integer(0)</span></span></code></pre><p></p></div>
<p><code><a href="vec_ptype2.html">vec_ptype2()</a></code> implements a fallback to try and be compatible with
simple classes, so it may seem that you don’t need to implement the
self-self coercion method. However, you must implement it explicitly
because this is how vctrs knows that a class that is implementing vctrs
methods (for instance this disable fallbacks to <code><a href="https://rdrr.io/r/base/c.html" class="external-link">base::c()</a></code>). Also, it
makes your class a bit more efficient.</p>
</div>

<div class="section">
<h4 id="the-parent-and-children-methods">The parent and children methods<a class="anchor" aria-label="anchor" href="#the-parent-and-children-methods"></a></h4>


<p>Our natural number class is conceptually a parent of <code>&lt;logical&gt;</code> and a
child of <code>&lt;integer&gt;</code>, but the class is not compatible with logical,
integer, or double vectors yet:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_ptype2.html">vec_ptype2</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="fu">new_natural</span><span class="op">(</span><span class="fl">2</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error:</span></span>
<span><span class="co">#&gt; ! Can't combine `TRUE` &lt;logical&gt; and `new_natural(2:3)` &lt;my_natural&gt;.</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_ptype2.html">vec_ptype2</a></span><span class="op">(</span><span class="fu">new_natural</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, <span class="fl">2</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error:</span></span>
<span><span class="co">#&gt; ! Can't combine `new_natural(1)` &lt;my_natural&gt; and `2:3` &lt;integer&gt;.</span></span></code></pre><p></p></div>
<p>We’ll specify the twin methods for each of these classes, returning the
richer class in each case.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.my_natural.logical</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># The order of the classes in the method name follows the order of</span></span>
<span>  <span class="co"># the arguments in the function signature, so `x` is the natural</span></span>
<span>  <span class="co"># number and `y` is the logical</span></span>
<span>  <span class="va">x</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.logical.my_natural</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># In this case `y` is the richer natural number</span></span>
<span>  <span class="va">y</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>Between a natural number and an integer, the latter is the richer class:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.my_natural.integer</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">y</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.integer.my_natural</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">x</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>We no longer get common type errors for logical and integer:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_ptype2.html">vec_ptype2</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="fu">new_natural</span><span class="op">(</span><span class="fl">2</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; &lt;natural&gt;</span></span>
<span><span class="co">#&gt; integer(0)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_ptype2.html">vec_ptype2</a></span><span class="op">(</span><span class="fu">new_natural</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, <span class="fl">2</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#&gt; integer(0)</span></span></code></pre><p></p></div>
<p>We are not done yet. Pairwise coercion methods must be implemented for
all the connected nodes in the coercion hierarchy, which include double
vectors further up. The coercion methods for grand-parent types must be
implemented separately:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.my_natural.double</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">y</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.double.my_natural</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">x</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
</div>

<div class="section">
<h4 id="incompatible-attributes">Incompatible attributes<a class="anchor" aria-label="anchor" href="#incompatible-attributes"></a></h4>


<p>Most of the time, inputs are incompatible because they have different
classes for which no <code><a href="vec_ptype2.html">vec_ptype2()</a></code> method is implemented. More rarely,
inputs could be incompatible because of their attributes. In that case
incompatibility is signalled by calling <code><a href="vctrs-conditions.html">stop_incompatible_type()</a></code>.</p>
<p>In the following example, we implement a self-self ptype2 method for a
hypothetical subclass of <code>&lt;factor&gt;</code> that has stricter combination
semantics. The method throws an error when the levels of the two factors
are not compatible.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.my_strict_factor.my_strict_factor</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span>, <span class="va">x_arg</span> <span class="op">=</span> <span class="st">""</span>, <span class="va">y_arg</span> <span class="op">=</span> <span class="st">""</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/sets.html" class="external-link">setequal</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/levels.html" class="external-link">levels</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/levels.html" class="external-link">levels</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="../reference/vctrs-conditions.html">stop_incompatible_type</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, x_arg <span class="op">=</span> <span class="va">x_arg</span>, y_arg <span class="op">=</span> <span class="va">y_arg</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span></span>
<span>  <span class="va">x</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>Note how the methods need to take <code>x_arg</code> and <code>y_arg</code> parameters and
pass them on to <code><a href="vctrs-conditions.html">stop_incompatible_type()</a></code>. These argument tags help
create more informative error messages when the common type
determination is for a column of a data frame. They are part of the
generic signature but can usually be left out if not used.</p>
</div>


</div>

<div class="section">
<h3 id="implementing-vec-cast-">Implementing <code><a href="vec_cast.html">vec_cast()</a></code><a class="anchor" aria-label="anchor" href="#implementing-vec-cast-"></a></h3>


<p>Corresponding <code><a href="vec_cast.html">vec_cast()</a></code> methods must be implemented for all
<code><a href="vec_ptype2.html">vec_ptype2()</a></code> methods. The general pattern is to convert the argument
<code>x</code> to the type of <code>to</code>. The methods should validate the values in <code>x</code>
and make sure they conform to the values of <code>to</code>.</p>
<p>Please note that for historical reasons, the order of the classes in the
method name is in reverse order of the arguments in the function
signature. The first class represents <code>to</code>, whereas the second class
represents <code>x</code>.</p>
<p>The self-self method is easy in this case, it just returns the target
input:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.my_natural.my_natural</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">x</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>The other types need to be validated. We perform input validation in the
<code>new_natural()</code> constructor, so that’s a good fit for our <code><a href="vec_cast.html">vec_cast()</a></code>
implementations.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.my_natural.logical</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># The order of the classes in the method name is in reverse order</span></span>
<span>  <span class="co"># of the arguments in the function signature, so `to` is the natural</span></span>
<span>  <span class="co"># number and `x` is the logical</span></span>
<span>  <span class="fu">new_natural</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="va">vec_cast.my_natural.integer</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">new_natural</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="va">vec_cast.my_natural.double</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">new_natural</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>With these methods, vctrs is now able to combine logical and natural
vectors. It properly returns the richer type of the two, a natural
vector:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_c.html">vec_c</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="fu">new_natural</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">#&gt; &lt;natural&gt;</span></span>
<span><span class="co">#&gt; [1] 1 1 0</span></span></code></pre><p></p></div>
<p>Because we haven’t implemented conversions <em>from</em> natural, it still
doesn’t know how to combine natural with the richer integer and double
types:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_c.html">vec_c</a></span><span class="op">(</span><span class="fu">new_natural</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, <span class="fl">10L</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error in `vec_c()`:</span></span>
<span><span class="co">#&gt; ! Can't convert `..1` &lt;my_natural&gt; to &lt;integer&gt;.</span></span>
<span><span class="fu"><a href="../reference/vec_c.html">vec_c</a></span><span class="op">(</span><span class="fl">1.5</span>, <span class="fu">new_natural</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error in `vec_c()`:</span></span>
<span><span class="co">#&gt; ! Can't convert `..2` &lt;my_natural&gt; to &lt;double&gt;.</span></span></code></pre><p></p></div>
<p>This is quick work which completes the implementation of coercion
methods for vctrs:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.logical.my_natural</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># In this case `to` is the logical and `x` is the natural number</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/attributes.html" class="external-link">attributes</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="cn">NULL</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/logical.html" class="external-link">as.logical</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.integer.my_natural</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/attributes.html" class="external-link">attributes</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="cn">NULL</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/integer.html" class="external-link">as.integer</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.double.my_natural</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/attributes.html" class="external-link">attributes</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="cn">NULL</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/double.html" class="external-link">as.double</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>And we now get the expected combinations.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_c.html">vec_c</a></span><span class="op">(</span><span class="fu">new_natural</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, <span class="fl">10L</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1]  1 10</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_c.html">vec_c</a></span><span class="op">(</span><span class="fl">1.5</span>, <span class="fu">new_natural</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 1.5 1.0</span></span></code></pre><p></p></div>
</div>

    </div>



  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by <a href="https://hadley.nz" class="external-link">Hadley Wickham</a>, <a href="https://github.com/lionel-" class="external-link">Lionel Henry</a>, <a href="https://github.com/DavisVaughan" class="external-link">Davis Vaughan</a>, <a href="https://www.posit.co" class="external-link"><img src="https://www.tidyverse.org/posit-logo.svg" alt="Posit" height="16" width="62" style="margin-bottom: 3px;"></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

  </div></footer></body></html>

