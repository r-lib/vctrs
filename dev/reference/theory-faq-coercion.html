<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="This is an overview of the usage of vec_ptype2() and vec_cast() and
their role in the vctrs coercion mechanism. Related topics:
For an example of implementing coercion methods for simple vectors,
see ?howto-faq-coercion.
For an example of implementing coercion methods for data frame
subclasses, see
?howto-faq-coercion-data-frame.
For a tutorial about implementing vctrs classes from scratch, see
vignette(&quot;s3-vector&quot;).


Combination mechanism in vctrs


The coercion system in vctrs is designed to make combination of multiple
inputs consistent and extensible. Combinations occur in many places,
such as row-binding, joins, subset-assignment, or grouped summary
functions that use the split-apply-combine strategy. For example:
vec_c(TRUE, 1)
#&amp;gt; [1] 1 1

vec_c(&quot;a&quot;, 1)
#&amp;gt; Error in `vec_c()`:
#&amp;gt; ! Can't combine `..1` &amp;lt;character&amp;gt; and `..2` &amp;lt;double&amp;gt;.

vec_rbind(
  data.frame(x = TRUE),
  data.frame(x = 1, y = 2)
)
#&amp;gt;   x  y
#&amp;gt; 1 1 NA
#&amp;gt; 2 1  2

vec_rbind(
  data.frame(x = &quot;a&quot;),
  data.frame(x = 1, y = 2)
)
#&amp;gt; Error in `vec_rbind()`:
#&amp;gt; ! Can't combine `..1$x` &amp;lt;character&amp;gt; and `..2$x` &amp;lt;double&amp;gt;.

One major goal of vctrs is to provide a central place for implementing
the coercion methods that make generic combinations possible. The two
relevant generics are vec_ptype2() and vec_cast(). They both take
two arguments and perform double dispatch, meaning that a method is
selected based on the classes of both inputs.
The general mechanism for combining multiple inputs is:
Find the common type of a set of inputs by reducing (as in
base::Reduce() or purrr::reduce()) the vec_ptype2() binary
function over the set.
Convert all inputs to the common type with vec_cast().
Initialise the output vector as an instance of this common type with
vec_init().
Fill the output vector with the elements of the inputs using
vec_assign().


The last two steps may require vec_proxy() and vec_restore()
implementations, unless the attributes of your class are constant and do
not depend on the contents of the vector. We focus here on the first two
steps, which require vec_ptype2() and vec_cast() implementations.



vec_ptype2()


Methods for vec_ptype2() are passed two prototypes, i.e. two inputs
emptied of their elements. They implement two behaviours:
If the types of their inputs are compatible, indicate which of them is
the richer type by returning it. If the types are of equal resolution,
return any of the two.
Throw an error with stop_incompatible_type() when it can be
determined from the attributes that the types of the inputs are not
compatible.


Type compatibility


A type is compatible with another type if the values it represents
are a subset or a superset of the values of the other type. The notion
of “value” is to be interpreted at a high level, in particular it is not
the same as the memory representation. For example, factors are
represented in memory with integers but their values are more related to
character vectors than to round numbers:
# Two factors are compatible
vec_ptype2(factor(&quot;a&quot;), factor(&quot;b&quot;))
#&amp;gt; factor()
#&amp;gt; Levels: a b

# Factors are compatible with a character
vec_ptype2(factor(&quot;a&quot;), &quot;b&quot;)
#&amp;gt; character(0)

# But they are incompatible with integers
vec_ptype2(factor(&quot;a&quot;), 1L)
#&amp;gt; Error:
#&amp;gt; ! Can't combine `factor(&quot;a&quot;)` &amp;lt;factor&amp;lt;4d52a&amp;gt;&amp;gt; and `1L` &amp;lt;integer&amp;gt;.




Richness of type


Richness of type is not a very precise notion. It can be about richer
data (for instance a double vector covers more values than an integer
vector), richer behaviour (a data.table has richer behaviour than a
data.frame), or both. If you have trouble determining which one of the
two types is richer, it probably means they shouldn’t be automatically
coercible.
Let’s look again at what happens when we combine a factor and a
character:
vec_ptype2(factor(&quot;a&quot;), &quot;b&quot;)
#&amp;gt; character(0)

The ptype2 method for &amp;lt;character&amp;gt; and &amp;lt;factor&amp;lt;&quot;a&quot;&amp;gt;&amp;gt; returns
&amp;lt;character&amp;gt; because the former is a richer type. The factor can only
contain &quot;a&quot; strings, whereas the character can contain any strings. In
this sense, factors are a subset of character.
Note that another valid behaviour would be to throw an incompatible type
error. This is what a strict factor implementation would do. We have
decided to be laxer in vctrs because it is easy to inadvertently create
factors instead of character vectors, especially with older versions of
R where stringsAsFactors is still true by default.



Consistency and symmetry on permutation


Each ptype2 method should strive to have exactly the same behaviour when
the inputs are permuted. This is not always possible, for example factor
levels are aggregated in order:
vec_ptype2(factor(c(&quot;a&quot;, &quot;c&quot;)), factor(&quot;b&quot;))
#&amp;gt; factor()
#&amp;gt; Levels: a c b

vec_ptype2(factor(&quot;b&quot;), factor(c(&quot;a&quot;, &quot;c&quot;)))
#&amp;gt; factor()
#&amp;gt; Levels: b a c

In any case, permuting the input should not return a fundamentally
different type or introduce an incompatible type error.



Coercion hierarchy


The classes that you can coerce together form a coercion (or subtyping)
hierarchy. Below is a schema of the hierarchy for the base types like
integer and factor. In this diagram the directions of the arrows express
which type is richer. They flow from the bottom (more constrained types)
to the top (richer types).

A coercion hierarchy is distinct from the structural hierarchy implied
by memory types and classes. For instance, in a structural hierarchy,
factors are built on top of integers. But in the coercion hierarchy they
are more related to character vectors. Similarly, subclasses are not
necessarily coercible with their superclasses because the coercion and
structural hierarchies are separate.



Implementing a coercion hierarchy


As a class implementor, you have two options. The simplest is to create
an entirely separate hierarchy. The date and date-time classes are an
example of an S3-based hierarchy that is completely separate.
Alternatively, you can integrate your class in an existing hierarchy,
typically by adding parent nodes on top of the hierarchy (your class is
richer), by adding children node at the root of the hierarchy (your
class is more constrained), or by inserting a node in the tree.
These coercion hierarchies are implicit, in the sense that they are
implied by the vec_ptype2() implementations. There is no structured
way to create or modify a hierarchy, instead you need to implement the
appropriate coercion methods for all the types in your hierarchy, and
diligently return the richer type in each case. The vec_ptype2()
implementations are not transitive nor inherited, so all pairwise
methods between classes lying on a given path must be implemented
manually. This is something we might make easier in the future.






vec_cast()


The second generic, vec_cast(), is the one that looks at the data and
actually performs the conversion. Because it has access to more
information than vec_ptype2(), it may be stricter and cause an error
in more cases. vec_cast() has three possible behaviours:
Determine that the prototypes of the two inputs are not compatible.
This must be decided in exactly the same way as for vec_ptype2().
Call stop_incompatible_cast() if you can determine from the
attributes that the types are not compatible.
Detect incompatible values. Usually this is because the target type is
too restricted for the values supported by the input type. For
example, a fractional number can’t be converted to an integer. The
method should throw an error in that case.
Return the input vector converted to the target type if all values are
compatible. Whereas vec_ptype2() must return the same type when the
inputs are permuted, vec_cast() is directional. It always returns
the type of the right-hand side, or dies trying.





Double dispatch


The dispatch mechanism for vec_ptype2() and vec_cast() looks like S3
but is actually a custom mechanism. Compared to S3, it has the following
differences:
It dispatches on the classes of the first two inputs.
There is no inheritance of ptype2 and cast methods. This is because
the S3 class hierarchy is not necessarily the same as the coercion
hierarchy.
NextMethod() does not work. Parent methods must be called explicitly
if necessary.
The default method is hard-coded.





Data frames


The determination of the common type of data frames with vec_ptype2()
happens in three steps:
Match the columns of the two input data frames. If some columns
don’t exist, they are created and filled with adequately typed NA
values.
Find the common type for each column by calling vec_ptype2() on
each pair of matched columns.
Find the common data frame type. For example the common type of a
grouped tibble and a tibble is a grouped tibble because the latter
is the richer type. The common type of a data table and a data frame
is a data table.


vec_cast() operates similarly. If a data frame is cast to a target
type that has fewer columns, this is an error.
If you are implementing coercion methods for data frames, you will need
to explicitly call the parent methods that perform the common type
determination or the type conversion described above. These are exported
as df_ptype2() and df_cast().
Data frame fallbacks


Being too strict with data frame combinations would cause too much pain
because there are many data frame subclasses in the wild that don’t
implement vctrs methods. We have decided to implement a special fallback
behaviour for foreign data frames. Incompatible data frames fall back to
a base data frame:
df1 &amp;lt;- data.frame(x = 1)
df2 &amp;lt;- structure(df1, class = c(&quot;foreign_df&quot;, &quot;data.frame&quot;))

vec_rbind(df1, df2)
#&amp;gt;   x
#&amp;gt; 1 1
#&amp;gt; 2 1

When a tibble is involved, we fall back to tibble:
df3 &amp;lt;- tibble::as_tibble(df1)

vec_rbind(df1, df3)
#&amp;gt; # A tibble: 2 x 1
#&amp;gt;       x
#&amp;gt;   &amp;lt;dbl&amp;gt;
#&amp;gt; 1     1
#&amp;gt; 2     1

These fallbacks are not ideal but they make sense because all data
frames share a common data structure. This is not generally the case for
vectors. For example factors and characters have different
representations, and it is not possible to find a fallback time
mechanically.
However this fallback has a big downside: implementing vctrs methods for
your data frame subclass is a breaking behaviour change. The proper
coercion behaviour for your data frame class should be specified as soon
as possible to limit the consequences of changing the behaviour of your
class in R scripts.




"><title>FAQ - How does coercion work in vctrs? — theory-faq-coercion • vctrs</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.9/font.css" rel="stylesheet"><link href="../deps/Source_Code_Pro-0.4.9/font.css" rel="stylesheet"><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="FAQ - How does coercion work in vctrs? — theory-faq-coercion"><meta property="og:description" content="This is an overview of the usage of vec_ptype2() and vec_cast() and
their role in the vctrs coercion mechanism. Related topics:
For an example of implementing coercion methods for simple vectors,
see ?howto-faq-coercion.
For an example of implementing coercion methods for data frame
subclasses, see
?howto-faq-coercion-data-frame.
For a tutorial about implementing vctrs classes from scratch, see
vignette(&quot;s3-vector&quot;).


Combination mechanism in vctrs


The coercion system in vctrs is designed to make combination of multiple
inputs consistent and extensible. Combinations occur in many places,
such as row-binding, joins, subset-assignment, or grouped summary
functions that use the split-apply-combine strategy. For example:
vec_c(TRUE, 1)
#&amp;gt; [1] 1 1

vec_c(&quot;a&quot;, 1)
#&amp;gt; Error in `vec_c()`:
#&amp;gt; ! Can't combine `..1` &amp;lt;character&amp;gt; and `..2` &amp;lt;double&amp;gt;.

vec_rbind(
  data.frame(x = TRUE),
  data.frame(x = 1, y = 2)
)
#&amp;gt;   x  y
#&amp;gt; 1 1 NA
#&amp;gt; 2 1  2

vec_rbind(
  data.frame(x = &quot;a&quot;),
  data.frame(x = 1, y = 2)
)
#&amp;gt; Error in `vec_rbind()`:
#&amp;gt; ! Can't combine `..1$x` &amp;lt;character&amp;gt; and `..2$x` &amp;lt;double&amp;gt;.

One major goal of vctrs is to provide a central place for implementing
the coercion methods that make generic combinations possible. The two
relevant generics are vec_ptype2() and vec_cast(). They both take
two arguments and perform double dispatch, meaning that a method is
selected based on the classes of both inputs.
The general mechanism for combining multiple inputs is:
Find the common type of a set of inputs by reducing (as in
base::Reduce() or purrr::reduce()) the vec_ptype2() binary
function over the set.
Convert all inputs to the common type with vec_cast().
Initialise the output vector as an instance of this common type with
vec_init().
Fill the output vector with the elements of the inputs using
vec_assign().


The last two steps may require vec_proxy() and vec_restore()
implementations, unless the attributes of your class are constant and do
not depend on the contents of the vector. We focus here on the first two
steps, which require vec_ptype2() and vec_cast() implementations.



vec_ptype2()


Methods for vec_ptype2() are passed two prototypes, i.e. two inputs
emptied of their elements. They implement two behaviours:
If the types of their inputs are compatible, indicate which of them is
the richer type by returning it. If the types are of equal resolution,
return any of the two.
Throw an error with stop_incompatible_type() when it can be
determined from the attributes that the types of the inputs are not
compatible.


Type compatibility


A type is compatible with another type if the values it represents
are a subset or a superset of the values of the other type. The notion
of “value” is to be interpreted at a high level, in particular it is not
the same as the memory representation. For example, factors are
represented in memory with integers but their values are more related to
character vectors than to round numbers:
# Two factors are compatible
vec_ptype2(factor(&quot;a&quot;), factor(&quot;b&quot;))
#&amp;gt; factor()
#&amp;gt; Levels: a b

# Factors are compatible with a character
vec_ptype2(factor(&quot;a&quot;), &quot;b&quot;)
#&amp;gt; character(0)

# But they are incompatible with integers
vec_ptype2(factor(&quot;a&quot;), 1L)
#&amp;gt; Error:
#&amp;gt; ! Can't combine `factor(&quot;a&quot;)` &amp;lt;factor&amp;lt;4d52a&amp;gt;&amp;gt; and `1L` &amp;lt;integer&amp;gt;.




Richness of type


Richness of type is not a very precise notion. It can be about richer
data (for instance a double vector covers more values than an integer
vector), richer behaviour (a data.table has richer behaviour than a
data.frame), or both. If you have trouble determining which one of the
two types is richer, it probably means they shouldn’t be automatically
coercible.
Let’s look again at what happens when we combine a factor and a
character:
vec_ptype2(factor(&quot;a&quot;), &quot;b&quot;)
#&amp;gt; character(0)

The ptype2 method for &amp;lt;character&amp;gt; and &amp;lt;factor&amp;lt;&quot;a&quot;&amp;gt;&amp;gt; returns
&amp;lt;character&amp;gt; because the former is a richer type. The factor can only
contain &quot;a&quot; strings, whereas the character can contain any strings. In
this sense, factors are a subset of character.
Note that another valid behaviour would be to throw an incompatible type
error. This is what a strict factor implementation would do. We have
decided to be laxer in vctrs because it is easy to inadvertently create
factors instead of character vectors, especially with older versions of
R where stringsAsFactors is still true by default.



Consistency and symmetry on permutation


Each ptype2 method should strive to have exactly the same behaviour when
the inputs are permuted. This is not always possible, for example factor
levels are aggregated in order:
vec_ptype2(factor(c(&quot;a&quot;, &quot;c&quot;)), factor(&quot;b&quot;))
#&amp;gt; factor()
#&amp;gt; Levels: a c b

vec_ptype2(factor(&quot;b&quot;), factor(c(&quot;a&quot;, &quot;c&quot;)))
#&amp;gt; factor()
#&amp;gt; Levels: b a c

In any case, permuting the input should not return a fundamentally
different type or introduce an incompatible type error.



Coercion hierarchy


The classes that you can coerce together form a coercion (or subtyping)
hierarchy. Below is a schema of the hierarchy for the base types like
integer and factor. In this diagram the directions of the arrows express
which type is richer. They flow from the bottom (more constrained types)
to the top (richer types).

A coercion hierarchy is distinct from the structural hierarchy implied
by memory types and classes. For instance, in a structural hierarchy,
factors are built on top of integers. But in the coercion hierarchy they
are more related to character vectors. Similarly, subclasses are not
necessarily coercible with their superclasses because the coercion and
structural hierarchies are separate.



Implementing a coercion hierarchy


As a class implementor, you have two options. The simplest is to create
an entirely separate hierarchy. The date and date-time classes are an
example of an S3-based hierarchy that is completely separate.
Alternatively, you can integrate your class in an existing hierarchy,
typically by adding parent nodes on top of the hierarchy (your class is
richer), by adding children node at the root of the hierarchy (your
class is more constrained), or by inserting a node in the tree.
These coercion hierarchies are implicit, in the sense that they are
implied by the vec_ptype2() implementations. There is no structured
way to create or modify a hierarchy, instead you need to implement the
appropriate coercion methods for all the types in your hierarchy, and
diligently return the richer type in each case. The vec_ptype2()
implementations are not transitive nor inherited, so all pairwise
methods between classes lying on a given path must be implemented
manually. This is something we might make easier in the future.






vec_cast()


The second generic, vec_cast(), is the one that looks at the data and
actually performs the conversion. Because it has access to more
information than vec_ptype2(), it may be stricter and cause an error
in more cases. vec_cast() has three possible behaviours:
Determine that the prototypes of the two inputs are not compatible.
This must be decided in exactly the same way as for vec_ptype2().
Call stop_incompatible_cast() if you can determine from the
attributes that the types are not compatible.
Detect incompatible values. Usually this is because the target type is
too restricted for the values supported by the input type. For
example, a fractional number can’t be converted to an integer. The
method should throw an error in that case.
Return the input vector converted to the target type if all values are
compatible. Whereas vec_ptype2() must return the same type when the
inputs are permuted, vec_cast() is directional. It always returns
the type of the right-hand side, or dies trying.





Double dispatch


The dispatch mechanism for vec_ptype2() and vec_cast() looks like S3
but is actually a custom mechanism. Compared to S3, it has the following
differences:
It dispatches on the classes of the first two inputs.
There is no inheritance of ptype2 and cast methods. This is because
the S3 class hierarchy is not necessarily the same as the coercion
hierarchy.
NextMethod() does not work. Parent methods must be called explicitly
if necessary.
The default method is hard-coded.





Data frames


The determination of the common type of data frames with vec_ptype2()
happens in three steps:
Match the columns of the two input data frames. If some columns
don’t exist, they are created and filled with adequately typed NA
values.
Find the common type for each column by calling vec_ptype2() on
each pair of matched columns.
Find the common data frame type. For example the common type of a
grouped tibble and a tibble is a grouped tibble because the latter
is the richer type. The common type of a data table and a data frame
is a data table.


vec_cast() operates similarly. If a data frame is cast to a target
type that has fewer columns, this is an error.
If you are implementing coercion methods for data frames, you will need
to explicitly call the parent methods that perform the common type
determination or the type conversion described above. These are exported
as df_ptype2() and df_cast().
Data frame fallbacks


Being too strict with data frame combinations would cause too much pain
because there are many data frame subclasses in the wild that don’t
implement vctrs methods. We have decided to implement a special fallback
behaviour for foreign data frames. Incompatible data frames fall back to
a base data frame:
df1 &amp;lt;- data.frame(x = 1)
df2 &amp;lt;- structure(df1, class = c(&quot;foreign_df&quot;, &quot;data.frame&quot;))

vec_rbind(df1, df2)
#&amp;gt;   x
#&amp;gt; 1 1
#&amp;gt; 2 1

When a tibble is involved, we fall back to tibble:
df3 &amp;lt;- tibble::as_tibble(df1)

vec_rbind(df1, df3)
#&amp;gt; # A tibble: 2 x 1
#&amp;gt;       x
#&amp;gt;   &amp;lt;dbl&amp;gt;
#&amp;gt; 1     1
#&amp;gt; 2     1

These fallbacks are not ideal but they make sense because all data
frames share a common data structure. This is not generally the case for
vectors. For example factors and characters have different
representations, and it is not possible to find a fallback time
mechanically.
However this fallback has a big downside: implementing vctrs methods for
your data frame subclass is a breaking behaviour change. The proper
coercion behaviour for your data frame class should be specified as soon
as possible to limit the consequences of changing the behaviour of your
class in R scripts.




"><meta property="og:image" content="https://vctrs.r-lib.org/logo.png"><meta name="robots" content="noindex"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><script defer data-domain="vctrs.r-lib.org,all.tidyverse.org" src="https://plausible.io/js/plausible.js"></script></head><body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-none" data-bs-theme="light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">vctrs</a>

    <small class="nav-text text-danger me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="In-development version">0.6.5.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/pillar.html">Printing vectors nicely in tibbles</a>
    <a class="dropdown-item" href="../articles/s3-vector.html">S3 vectors</a>
    <a class="dropdown-item" href="../articles/stability.html">Type and size stability</a>
    <a class="dropdown-item" href="../articles/type-size.html">Prototypes and sizes</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/r-lib/vctrs/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic" id="container">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>FAQ - How does coercion work in vctrs?</h1>
      <small class="dont-index">Source: <a href="https://github.com/r-lib/vctrs/blob/HEAD/R/faq-developer.R" class="external-link"><code>R/faq-developer.R</code></a></small>
      <div class="d-none name"><code>theory-faq-coercion.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>This is an overview of the usage of <code><a href="vec_ptype2.html">vec_ptype2()</a></code> and <code><a href="vec_cast.html">vec_cast()</a></code> and
their role in the vctrs coercion mechanism. Related topics:</p><ul><li><p>For an example of implementing coercion methods for simple vectors,
see <code><a href="howto-faq-coercion.html">?howto-faq-coercion</a></code>.</p></li>
<li><p>For an example of implementing coercion methods for data frame
subclasses, see
<code><a href="howto-faq-coercion-data-frame.html">?howto-faq-coercion-data-frame</a></code>.</p></li>
<li><p>For a tutorial about implementing vctrs classes from scratch, see
<code><a href="../articles/s3-vector.html">vignette("s3-vector")</a></code>.</p></li>
</ul><div class="section">
<h3 id="combination-mechanism-in-vctrs">Combination mechanism in vctrs<a class="anchor" aria-label="anchor" href="#combination-mechanism-in-vctrs"></a></h3>


<p>The coercion system in vctrs is designed to make combination of multiple
inputs consistent and extensible. Combinations occur in many places,
such as row-binding, joins, subset-assignment, or grouped summary
functions that use the split-apply-combine strategy. For example:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_c.html">vec_c</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 1 1</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_c.html">vec_c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error in `vec_c()`:</span></span>
<span><span class="co">#&gt; ! Can't combine `..1` &lt;character&gt; and `..2` &lt;double&gt;.</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_bind.html">vec_rbind</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span>, y <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt;   x  y</span></span>
<span><span class="co">#&gt; 1 1 NA</span></span>
<span><span class="co">#&gt; 2 1  2</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_bind.html">vec_rbind</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="st">"a"</span><span class="op">)</span>,</span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span>, y <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Error in `vec_rbind()`:</span></span>
<span><span class="co">#&gt; ! Can't combine `..1$x` &lt;character&gt; and `..2$x` &lt;double&gt;.</span></span></code></pre><p></p></div>
<p>One major goal of vctrs is to provide a central place for implementing
the coercion methods that make generic combinations possible. The two
relevant generics are <code><a href="vec_ptype2.html">vec_ptype2()</a></code> and <code><a href="vec_cast.html">vec_cast()</a></code>. They both take
two arguments and perform <strong>double dispatch</strong>, meaning that a method is
selected based on the classes of both inputs.</p>
<p>The general mechanism for combining multiple inputs is:</p><ol><li><p>Find the common type of a set of inputs by reducing (as in
<code><a href="https://rdrr.io/r/base/funprog.html" class="external-link">base::Reduce()</a></code> or <code><a href="https://purrr.tidyverse.org/reference/reduce.html" class="external-link">purrr::reduce()</a></code>) the <code><a href="vec_ptype2.html">vec_ptype2()</a></code> binary
function over the set.</p></li>
<li><p>Convert all inputs to the common type with <code><a href="vec_cast.html">vec_cast()</a></code>.</p></li>
<li><p>Initialise the output vector as an instance of this common type with
<code><a href="vec_init.html">vec_init()</a></code>.</p></li>
<li><p>Fill the output vector with the elements of the inputs using
<code><a href="vec_slice.html">vec_assign()</a></code>.</p></li>
</ol><p>The last two steps may require <code><a href="vec_proxy.html">vec_proxy()</a></code> and <code><a href="vec_proxy.html">vec_restore()</a></code>
implementations, unless the attributes of your class are constant and do
not depend on the contents of the vector. We focus here on the first two
steps, which require <code><a href="vec_ptype2.html">vec_ptype2()</a></code> and <code><a href="vec_cast.html">vec_cast()</a></code> implementations.</p>
</div>

<div class="section">
<h3 id="vec-ptype-"><code><a href="vec_ptype2.html">vec_ptype2()</a></code><a class="anchor" aria-label="anchor" href="#vec-ptype-"></a></h3>


<p>Methods for <code><a href="vec_ptype2.html">vec_ptype2()</a></code> are passed two <em>prototypes</em>, i.e. two inputs
emptied of their elements. They implement two behaviours:</p><ul><li><p>If the types of their inputs are compatible, indicate which of them is
the richer type by returning it. If the types are of equal resolution,
return any of the two.</p></li>
<li><p>Throw an error with <code><a href="vctrs-conditions.html">stop_incompatible_type()</a></code> when it can be
determined from the attributes that the types of the inputs are not
compatible.</p></li>
</ul><div class="section">
<h4 id="type-compatibility">Type compatibility<a class="anchor" aria-label="anchor" href="#type-compatibility"></a></h4>


<p>A type is <strong>compatible</strong> with another type if the values it represents
are a subset or a superset of the values of the other type. The notion
of “value” is to be interpreted at a high level, in particular it is not
the same as the memory representation. For example, factors are
represented in memory with integers but their values are more related to
character vectors than to round numbers:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co"># Two factors are compatible</span></span>
<span><span class="fu"><a href="../reference/vec_ptype2.html">vec_ptype2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="st">"a"</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="st">"b"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; factor()</span></span>
<span><span class="co">#&gt; Levels: a b</span></span>
<span></span>
<span><span class="co"># Factors are compatible with a character</span></span>
<span><span class="fu"><a href="../reference/vec_ptype2.html">vec_ptype2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="st">"a"</span><span class="op">)</span>, <span class="st">"b"</span><span class="op">)</span></span>
<span><span class="co">#&gt; character(0)</span></span>
<span></span>
<span><span class="co"># But they are incompatible with integers</span></span>
<span><span class="fu"><a href="../reference/vec_ptype2.html">vec_ptype2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="st">"a"</span><span class="op">)</span>, <span class="fl">1L</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error:</span></span>
<span><span class="co">#&gt; ! Can't combine `factor("a")` &lt;factor&lt;4d52a&gt;&gt; and `1L` &lt;integer&gt;.</span></span></code></pre><p></p></div>
</div>

<div class="section">
<h4 id="richness-of-type">Richness of type<a class="anchor" aria-label="anchor" href="#richness-of-type"></a></h4>


<p>Richness of type is not a very precise notion. It can be about richer
data (for instance a <code>double</code> vector covers more values than an integer
vector), richer behaviour (a <code>data.table</code> has richer behaviour than a
<code>data.frame</code>), or both. If you have trouble determining which one of the
two types is richer, it probably means they shouldn’t be automatically
coercible.</p>
<p>Let’s look again at what happens when we combine a factor and a
character:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_ptype2.html">vec_ptype2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="st">"a"</span><span class="op">)</span>, <span class="st">"b"</span><span class="op">)</span></span>
<span><span class="co">#&gt; character(0)</span></span></code></pre><p></p></div>
<p>The ptype2 method for <code>&lt;character&gt;</code> and <code>&lt;factor&lt;"a"&gt;&gt;</code> returns
<code>&lt;character&gt;</code> because the former is a richer type. The factor can only
contain <code>"a"</code> strings, whereas the character can contain any strings. In
this sense, factors are a <em>subset</em> of character.</p>
<p>Note that another valid behaviour would be to throw an incompatible type
error. This is what a strict factor implementation would do. We have
decided to be laxer in vctrs because it is easy to inadvertently create
factors instead of character vectors, especially with older versions of
R where <code>stringsAsFactors</code> is still true by default.</p>
</div>

<div class="section">
<h4 id="consistency-and-symmetry-on-permutation">Consistency and symmetry on permutation<a class="anchor" aria-label="anchor" href="#consistency-and-symmetry-on-permutation"></a></h4>


<p>Each ptype2 method should strive to have exactly the same behaviour when
the inputs are permuted. This is not always possible, for example factor
levels are aggregated in order:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_ptype2.html">vec_ptype2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="st">"c"</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="st">"b"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; factor()</span></span>
<span><span class="co">#&gt; Levels: a c b</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_ptype2.html">vec_ptype2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="st">"b"</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="st">"c"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; factor()</span></span>
<span><span class="co">#&gt; Levels: b a c</span></span></code></pre><p></p></div>
<p>In any case, permuting the input should not return a fundamentally
different type or introduce an incompatible type error.</p>
</div>

<div class="section">
<h4 id="coercion-hierarchy">Coercion hierarchy<a class="anchor" aria-label="anchor" href="#coercion-hierarchy"></a></h4>


<p>The classes that you can coerce together form a coercion (or subtyping)
hierarchy. Below is a schema of the hierarchy for the base types like
integer and factor. In this diagram the directions of the arrows express
which type is richer. They flow from the bottom (more constrained types)
to the top (richer types).</p>
<p><img src="figures/coerce.png" alt=""></p>
<p>A coercion hierarchy is distinct from the structural hierarchy implied
by memory types and classes. For instance, in a structural hierarchy,
factors are built on top of integers. But in the coercion hierarchy they
are more related to character vectors. Similarly, subclasses are not
necessarily coercible with their superclasses because the coercion and
structural hierarchies are separate.</p>
</div>

<div class="section">
<h4 id="implementing-a-coercion-hierarchy">Implementing a coercion hierarchy<a class="anchor" aria-label="anchor" href="#implementing-a-coercion-hierarchy"></a></h4>


<p>As a class implementor, you have two options. The simplest is to create
an entirely separate hierarchy. The date and date-time classes are an
example of an S3-based hierarchy that is completely separate.
Alternatively, you can integrate your class in an existing hierarchy,
typically by adding parent nodes on top of the hierarchy (your class is
richer), by adding children node at the root of the hierarchy (your
class is more constrained), or by inserting a node in the tree.</p>
<p>These coercion hierarchies are <em>implicit</em>, in the sense that they are
implied by the <code><a href="vec_ptype2.html">vec_ptype2()</a></code> implementations. There is no structured
way to create or modify a hierarchy, instead you need to implement the
appropriate coercion methods for all the types in your hierarchy, and
diligently return the richer type in each case. The <code><a href="vec_ptype2.html">vec_ptype2()</a></code>
implementations are not transitive nor inherited, so all pairwise
methods between classes lying on a given path must be implemented
manually. This is something we might make easier in the future.</p>
</div>


</div>

<div class="section">
<h3 id="vec-cast-"><code><a href="vec_cast.html">vec_cast()</a></code><a class="anchor" aria-label="anchor" href="#vec-cast-"></a></h3>


<p>The second generic, <code><a href="vec_cast.html">vec_cast()</a></code>, is the one that looks at the data and
actually performs the conversion. Because it has access to more
information than <code><a href="vec_ptype2.html">vec_ptype2()</a></code>, it may be stricter and cause an error
in more cases. <code><a href="vec_cast.html">vec_cast()</a></code> has three possible behaviours:</p><ul><li><p>Determine that the prototypes of the two inputs are not compatible.
This must be decided in exactly the same way as for <code><a href="vec_ptype2.html">vec_ptype2()</a></code>.
Call <code><a href="vctrs-conditions.html">stop_incompatible_cast()</a></code> if you can determine from the
attributes that the types are not compatible.</p></li>
<li><p>Detect incompatible values. Usually this is because the target type is
too restricted for the values supported by the input type. For
example, a fractional number can’t be converted to an integer. The
method should throw an error in that case.</p></li>
<li><p>Return the input vector converted to the target type if all values are
compatible. Whereas <code><a href="vec_ptype2.html">vec_ptype2()</a></code> must return the same type when the
inputs are permuted, <code><a href="vec_cast.html">vec_cast()</a></code> is <em>directional</em>. It always returns
the type of the right-hand side, or dies trying.</p></li>
</ul></div>

<div class="section">
<h3 id="double-dispatch">Double dispatch<a class="anchor" aria-label="anchor" href="#double-dispatch"></a></h3>


<p>The dispatch mechanism for <code><a href="vec_ptype2.html">vec_ptype2()</a></code> and <code><a href="vec_cast.html">vec_cast()</a></code> looks like S3
but is actually a custom mechanism. Compared to S3, it has the following
differences:</p><ul><li><p>It dispatches on the classes of the first two inputs.</p></li>
<li><p>There is no inheritance of ptype2 and cast methods. This is because
the S3 class hierarchy is not necessarily the same as the coercion
hierarchy.</p></li>
<li><p><code><a href="https://rdrr.io/r/base/UseMethod.html" class="external-link">NextMethod()</a></code> does not work. Parent methods must be called explicitly
if necessary.</p></li>
<li><p>The default method is hard-coded.</p></li>
</ul></div>

<div class="section">
<h3 id="data-frames">Data frames<a class="anchor" aria-label="anchor" href="#data-frames"></a></h3>


<p>The determination of the common type of data frames with <code><a href="vec_ptype2.html">vec_ptype2()</a></code>
happens in three steps:</p><ol><li><p>Match the columns of the two input data frames. If some columns
don’t exist, they are created and filled with adequately typed <code>NA</code>
values.</p></li>
<li><p>Find the common type for each column by calling <code><a href="vec_ptype2.html">vec_ptype2()</a></code> on
each pair of matched columns.</p></li>
<li><p>Find the common data frame type. For example the common type of a
grouped tibble and a tibble is a grouped tibble because the latter
is the richer type. The common type of a data table and a data frame
is a data table.</p></li>
</ol><p><code><a href="vec_cast.html">vec_cast()</a></code> operates similarly. If a data frame is cast to a target
type that has fewer columns, this is an error.</p>
<p>If you are implementing coercion methods for data frames, you will need
to explicitly call the parent methods that perform the common type
determination or the type conversion described above. These are exported
as <code><a href="df_ptype2.html">df_ptype2()</a></code> and <code><a href="df_ptype2.html">df_cast()</a></code>.</p><div class="section">
<h4 id="data-frame-fallbacks">Data frame fallbacks<a class="anchor" aria-label="anchor" href="#data-frame-fallbacks"></a></h4>


<p>Being too strict with data frame combinations would cause too much pain
because there are many data frame subclasses in the wild that don’t
implement vctrs methods. We have decided to implement a special fallback
behaviour for foreign data frames. Incompatible data frames fall back to
a base data frame:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">df1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">df2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/structure.html" class="external-link">structure</a></span><span class="op">(</span><span class="va">df1</span>, class <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"foreign_df"</span>, <span class="st">"data.frame"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_bind.html">vec_rbind</a></span><span class="op">(</span><span class="va">df1</span>, <span class="va">df2</span><span class="op">)</span></span>
<span><span class="co">#&gt;   x</span></span>
<span><span class="co">#&gt; 1 1</span></span>
<span><span class="co">#&gt; 2 1</span></span></code></pre><p></p></div>
<p>When a tibble is involved, we fall back to tibble:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">df3</span> <span class="op">&lt;-</span> <span class="fu">tibble</span><span class="fu">::</span><span class="fu"><a href="https://tibble.tidyverse.org/reference/as_tibble.html" class="external-link">as_tibble</a></span><span class="op">(</span><span class="va">df1</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_bind.html">vec_rbind</a></span><span class="op">(</span><span class="va">df1</span>, <span class="va">df3</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 2 x 1</span></span>
<span><span class="co">#&gt;       x</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt;</span></span>
<span><span class="co">#&gt; 1     1</span></span>
<span><span class="co">#&gt; 2     1</span></span></code></pre><p></p></div>
<p>These fallbacks are not ideal but they make sense because all data
frames share a common data structure. This is not generally the case for
vectors. For example factors and characters have different
representations, and it is not possible to find a fallback time
mechanically.</p>
<p>However this fallback has a big downside: implementing vctrs methods for
your data frame subclass is a breaking behaviour change. The proper
coercion behaviour for your data frame class should be specified as soon
as possible to limit the consequences of changing the behaviour of your
class in R scripts.</p>
</div>


</div>

    </div>



  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by <a href="https://hadley.nz" class="external-link">Hadley Wickham</a>, <a href="https://github.com/lionel-" class="external-link">Lionel Henry</a>, <a href="https://github.com/DavisVaughan" class="external-link">Davis Vaughan</a>, <a href="https://www.posit.co" class="external-link"><img src="https://www.tidyverse.org/posit-logo.svg" alt="Posit" height="16" width="62" style="margin-bottom: 3px;"></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

  </div></footer></body></html>

