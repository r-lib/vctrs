<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>FAQ - How to implement ptype2 and cast methods? (Data frames) — howto-faq-coercion-data-frame • vctrs</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.9/font.css" rel="stylesheet"><link href="../deps/Source_Code_Pro-0.4.9/font.css" rel="stylesheet"><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="FAQ - How to implement ptype2 and cast methods? (Data frames) — howto-faq-coercion-data-frame"><meta name="description" content="This guide provides a practical recipe for implementing vec_ptype2()
and vec_cast() methods for coercions of data frame subclasses. Related
topics:
For an overview of the coercion mechanism in vctrs, see
?theory-faq-coercion.
For an example of implementing coercion methods for simple vectors,
see ?howto-faq-coercion.


Coercion of data frames occurs when different data frame classes are
combined in some way. The two main methods of combination are currently
row-binding with vec_rbind() and col-binding with
vec_cbind() (which are in turn used by a number of
dplyr and tidyr functions). These functions take multiple data frame
inputs and automatically coerce them to their common type.
vctrs is generally strict about the kind of automatic coercions that are
performed when combining inputs. In the case of data frames we have
decided to be a bit less strict for convenience. Instead of throwing an
incompatible type error, we fall back to a base data frame or a tibble
if we don’t know how to combine two data frame subclasses. It is still a
good idea to specify the proper coercion behaviour for your data frame
subclasses as soon as possible.
We will see two examples in this guide. The first example is about a
data frame subclass that has no particular attributes to manage. In the
second example, we implement coercion methods for a tibble subclass that
includes potentially incompatible attributes.
Roxygen workflow


To implement methods for generics, first import the generics in your
namespace and redocument:
#' @importFrom vctrs vec_ptype2 vec_cast
NULL

Note that for each batches of methods that you add to your package, you
need to export the methods and redocument immediately, even during
development. Otherwise they won’t be in scope when you run unit tests
e.g. with testthat.
Implementing double dispatch methods is very similar to implementing
regular S3 methods. In these examples we are using roxygen2 tags to
register the methods, but you can also register the methods manually in
your NAMESPACE file or lazily with s3_register().



Parent methods


Most of the common type determination should be performed by the parent
class. In vctrs, double dispatch is implemented in such a way that you
need to call the methods for the parent class manually. For
vec_ptype2() this means you need to call df_ptype2() (for data frame
subclasses) or tib_ptype2() (for tibble subclasses). Similarly,
df_cast() and tib_cast() are the workhorses for vec_cast() methods
of subtypes of data.frame and tbl_df. These functions take the union
of the columns in x and y, and ensure shared columns have the same
type.
These functions are much less strict than vec_ptype2() and
vec_cast() as they accept any subclass of data frame as input. They
always return a data.frame or a tbl_df. You will probably want to
write similar functions for your subclass to avoid repetition in your
code. You may want to export them as well if you are expecting other
people to derive from your class.



A data.table example


This example is the actual implementation of vctrs coercion methods for
data.table. This is a simple example because we don’t have to keep
track of attributes for this class or manage incompatibilities. See the
tibble section for a more complicated example.
We first create the dt_ptype2() and dt_cast() helpers. They wrap
around the parent methods df_ptype2() and df_cast(), and transform
the common type or converted input to a data table. You may want to
export these helpers if you expect other packages to derive from your
data frame class.
These helpers should always return data tables. To this end we use the
conversion generic as.data.table(). Depending on the tools available
for the particular class at hand, a constructor might be appropriate as
well.
dt_ptype2 &amp;lt;- function(x, y, ...) {
  as.data.table(df_ptype2(x, y, ...))
}
dt_cast &amp;lt;- function(x, to, ...) {
  as.data.table(df_cast(x, to, ...))
}

We start with the self-self method:
#' @export
vec_ptype2.data.table.data.table &amp;lt;- function(x, y, ...) {
  dt_ptype2(x, y, ...)
}

Between a data frame and a data table, we consider the richer type to be
data table. This decision is not based on the value coverage of each
data structures, but on the idea that data tables have richer behaviour.
Since data tables are the richer type, we call dt_type2() from the
vec_ptype2() method. It always returns a data table, no matter the
order of arguments:
#' @export
vec_ptype2.data.table.data.frame &amp;lt;- function(x, y, ...) {
  dt_ptype2(x, y, ...)
}
#' @export
vec_ptype2.data.frame.data.table &amp;lt;- function(x, y, ...) {
  dt_ptype2(x, y, ...)
}

The vec_cast() methods follow the same pattern, but note how the
method for coercing to data frame uses df_cast() rather than
dt_cast().
Also, please note that for historical reasons, the order of the classes
in the method name is in reverse order of the arguments in the function
signature. The first class represents to, whereas the second class
represents x.
#' @export
vec_cast.data.table.data.table &amp;lt;- function(x, to, ...) {
  dt_cast(x, to, ...)
}
#' @export
vec_cast.data.table.data.frame &amp;lt;- function(x, to, ...) {
  # `x` is a data.frame to be converted to a data.table
  dt_cast(x, to, ...)
}
#' @export
vec_cast.data.frame.data.table &amp;lt;- function(x, to, ...) {
  # `x` is a data.table to be converted to a data.frame
  df_cast(x, to, ...)
}

With these methods vctrs is now able to combine data tables with data
frames:
vec_cbind(data.frame(x = 1:3), data.table(y = &quot;foo&quot;))
#&amp;gt;        x      y
#&amp;gt;    &amp;lt;int&amp;gt; &amp;lt;char&amp;gt;
#&amp;gt; 1:     1    foo
#&amp;gt; 2:     2    foo
#&amp;gt; 3:     3    foo




A tibble example


In this example we implement coercion methods for a tibble subclass that
carries a colour as a scalar metadata:
# User constructor
my_tibble &amp;lt;- function(colour = NULL, ...) {
  new_my_tibble(tibble::tibble(...), colour = colour)
}
# Developer constructor
new_my_tibble &amp;lt;- function(x, colour = NULL) {
  stopifnot(is.data.frame(x))
  tibble::new_tibble(
    x,
    colour = colour,
    class = &quot;my_tibble&quot;,
    nrow = nrow(x)
  )
}

df_colour &amp;lt;- function(x) {
  if (inherits(x, &quot;my_tibble&quot;)) {
    attr(x, &quot;colour&quot;)
  } else {
    NULL
  }
}

#'@export
print.my_tibble &amp;lt;- function(x, ...) {
  cat(sprintf(&quot;&amp;lt;%s: %s&amp;gt;\n&quot;, class(x)[[1]], df_colour(x)))
  cli::cat_line(format(x)[-1])
}

This subclass is very simple. All it does is modify the header.
red &amp;lt;- my_tibble(&quot;red&quot;, x = 1, y = 1:2)
red
#&amp;gt; &amp;lt;my_tibble: red&amp;gt;
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2

red[2]
#&amp;gt; &amp;lt;my_tibble: red&amp;gt;
#&amp;gt;       y
#&amp;gt;   &amp;lt;int&amp;gt;
#&amp;gt; 1     1
#&amp;gt; 2     2

green &amp;lt;- my_tibble(&quot;green&quot;, z = TRUE)
green
#&amp;gt; &amp;lt;my_tibble: green&amp;gt;
#&amp;gt;   z
#&amp;gt;   &amp;lt;lgl&amp;gt;
#&amp;gt; 1 TRUE

Combinations do not work properly out of the box, instead vctrs falls
back to a bare tibble:
vec_rbind(red, tibble::tibble(x = 10:12))
#&amp;gt; # A tibble: 5 x 2
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2
#&amp;gt; 3    10    NA
#&amp;gt; 4    11    NA
#&amp;gt; 5    12    NA

Instead of falling back to a data frame, we would like to return a
&amp;lt;my_tibble&amp;gt; when combined with a data frame or a tibble. Because this
subclass has more metadata than normal data frames (it has a colour), it
is a supertype of tibble and data frame, i.e. it is the richer type.
This is similar to how a grouped tibble is a more general type than a
tibble or a data frame. Conceptually, the latter are pinned to a single
constant group.
The coercion methods for data frames operate in two steps:
They check for compatible subclass attributes. In our case the tibble
colour has to be the same, or be undefined.
They call their parent methods, in this case
tib_ptype2() and tib_cast() because
we have a subclass of tibble. This eventually calls the data frame
methods df_ptype2() and
tib_ptype2() which match the columns and their
types.


This process should usually be wrapped in two functions to avoid
repetition. Consider exporting these if you expect your class to be
derived by other subclasses.
We first implement a helper to determine if two data frames have
compatible colours. We use the df_colour() accessor which returns
NULL when the data frame colour is undefined.
has_compatible_colours &amp;lt;- function(x, y) {
  x_colour &amp;lt;- df_colour(x) %||% df_colour(y)
  y_colour &amp;lt;- df_colour(y) %||% x_colour
  identical(x_colour, y_colour)
}

Next we implement the coercion helpers. If the colours are not
compatible, we call stop_incompatible_cast() or
stop_incompatible_type(). These strict coercion semantics are
justified because in this class colour is a data attribute. If it were
a non essential detail attribute, like the timezone in a datetime, we
would just standardise it to the value of the left-hand side.
In simpler cases (like the data.table example), these methods do not
need to take the arguments suffixed in _arg. Here we do need to take
these arguments so we can pass them to the stop_ functions when we
detect an incompatibility. They also should be passed to the parent
methods.
#' @export
my_tib_cast &amp;lt;- function(x, to, ..., x_arg = &quot;&quot;, to_arg = &quot;&quot;) {
  out &amp;lt;- tib_cast(x, to, ..., x_arg = x_arg, to_arg = to_arg)

  if (!has_compatible_colours(x, to)) {
    stop_incompatible_cast(
      x,
      to,
      x_arg = x_arg,
      to_arg = to_arg,
      details = &quot;Can't combine colours.&quot;
    )
  }

  colour &amp;lt;- df_colour(x) %||% df_colour(to)
  new_my_tibble(out, colour = colour)
}
#' @export
my_tib_ptype2 &amp;lt;- function(x, y, ..., x_arg = &quot;&quot;, y_arg = &quot;&quot;) {
  out &amp;lt;- tib_ptype2(x, y, ..., x_arg = x_arg, y_arg = y_arg)

  if (!has_compatible_colours(x, y)) {
    stop_incompatible_type(
      x,
      y,
      x_arg = x_arg,
      y_arg = y_arg,
      details = &quot;Can't combine colours.&quot;
    )
  }

  colour &amp;lt;- df_colour(x) %||% df_colour(y)
  new_my_tibble(out, colour = colour)
}

Let’s now implement the coercion methods, starting with the self-self
methods.
#' @export
vec_ptype2.my_tibble.my_tibble &amp;lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}
#' @export
vec_cast.my_tibble.my_tibble &amp;lt;- function(x, to, ...) {
  my_tib_cast(x, to, ...)
}

We can now combine compatible instances of our class!
vec_rbind(red, red)
#&amp;gt; &amp;lt;my_tibble: red&amp;gt;
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2
#&amp;gt; 3     1     1
#&amp;gt; 4     1     2

vec_rbind(green, green)
#&amp;gt; &amp;lt;my_tibble: green&amp;gt;
#&amp;gt;   z
#&amp;gt;   &amp;lt;lgl&amp;gt;
#&amp;gt; 1 TRUE
#&amp;gt; 2 TRUE

vec_rbind(green, red)
#&amp;gt; Error in `my_tib_ptype2()`:
#&amp;gt; ! Can't combine `..1` &amp;lt;my_tibble&amp;gt; and `..2` &amp;lt;my_tibble&amp;gt;.
#&amp;gt; Can't combine colours.

The methods for combining our class with tibbles follow the same
pattern. For ptype2 we return our class in both cases because it is the
richer type:
#' @export
vec_ptype2.my_tibble.tbl_df &amp;lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}
#' @export
vec_ptype2.tbl_df.my_tibble &amp;lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}

For cast are careful about returning a tibble when casting to a tibble.
Note the call to vctrs::tib_cast():
#' @export
vec_cast.my_tibble.tbl_df &amp;lt;- function(x, to, ...) {
  my_tib_cast(x, to, ...)
}
#' @export
vec_cast.tbl_df.my_tibble &amp;lt;- function(x, to, ...) {
  tib_cast(x, to, ...)
}

From this point, we get correct combinations with tibbles:
vec_rbind(red, tibble::tibble(x = 10:12))
#&amp;gt; &amp;lt;my_tibble: red&amp;gt;
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2
#&amp;gt; 3    10    NA
#&amp;gt; 4    11    NA
#&amp;gt; 5    12    NA

However we are not done yet. Because the coercion hierarchy is different
from the class hierarchy, there is no inheritance of coercion methods.
We’re not getting correct behaviour for data frames yet because we
haven’t explicitly specified the methods for this class:
vec_rbind(red, data.frame(x = 10:12))
#&amp;gt; # A tibble: 5 x 2
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2
#&amp;gt; 3    10    NA
#&amp;gt; 4    11    NA
#&amp;gt; 5    12    NA

Let’s finish up the boiler plate:
#' @export
vec_ptype2.my_tibble.data.frame &amp;lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}
#' @export
vec_ptype2.data.frame.my_tibble &amp;lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}

#' @export
vec_cast.my_tibble.data.frame &amp;lt;- function(x, to, ...) {
  my_tib_cast(x, to, ...)
}
#' @export
vec_cast.data.frame.my_tibble &amp;lt;- function(x, to, ...) {
  df_cast(x, to, ...)
}

This completes the implementation:
vec_rbind(red, data.frame(x = 10:12))
#&amp;gt; &amp;lt;my_tibble: red&amp;gt;
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2
#&amp;gt; 3    10    NA
#&amp;gt; 4    11    NA
#&amp;gt; 5    12    NA


"><meta property="og:description" content="This guide provides a practical recipe for implementing vec_ptype2()
and vec_cast() methods for coercions of data frame subclasses. Related
topics:
For an overview of the coercion mechanism in vctrs, see
?theory-faq-coercion.
For an example of implementing coercion methods for simple vectors,
see ?howto-faq-coercion.


Coercion of data frames occurs when different data frame classes are
combined in some way. The two main methods of combination are currently
row-binding with vec_rbind() and col-binding with
vec_cbind() (which are in turn used by a number of
dplyr and tidyr functions). These functions take multiple data frame
inputs and automatically coerce them to their common type.
vctrs is generally strict about the kind of automatic coercions that are
performed when combining inputs. In the case of data frames we have
decided to be a bit less strict for convenience. Instead of throwing an
incompatible type error, we fall back to a base data frame or a tibble
if we don’t know how to combine two data frame subclasses. It is still a
good idea to specify the proper coercion behaviour for your data frame
subclasses as soon as possible.
We will see two examples in this guide. The first example is about a
data frame subclass that has no particular attributes to manage. In the
second example, we implement coercion methods for a tibble subclass that
includes potentially incompatible attributes.
Roxygen workflow


To implement methods for generics, first import the generics in your
namespace and redocument:
#' @importFrom vctrs vec_ptype2 vec_cast
NULL

Note that for each batches of methods that you add to your package, you
need to export the methods and redocument immediately, even during
development. Otherwise they won’t be in scope when you run unit tests
e.g. with testthat.
Implementing double dispatch methods is very similar to implementing
regular S3 methods. In these examples we are using roxygen2 tags to
register the methods, but you can also register the methods manually in
your NAMESPACE file or lazily with s3_register().



Parent methods


Most of the common type determination should be performed by the parent
class. In vctrs, double dispatch is implemented in such a way that you
need to call the methods for the parent class manually. For
vec_ptype2() this means you need to call df_ptype2() (for data frame
subclasses) or tib_ptype2() (for tibble subclasses). Similarly,
df_cast() and tib_cast() are the workhorses for vec_cast() methods
of subtypes of data.frame and tbl_df. These functions take the union
of the columns in x and y, and ensure shared columns have the same
type.
These functions are much less strict than vec_ptype2() and
vec_cast() as they accept any subclass of data frame as input. They
always return a data.frame or a tbl_df. You will probably want to
write similar functions for your subclass to avoid repetition in your
code. You may want to export them as well if you are expecting other
people to derive from your class.



A data.table example


This example is the actual implementation of vctrs coercion methods for
data.table. This is a simple example because we don’t have to keep
track of attributes for this class or manage incompatibilities. See the
tibble section for a more complicated example.
We first create the dt_ptype2() and dt_cast() helpers. They wrap
around the parent methods df_ptype2() and df_cast(), and transform
the common type or converted input to a data table. You may want to
export these helpers if you expect other packages to derive from your
data frame class.
These helpers should always return data tables. To this end we use the
conversion generic as.data.table(). Depending on the tools available
for the particular class at hand, a constructor might be appropriate as
well.
dt_ptype2 &amp;lt;- function(x, y, ...) {
  as.data.table(df_ptype2(x, y, ...))
}
dt_cast &amp;lt;- function(x, to, ...) {
  as.data.table(df_cast(x, to, ...))
}

We start with the self-self method:
#' @export
vec_ptype2.data.table.data.table &amp;lt;- function(x, y, ...) {
  dt_ptype2(x, y, ...)
}

Between a data frame and a data table, we consider the richer type to be
data table. This decision is not based on the value coverage of each
data structures, but on the idea that data tables have richer behaviour.
Since data tables are the richer type, we call dt_type2() from the
vec_ptype2() method. It always returns a data table, no matter the
order of arguments:
#' @export
vec_ptype2.data.table.data.frame &amp;lt;- function(x, y, ...) {
  dt_ptype2(x, y, ...)
}
#' @export
vec_ptype2.data.frame.data.table &amp;lt;- function(x, y, ...) {
  dt_ptype2(x, y, ...)
}

The vec_cast() methods follow the same pattern, but note how the
method for coercing to data frame uses df_cast() rather than
dt_cast().
Also, please note that for historical reasons, the order of the classes
in the method name is in reverse order of the arguments in the function
signature. The first class represents to, whereas the second class
represents x.
#' @export
vec_cast.data.table.data.table &amp;lt;- function(x, to, ...) {
  dt_cast(x, to, ...)
}
#' @export
vec_cast.data.table.data.frame &amp;lt;- function(x, to, ...) {
  # `x` is a data.frame to be converted to a data.table
  dt_cast(x, to, ...)
}
#' @export
vec_cast.data.frame.data.table &amp;lt;- function(x, to, ...) {
  # `x` is a data.table to be converted to a data.frame
  df_cast(x, to, ...)
}

With these methods vctrs is now able to combine data tables with data
frames:
vec_cbind(data.frame(x = 1:3), data.table(y = &quot;foo&quot;))
#&amp;gt;        x      y
#&amp;gt;    &amp;lt;int&amp;gt; &amp;lt;char&amp;gt;
#&amp;gt; 1:     1    foo
#&amp;gt; 2:     2    foo
#&amp;gt; 3:     3    foo




A tibble example


In this example we implement coercion methods for a tibble subclass that
carries a colour as a scalar metadata:
# User constructor
my_tibble &amp;lt;- function(colour = NULL, ...) {
  new_my_tibble(tibble::tibble(...), colour = colour)
}
# Developer constructor
new_my_tibble &amp;lt;- function(x, colour = NULL) {
  stopifnot(is.data.frame(x))
  tibble::new_tibble(
    x,
    colour = colour,
    class = &quot;my_tibble&quot;,
    nrow = nrow(x)
  )
}

df_colour &amp;lt;- function(x) {
  if (inherits(x, &quot;my_tibble&quot;)) {
    attr(x, &quot;colour&quot;)
  } else {
    NULL
  }
}

#'@export
print.my_tibble &amp;lt;- function(x, ...) {
  cat(sprintf(&quot;&amp;lt;%s: %s&amp;gt;\n&quot;, class(x)[[1]], df_colour(x)))
  cli::cat_line(format(x)[-1])
}

This subclass is very simple. All it does is modify the header.
red &amp;lt;- my_tibble(&quot;red&quot;, x = 1, y = 1:2)
red
#&amp;gt; &amp;lt;my_tibble: red&amp;gt;
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2

red[2]
#&amp;gt; &amp;lt;my_tibble: red&amp;gt;
#&amp;gt;       y
#&amp;gt;   &amp;lt;int&amp;gt;
#&amp;gt; 1     1
#&amp;gt; 2     2

green &amp;lt;- my_tibble(&quot;green&quot;, z = TRUE)
green
#&amp;gt; &amp;lt;my_tibble: green&amp;gt;
#&amp;gt;   z
#&amp;gt;   &amp;lt;lgl&amp;gt;
#&amp;gt; 1 TRUE

Combinations do not work properly out of the box, instead vctrs falls
back to a bare tibble:
vec_rbind(red, tibble::tibble(x = 10:12))
#&amp;gt; # A tibble: 5 x 2
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2
#&amp;gt; 3    10    NA
#&amp;gt; 4    11    NA
#&amp;gt; 5    12    NA

Instead of falling back to a data frame, we would like to return a
&amp;lt;my_tibble&amp;gt; when combined with a data frame or a tibble. Because this
subclass has more metadata than normal data frames (it has a colour), it
is a supertype of tibble and data frame, i.e. it is the richer type.
This is similar to how a grouped tibble is a more general type than a
tibble or a data frame. Conceptually, the latter are pinned to a single
constant group.
The coercion methods for data frames operate in two steps:
They check for compatible subclass attributes. In our case the tibble
colour has to be the same, or be undefined.
They call their parent methods, in this case
tib_ptype2() and tib_cast() because
we have a subclass of tibble. This eventually calls the data frame
methods df_ptype2() and
tib_ptype2() which match the columns and their
types.


This process should usually be wrapped in two functions to avoid
repetition. Consider exporting these if you expect your class to be
derived by other subclasses.
We first implement a helper to determine if two data frames have
compatible colours. We use the df_colour() accessor which returns
NULL when the data frame colour is undefined.
has_compatible_colours &amp;lt;- function(x, y) {
  x_colour &amp;lt;- df_colour(x) %||% df_colour(y)
  y_colour &amp;lt;- df_colour(y) %||% x_colour
  identical(x_colour, y_colour)
}

Next we implement the coercion helpers. If the colours are not
compatible, we call stop_incompatible_cast() or
stop_incompatible_type(). These strict coercion semantics are
justified because in this class colour is a data attribute. If it were
a non essential detail attribute, like the timezone in a datetime, we
would just standardise it to the value of the left-hand side.
In simpler cases (like the data.table example), these methods do not
need to take the arguments suffixed in _arg. Here we do need to take
these arguments so we can pass them to the stop_ functions when we
detect an incompatibility. They also should be passed to the parent
methods.
#' @export
my_tib_cast &amp;lt;- function(x, to, ..., x_arg = &quot;&quot;, to_arg = &quot;&quot;) {
  out &amp;lt;- tib_cast(x, to, ..., x_arg = x_arg, to_arg = to_arg)

  if (!has_compatible_colours(x, to)) {
    stop_incompatible_cast(
      x,
      to,
      x_arg = x_arg,
      to_arg = to_arg,
      details = &quot;Can't combine colours.&quot;
    )
  }

  colour &amp;lt;- df_colour(x) %||% df_colour(to)
  new_my_tibble(out, colour = colour)
}
#' @export
my_tib_ptype2 &amp;lt;- function(x, y, ..., x_arg = &quot;&quot;, y_arg = &quot;&quot;) {
  out &amp;lt;- tib_ptype2(x, y, ..., x_arg = x_arg, y_arg = y_arg)

  if (!has_compatible_colours(x, y)) {
    stop_incompatible_type(
      x,
      y,
      x_arg = x_arg,
      y_arg = y_arg,
      details = &quot;Can't combine colours.&quot;
    )
  }

  colour &amp;lt;- df_colour(x) %||% df_colour(y)
  new_my_tibble(out, colour = colour)
}

Let’s now implement the coercion methods, starting with the self-self
methods.
#' @export
vec_ptype2.my_tibble.my_tibble &amp;lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}
#' @export
vec_cast.my_tibble.my_tibble &amp;lt;- function(x, to, ...) {
  my_tib_cast(x, to, ...)
}

We can now combine compatible instances of our class!
vec_rbind(red, red)
#&amp;gt; &amp;lt;my_tibble: red&amp;gt;
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2
#&amp;gt; 3     1     1
#&amp;gt; 4     1     2

vec_rbind(green, green)
#&amp;gt; &amp;lt;my_tibble: green&amp;gt;
#&amp;gt;   z
#&amp;gt;   &amp;lt;lgl&amp;gt;
#&amp;gt; 1 TRUE
#&amp;gt; 2 TRUE

vec_rbind(green, red)
#&amp;gt; Error in `my_tib_ptype2()`:
#&amp;gt; ! Can't combine `..1` &amp;lt;my_tibble&amp;gt; and `..2` &amp;lt;my_tibble&amp;gt;.
#&amp;gt; Can't combine colours.

The methods for combining our class with tibbles follow the same
pattern. For ptype2 we return our class in both cases because it is the
richer type:
#' @export
vec_ptype2.my_tibble.tbl_df &amp;lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}
#' @export
vec_ptype2.tbl_df.my_tibble &amp;lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}

For cast are careful about returning a tibble when casting to a tibble.
Note the call to vctrs::tib_cast():
#' @export
vec_cast.my_tibble.tbl_df &amp;lt;- function(x, to, ...) {
  my_tib_cast(x, to, ...)
}
#' @export
vec_cast.tbl_df.my_tibble &amp;lt;- function(x, to, ...) {
  tib_cast(x, to, ...)
}

From this point, we get correct combinations with tibbles:
vec_rbind(red, tibble::tibble(x = 10:12))
#&amp;gt; &amp;lt;my_tibble: red&amp;gt;
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2
#&amp;gt; 3    10    NA
#&amp;gt; 4    11    NA
#&amp;gt; 5    12    NA

However we are not done yet. Because the coercion hierarchy is different
from the class hierarchy, there is no inheritance of coercion methods.
We’re not getting correct behaviour for data frames yet because we
haven’t explicitly specified the methods for this class:
vec_rbind(red, data.frame(x = 10:12))
#&amp;gt; # A tibble: 5 x 2
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2
#&amp;gt; 3    10    NA
#&amp;gt; 4    11    NA
#&amp;gt; 5    12    NA

Let’s finish up the boiler plate:
#' @export
vec_ptype2.my_tibble.data.frame &amp;lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}
#' @export
vec_ptype2.data.frame.my_tibble &amp;lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}

#' @export
vec_cast.my_tibble.data.frame &amp;lt;- function(x, to, ...) {
  my_tib_cast(x, to, ...)
}
#' @export
vec_cast.data.frame.my_tibble &amp;lt;- function(x, to, ...) {
  df_cast(x, to, ...)
}

This completes the implementation:
vec_rbind(red, data.frame(x = 10:12))
#&amp;gt; &amp;lt;my_tibble: red&amp;gt;
#&amp;gt;       x     y
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
#&amp;gt; 1     1     1
#&amp;gt; 2     1     2
#&amp;gt; 3    10    NA
#&amp;gt; 4    11    NA
#&amp;gt; 5    12    NA


"><meta property="og:image" content="https://vctrs.r-lib.org/logo.png"><meta name="robots" content="noindex"><script defer data-domain="vctrs.r-lib.org,all.tidyverse.org" src="https://plausible.io/js/plausible.js"></script></head><body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-none" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">vctrs</a>

    <small class="nav-text text-danger me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="In-development version">0.6.5.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/pillar.html">Printing vectors nicely in tibbles</a></li>
    <li><a class="dropdown-item" href="../articles/s3-vector.html">S3 vectors</a></li>
    <li><a class="dropdown-item" href="../articles/stability.html">Type and size stability</a></li>
    <li><a class="dropdown-item" href="../articles/type-size.html">Prototypes and sizes</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/r-lib/vctrs/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic" id="container">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>FAQ - How to implement ptype2 and cast methods? (Data frames)</h1>
      <small class="dont-index">Source: <a href="https://github.com/r-lib/vctrs/blob/main/R/faq-developer.R" class="external-link"><code>R/faq-developer.R</code></a></small>
      <div class="d-none name"><code>howto-faq-coercion-data-frame.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>This guide provides a practical recipe for implementing <code><a href="vec_ptype2.html">vec_ptype2()</a></code>
and <code><a href="vec_cast.html">vec_cast()</a></code> methods for coercions of data frame subclasses. Related
topics:</p><ul><li><p>For an overview of the coercion mechanism in vctrs, see
<code><a href="theory-faq-coercion.html">?theory-faq-coercion</a></code>.</p></li>
<li><p>For an example of implementing coercion methods for simple vectors,
see <code><a href="howto-faq-coercion.html">?howto-faq-coercion</a></code>.</p></li>
</ul><p>Coercion of data frames occurs when different data frame classes are
combined in some way. The two main methods of combination are currently
row-binding with <code><a href="vec_bind.html">vec_rbind()</a></code> and col-binding with
<code><a href="vec_bind.html">vec_cbind()</a></code> (which are in turn used by a number of
dplyr and tidyr functions). These functions take multiple data frame
inputs and automatically coerce them to their common type.</p>
<p>vctrs is generally strict about the kind of automatic coercions that are
performed when combining inputs. In the case of data frames we have
decided to be a bit less strict for convenience. Instead of throwing an
incompatible type error, we fall back to a base data frame or a tibble
if we don’t know how to combine two data frame subclasses. It is still a
good idea to specify the proper coercion behaviour for your data frame
subclasses as soon as possible.</p>
<p>We will see two examples in this guide. The first example is about a
data frame subclass that has no particular attributes to manage. In the
second example, we implement coercion methods for a tibble subclass that
includes potentially incompatible attributes.</p><div class="section">
<h3 id="roxygen-workflow">Roxygen workflow<a class="anchor" aria-label="anchor" href="#roxygen-workflow"></a></h3>


<p>To implement methods for generics, first import the generics in your
namespace and redocument:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @importFrom vctrs vec_ptype2 vec_cast</span></span>
<span><span class="cn">NULL</span></span></code></pre><p></p></div>
<p>Note that for each batches of methods that you add to your package, you
need to export the methods and redocument immediately, even during
development. Otherwise they won’t be in scope when you run unit tests
e.g. with testthat.</p>
<p>Implementing double dispatch methods is very similar to implementing
regular S3 methods. In these examples we are using roxygen2 tags to
register the methods, but you can also register the methods manually in
your NAMESPACE file or lazily with <code><a href="s3_register.html">s3_register()</a></code>.</p>
</div>

<div class="section">
<h3 id="parent-methods">Parent methods<a class="anchor" aria-label="anchor" href="#parent-methods"></a></h3>


<p>Most of the common type determination should be performed by the parent
class. In vctrs, double dispatch is implemented in such a way that you
need to call the methods for the parent class manually. For
<code><a href="vec_ptype2.html">vec_ptype2()</a></code> this means you need to call <code><a href="df_ptype2.html">df_ptype2()</a></code> (for data frame
subclasses) or <code><a href="df_ptype2.html">tib_ptype2()</a></code> (for tibble subclasses). Similarly,
<code><a href="df_ptype2.html">df_cast()</a></code> and <code><a href="df_ptype2.html">tib_cast()</a></code> are the workhorses for <code><a href="vec_cast.html">vec_cast()</a></code> methods
of subtypes of <code>data.frame</code> and <code>tbl_df</code>. These functions take the union
of the columns in <code>x</code> and <code>y</code>, and ensure shared columns have the same
type.</p>
<p>These functions are much less strict than <code><a href="vec_ptype2.html">vec_ptype2()</a></code> and
<code><a href="vec_cast.html">vec_cast()</a></code> as they accept any subclass of data frame as input. They
always return a <code>data.frame</code> or a <code>tbl_df</code>. You will probably want to
write similar functions for your subclass to avoid repetition in your
code. You may want to export them as well if you are expecting other
people to derive from your class.</p>
</div>

<div class="section">
<h3 id="a-data-table-example">A <code>data.table</code> example<a class="anchor" aria-label="anchor" href="#a-data-table-example"></a></h3>


<p>This example is the actual implementation of vctrs coercion methods for
<code>data.table</code>. This is a simple example because we don’t have to keep
track of attributes for this class or manage incompatibilities. See the
tibble section for a more complicated example.</p>
<p>We first create the <code>dt_ptype2()</code> and <code>dt_cast()</code> helpers. They wrap
around the parent methods <code><a href="df_ptype2.html">df_ptype2()</a></code> and <code><a href="df_ptype2.html">df_cast()</a></code>, and transform
the common type or converted input to a data table. You may want to
export these helpers if you expect other packages to derive from your
data frame class.</p>
<p>These helpers should always return data tables. To this end we use the
conversion generic <code>as.data.table()</code>. Depending on the tools available
for the particular class at hand, a constructor might be appropriate as
well.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">dt_ptype2</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">as.data.table</span><span class="op">(</span><span class="fu"><a href="../reference/df_ptype2.html">df_ptype2</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="va">dt_cast</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">as.data.table</span><span class="op">(</span><span class="fu"><a href="../reference/df_ptype2.html">df_cast</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>We start with the self-self method:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.data.table.data.table</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">dt_ptype2</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>Between a data frame and a data table, we consider the richer type to be
data table. This decision is not based on the value coverage of each
data structures, but on the idea that data tables have richer behaviour.
Since data tables are the richer type, we call <code>dt_type2()</code> from the
<code><a href="vec_ptype2.html">vec_ptype2()</a></code> method. It always returns a data table, no matter the
order of arguments:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.data.table.data.frame</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">dt_ptype2</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.data.frame.data.table</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">dt_ptype2</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>The <code><a href="vec_cast.html">vec_cast()</a></code> methods follow the same pattern, but note how the
method for coercing to data frame uses <code><a href="df_ptype2.html">df_cast()</a></code> rather than
<code>dt_cast()</code>.</p>
<p>Also, please note that for historical reasons, the order of the classes
in the method name is in reverse order of the arguments in the function
signature. The first class represents <code>to</code>, whereas the second class
represents <code>x</code>.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.data.table.data.table</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">dt_cast</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.data.table.data.frame</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># `x` is a data.frame to be converted to a data.table</span></span>
<span>  <span class="fu">dt_cast</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.data.frame.data.table</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># `x` is a data.table to be converted to a data.frame</span></span>
<span>  <span class="fu"><a href="../reference/df_ptype2.html">df_cast</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>With these methods vctrs is now able to combine data tables with data
frames:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_bind.html">vec_cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span>, <span class="fu">data.table</span><span class="op">(</span>y <span class="op">=</span> <span class="st">"foo"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;        x      y</span></span>
<span><span class="co">#&gt;    &lt;int&gt; &lt;char&gt;</span></span>
<span><span class="co">#&gt; 1:     1    foo</span></span>
<span><span class="co">#&gt; 2:     2    foo</span></span>
<span><span class="co">#&gt; 3:     3    foo</span></span></code></pre><p></p></div>
</div>

<div class="section">
<h3 id="a-tibble-example">A tibble example<a class="anchor" aria-label="anchor" href="#a-tibble-example"></a></h3>


<p>In this example we implement coercion methods for a tibble subclass that
carries a colour as a scalar metadata:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co"># User constructor</span></span>
<span><span class="va">my_tibble</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">colour</span> <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">new_my_tibble</span><span class="op">(</span><span class="fu">tibble</span><span class="fu">::</span><span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html" class="external-link">tibble</a></span><span class="op">(</span><span class="va">...</span><span class="op">)</span>, colour <span class="op">=</span> <span class="va">colour</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co"># Developer constructor</span></span>
<span><span class="va">new_my_tibble</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">colour</span> <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/stopifnot.html" class="external-link">stopifnot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">is.data.frame</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="fu">tibble</span><span class="fu">::</span><span class="fu"><a href="https://tibble.tidyverse.org/reference/new_tibble.html" class="external-link">new_tibble</a></span><span class="op">(</span></span>
<span>    <span class="va">x</span>,</span>
<span>    colour <span class="op">=</span> <span class="va">colour</span>,</span>
<span>    class <span class="op">=</span> <span class="st">"my_tibble"</span>,</span>
<span>    nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">df_colour</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/class.html" class="external-link">inherits</a></span><span class="op">(</span><span class="va">x</span>, <span class="st">"my_tibble"</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/attr.html" class="external-link">attr</a></span><span class="op">(</span><span class="va">x</span>, <span class="st">"colour"</span><span class="op">)</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span>    <span class="cn">NULL</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#'@export</span></span>
<span><span class="va">print.my_tibble</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sprintf.html" class="external-link">sprintf</a></span><span class="op">(</span><span class="st">"&lt;%s: %s&gt;\n"</span>, <span class="fu"><a href="https://rdrr.io/r/base/class.html" class="external-link">class</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, <span class="fu">df_colour</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="fu">cli</span><span class="fu">::</span><span class="fu"><a href="https://cli.r-lib.org/reference/cat_line.html" class="external-link">cat_line</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/format.html" class="external-link">format</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>This subclass is very simple. All it does is modify the header.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">red</span> <span class="op">&lt;-</span> <span class="fu">my_tibble</span><span class="op">(</span><span class="st">"red"</span>, x <span class="op">=</span> <span class="fl">1</span>, y <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">red</span></span>
<span><span class="co">#&gt; &lt;my_tibble: red&gt;</span></span>
<span><span class="co">#&gt;       x     y</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt; &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1     1     1</span></span>
<span><span class="co">#&gt; 2     1     2</span></span>
<span></span>
<span><span class="va">red</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span><span class="co">#&gt; &lt;my_tibble: red&gt;</span></span>
<span><span class="co">#&gt;       y</span></span>
<span><span class="co">#&gt;   &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1     1</span></span>
<span><span class="co">#&gt; 2     2</span></span>
<span></span>
<span><span class="va">green</span> <span class="op">&lt;-</span> <span class="fu">my_tibble</span><span class="op">(</span><span class="st">"green"</span>, z <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">green</span></span>
<span><span class="co">#&gt; &lt;my_tibble: green&gt;</span></span>
<span><span class="co">#&gt;   z</span></span>
<span><span class="co">#&gt;   &lt;lgl&gt;</span></span>
<span><span class="co">#&gt; 1 TRUE</span></span></code></pre><p></p></div>
<p>Combinations do not work properly out of the box, instead vctrs falls
back to a bare tibble:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_bind.html">vec_rbind</a></span><span class="op">(</span><span class="va">red</span>, <span class="fu">tibble</span><span class="fu">::</span><span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html" class="external-link">tibble</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">10</span><span class="op">:</span><span class="fl">12</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 5 x 2</span></span>
<span><span class="co">#&gt;       x     y</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt; &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1     1     1</span></span>
<span><span class="co">#&gt; 2     1     2</span></span>
<span><span class="co">#&gt; 3    10    NA</span></span>
<span><span class="co">#&gt; 4    11    NA</span></span>
<span><span class="co">#&gt; 5    12    NA</span></span></code></pre><p></p></div>
<p>Instead of falling back to a data frame, we would like to return a
<code>&lt;my_tibble&gt;</code> when combined with a data frame or a tibble. Because this
subclass has more metadata than normal data frames (it has a colour), it
is a <em>supertype</em> of tibble and data frame, i.e. it is the richer type.
This is similar to how a grouped tibble is a more general type than a
tibble or a data frame. Conceptually, the latter are pinned to a single
constant group.</p>
<p>The coercion methods for data frames operate in two steps:</p><ul><li><p>They check for compatible subclass attributes. In our case the tibble
colour has to be the same, or be undefined.</p></li>
<li><p>They call their parent methods, in this case
<code><a href="df_ptype2.html">tib_ptype2()</a></code> and <code><a href="df_ptype2.html">tib_cast()</a></code> because
we have a subclass of tibble. This eventually calls the data frame
methods <code><a href="df_ptype2.html">df_ptype2()</a></code> and
<code><a href="df_ptype2.html">tib_ptype2()</a></code> which match the columns and their
types.</p></li>
</ul><p>This process should usually be wrapped in two functions to avoid
repetition. Consider exporting these if you expect your class to be
derived by other subclasses.</p>
<p>We first implement a helper to determine if two data frames have
compatible colours. We use the <code>df_colour()</code> accessor which returns
<code>NULL</code> when the data frame colour is undefined.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">has_compatible_colours</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">x_colour</span> <span class="op">&lt;-</span> <span class="fu">df_colour</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/Control.html" class="external-link">%||%</a></span> <span class="fu">df_colour</span><span class="op">(</span><span class="va">y</span><span class="op">)</span></span>
<span>  <span class="va">y_colour</span> <span class="op">&lt;-</span> <span class="fu">df_colour</span><span class="op">(</span><span class="va">y</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/Control.html" class="external-link">%||%</a></span> <span class="va">x_colour</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/identical.html" class="external-link">identical</a></span><span class="op">(</span><span class="va">x_colour</span>, <span class="va">y_colour</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>Next we implement the coercion helpers. If the colours are not
compatible, we call <code><a href="vctrs-conditions.html">stop_incompatible_cast()</a></code> or
<code><a href="vctrs-conditions.html">stop_incompatible_type()</a></code>. These strict coercion semantics are
justified because in this class colour is a <em>data</em> attribute. If it were
a non essential <em>detail</em> attribute, like the timezone in a datetime, we
would just standardise it to the value of the left-hand side.</p>
<p>In simpler cases (like the data.table example), these methods do not
need to take the arguments suffixed in <code>_arg</code>. Here we do need to take
these arguments so we can pass them to the <code>stop_</code> functions when we
detect an incompatibility. They also should be passed to the parent
methods.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">my_tib_cast</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span>, <span class="va">x_arg</span> <span class="op">=</span> <span class="st">""</span>, <span class="va">to_arg</span> <span class="op">=</span> <span class="st">""</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">out</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/df_ptype2.html">tib_cast</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span>, x_arg <span class="op">=</span> <span class="va">x_arg</span>, to_arg <span class="op">=</span> <span class="va">to_arg</span><span class="op">)</span></span>
<span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="fu">has_compatible_colours</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="../reference/vctrs-conditions.html">stop_incompatible_cast</a></span><span class="op">(</span></span>
<span>      <span class="va">x</span>,</span>
<span>      <span class="va">to</span>,</span>
<span>      x_arg <span class="op">=</span> <span class="va">x_arg</span>,</span>
<span>      to_arg <span class="op">=</span> <span class="va">to_arg</span>,</span>
<span>      details <span class="op">=</span> <span class="st">"Can't combine colours."</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span></span>
<span>  <span class="va">colour</span> <span class="op">&lt;-</span> <span class="fu">df_colour</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/Control.html" class="external-link">%||%</a></span> <span class="fu">df_colour</span><span class="op">(</span><span class="va">to</span><span class="op">)</span></span>
<span>  <span class="fu">new_my_tibble</span><span class="op">(</span><span class="va">out</span>, colour <span class="op">=</span> <span class="va">colour</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">my_tib_ptype2</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span>, <span class="va">x_arg</span> <span class="op">=</span> <span class="st">""</span>, <span class="va">y_arg</span> <span class="op">=</span> <span class="st">""</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">out</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/df_ptype2.html">tib_ptype2</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span>, x_arg <span class="op">=</span> <span class="va">x_arg</span>, y_arg <span class="op">=</span> <span class="va">y_arg</span><span class="op">)</span></span>
<span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="fu">has_compatible_colours</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="../reference/vctrs-conditions.html">stop_incompatible_type</a></span><span class="op">(</span></span>
<span>      <span class="va">x</span>,</span>
<span>      <span class="va">y</span>,</span>
<span>      x_arg <span class="op">=</span> <span class="va">x_arg</span>,</span>
<span>      y_arg <span class="op">=</span> <span class="va">y_arg</span>,</span>
<span>      details <span class="op">=</span> <span class="st">"Can't combine colours."</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span></span>
<span>  <span class="va">colour</span> <span class="op">&lt;-</span> <span class="fu">df_colour</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/Control.html" class="external-link">%||%</a></span> <span class="fu">df_colour</span><span class="op">(</span><span class="va">y</span><span class="op">)</span></span>
<span>  <span class="fu">new_my_tibble</span><span class="op">(</span><span class="va">out</span>, colour <span class="op">=</span> <span class="va">colour</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>Let’s now implement the coercion methods, starting with the self-self
methods.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.my_tibble.my_tibble</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">my_tib_ptype2</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.my_tibble.my_tibble</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">my_tib_cast</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>We can now combine compatible instances of our class!</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_bind.html">vec_rbind</a></span><span class="op">(</span><span class="va">red</span>, <span class="va">red</span><span class="op">)</span></span>
<span><span class="co">#&gt; &lt;my_tibble: red&gt;</span></span>
<span><span class="co">#&gt;       x     y</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt; &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1     1     1</span></span>
<span><span class="co">#&gt; 2     1     2</span></span>
<span><span class="co">#&gt; 3     1     1</span></span>
<span><span class="co">#&gt; 4     1     2</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_bind.html">vec_rbind</a></span><span class="op">(</span><span class="va">green</span>, <span class="va">green</span><span class="op">)</span></span>
<span><span class="co">#&gt; &lt;my_tibble: green&gt;</span></span>
<span><span class="co">#&gt;   z</span></span>
<span><span class="co">#&gt;   &lt;lgl&gt;</span></span>
<span><span class="co">#&gt; 1 TRUE</span></span>
<span><span class="co">#&gt; 2 TRUE</span></span>
<span></span>
<span><span class="fu"><a href="../reference/vec_bind.html">vec_rbind</a></span><span class="op">(</span><span class="va">green</span>, <span class="va">red</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error in `my_tib_ptype2()`:</span></span>
<span><span class="co">#&gt; ! Can't combine `..1` &lt;my_tibble&gt; and `..2` &lt;my_tibble&gt;.</span></span>
<span><span class="co">#&gt; Can't combine colours.</span></span></code></pre><p></p></div>
<p>The methods for combining our class with tibbles follow the same
pattern. For ptype2 we return our class in both cases because it is the
richer type:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.my_tibble.tbl_df</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">my_tib_ptype2</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.tbl_df.my_tibble</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">my_tib_ptype2</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>For cast are careful about returning a tibble when casting to a tibble.
Note the call to <code><a href="df_ptype2.html">vctrs::tib_cast()</a></code>:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.my_tibble.tbl_df</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">my_tib_cast</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.tbl_df.my_tibble</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="../reference/df_ptype2.html">tib_cast</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>From this point, we get correct combinations with tibbles:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_bind.html">vec_rbind</a></span><span class="op">(</span><span class="va">red</span>, <span class="fu">tibble</span><span class="fu">::</span><span class="fu"><a href="https://tibble.tidyverse.org/reference/tibble.html" class="external-link">tibble</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">10</span><span class="op">:</span><span class="fl">12</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; &lt;my_tibble: red&gt;</span></span>
<span><span class="co">#&gt;       x     y</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt; &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1     1     1</span></span>
<span><span class="co">#&gt; 2     1     2</span></span>
<span><span class="co">#&gt; 3    10    NA</span></span>
<span><span class="co">#&gt; 4    11    NA</span></span>
<span><span class="co">#&gt; 5    12    NA</span></span></code></pre><p></p></div>
<p>However we are not done yet. Because the coercion hierarchy is different
from the class hierarchy, there is no inheritance of coercion methods.
We’re not getting correct behaviour for data frames yet because we
haven’t explicitly specified the methods for this class:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_bind.html">vec_rbind</a></span><span class="op">(</span><span class="va">red</span>, <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">10</span><span class="op">:</span><span class="fl">12</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 5 x 2</span></span>
<span><span class="co">#&gt;       x     y</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt; &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1     1     1</span></span>
<span><span class="co">#&gt; 2     1     2</span></span>
<span><span class="co">#&gt; 3    10    NA</span></span>
<span><span class="co">#&gt; 4    11    NA</span></span>
<span><span class="co">#&gt; 5    12    NA</span></span></code></pre><p></p></div>
<p>Let’s finish up the boiler plate:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.my_tibble.data.frame</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">my_tib_ptype2</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_ptype2.data.frame.my_tibble</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">my_tib_ptype2</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.my_tibble.data.frame</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">my_tib_cast</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#' @export</span></span>
<span><span class="va">vec_cast.data.frame.my_tibble</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="../reference/df_ptype2.html">df_cast</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">to</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>This completes the implementation:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/vec_bind.html">vec_rbind</a></span><span class="op">(</span><span class="va">red</span>, <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">10</span><span class="op">:</span><span class="fl">12</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; &lt;my_tibble: red&gt;</span></span>
<span><span class="co">#&gt;       x     y</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt; &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1     1     1</span></span>
<span><span class="co">#&gt; 2     1     2</span></span>
<span><span class="co">#&gt; 3    10    NA</span></span>
<span><span class="co">#&gt; 4    11    NA</span></span>
<span><span class="co">#&gt; 5    12    NA</span></span></code></pre><p></p></div>
</div>

    </div>



  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by <a href="https://hadley.nz" class="external-link">Hadley Wickham</a>, <a href="https://github.com/lionel-" class="external-link">Lionel Henry</a>, <a href="https://github.com/DavisVaughan" class="external-link">Davis Vaughan</a>, <a href="https://www.posit.co" class="external-link"><img src="https://www.tidyverse.org/posit-logo.svg" alt="Posit" height="16" width="62" style="margin-bottom: 3px;"></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

  </div></footer></body></html>

