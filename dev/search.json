[{"path":[]},{"path":"https://vctrs.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://vctrs.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://vctrs.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://vctrs.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://vctrs.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@posit.co. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://vctrs.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://vctrs.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://vctrs.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://vctrs.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://vctrs.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://vctrs.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://vctrs.r-lib.org/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 vctrs authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://vctrs.r-lib.org/dev/articles/pillar.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Printing vectors nicely in tibbles","text":"illustrate basic ideas ’re going create \"latlon\" class encodes geographic coordinates record. ’ll pretend code lives package called earth. simplicity, values printed degrees minutes . using vctrs_rcrd(), already get infrastructure make class fully compatible data frames free. See vignette(\"s3-vector\", package = \"vctrs\") details record data type.","code":"#' @export latlon <- function(lat, lon) {   new_rcrd(list(lat = lat, lon = lon), class = \"earth_latlon\") }  #' @export format.earth_latlon <- function(x, ..., formatter = deg_min) {   x_valid <- which(!is.na(x))    lat <- field(x, \"lat\")[x_valid]   lon <- field(x, \"lon\")[x_valid]    ret <- rep(NA_character_, vec_size(x))   ret[x_valid] <- paste0(formatter(lat, \"lat\"), \" \", formatter(lon, \"lon\"))   # It's important to keep NA in the vector!   ret }  deg_min <- function(x, direction) {   pm <- if (direction == \"lat\") c(\"N\", \"S\") else c(\"E\", \"W\")    sign <- sign(x)   x <- abs(x)   deg <- trunc(x)   x <- x - deg   min <- round(x * 60)    # Ensure the columns are always the same width so they line up nicely   ret <- sprintf(\"%d°%.2d'%s\", deg, min, ifelse(sign >= 0, pm[[1]], pm[[2]]))   format(ret, justify = \"right\") }  latlon(c(32.71, 2.95), c(-117.17, 1.67)) #> <earth_latlon[2]> #> [1] 32°43'N 117°10'W  2°57'N   1°40'E"},{"path":"https://vctrs.r-lib.org/dev/articles/pillar.html","id":"using-in-a-tibble","dir":"Articles","previous_headings":"","what":"Using in a tibble","title":"Printing vectors nicely in tibbles","text":"Columns class can used tibble right away ’ve made class using vctrs infrastructure provided format() method: output ok, improve : Using description type abbreviation <erth_ltl>. Using dash colour highlight important parts value. Providing narrower view horizontal space premium. following sections show enhance rendering.","code":"library(tibble) #>  #> Attaching package: 'tibble' #> The following object is masked from 'package:vctrs': #>  #>     data_frame  loc <- latlon(   c(28.3411783, 32.7102978, 30.2622356, 37.7859102, 28.5, NA),   c(-81.5480348, -117.1704058, -97.7403327, -122.4131357, -81.4, NA) )  data <- tibble(venue = \"rstudio::conf\", year = 2017:2022, loc = loc)  data #> # A tibble: 6 × 3 #>   venue          year              loc #>   <chr>         <int>       <erth_ltl> #> 1 rstudio::conf  2017 28°20'N  81°33'W #> 2 rstudio::conf  2018 32°43'N 117°10'W #> 3 rstudio::conf  2019 30°16'N  97°44'W #> 4 rstudio::conf  2020 37°47'N 122°25'W #> 5 rstudio::conf  2021 28°30'N  81°24'W #> 6 rstudio::conf  2022               NA"},{"path":"https://vctrs.r-lib.org/dev/articles/pillar.html","id":"fixing-the-data-type","dir":"Articles","previous_headings":"","what":"Fixing the data type","title":"Printing vectors nicely in tibbles","text":"Instead <erth_ltl> ’d prefer use <latlon>. can implementing vec_ptype_abbr() method, return string can used column header. classes, strive evocative abbreviation ’s 6 characters.","code":"#' @export vec_ptype_abbr.earth_latlon <- function(x) {   \"latlon\" }  data #> # A tibble: 6 × 3 #>   venue          year              loc #>   <chr>         <int>         <latlon> #> 1 rstudio::conf  2017 28°20'N  81°33'W #> 2 rstudio::conf  2018 32°43'N 117°10'W #> 3 rstudio::conf  2019 30°16'N  97°44'W #> 4 rstudio::conf  2020 37°47'N 122°25'W #> 5 rstudio::conf  2021 28°30'N  81°24'W #> 6 rstudio::conf  2022               NA"},{"path":"https://vctrs.r-lib.org/dev/articles/pillar.html","id":"custom-rendering","dir":"Articles","previous_headings":"","what":"Custom rendering","title":"Printing vectors nicely in tibbles","text":"format() method used default rendering. custom formatting need implement pillar_shaft() method. function always return pillar shaft object, created new_pillar_shaft_simple() similar. new_pillar_shaft_simple() accepts ANSI escape codes colouring, pillar includes built styles like style_subtle(). can use subtle style degree minute separators make data obvious. First define degree formatter makes use style_subtle(): pass format() method: Currently, ANSI escapes rendered vignettes, result doesn’t look different, run code ’ll see improved display. well functions pillar, cli package provides variety tools styling text.","code":"deg_min_color <- function(x, direction) {   pm <- if (direction == \"lat\") c(\"N\", \"S\") else c(\"E\", \"W\")    sign <- sign(x)   x <- abs(x)   deg <- trunc(x)   x <- x - deg   rad <- round(x * 60)   ret <- sprintf(     \"%d%s%.2d%s%s\",     deg,     pillar::style_subtle(\"°\"),     rad,     pillar::style_subtle(\"'\"),     pm[ifelse(sign >= 0, 1, 2)]   )   format(ret, justify = \"right\") } #' @importFrom pillar pillar_shaft #' @export pillar_shaft.earth_latlon <- function(x, ...) {   out <- format(x, formatter = deg_min_color)   pillar::new_pillar_shaft_simple(out, align = \"right\") } data #> # A tibble: 6 × 3 #>   venue          year              loc #>   <chr>         <int>         <latlon> #> 1 rstudio::conf  2017 28°20'N  81°33'W #> 2 rstudio::conf  2018 32°43'N 117°10'W #> 3 rstudio::conf  2019 30°16'N  97°44'W #> 4 rstudio::conf  2020 37°47'N 122°25'W #> 5 rstudio::conf  2021 28°30'N  81°24'W #> 6 rstudio::conf  2022               NA"},{"path":"https://vctrs.r-lib.org/dev/articles/pillar.html","id":"truncation","dir":"Articles","previous_headings":"","what":"Truncation","title":"Printing vectors nicely in tibbles","text":"Tibbles can automatically compacts columns ’s enough horizontal space display everything: Currently latlon class isn’t ever compacted haven’t specified minimum width constructing shaft. Let’s fix re-print data:","code":"print(data, width = 30) #> # A tibble: 6 × 3 #>   venue  year              loc #>   <chr> <int>         <latlon> #> 1 rstu…  2017 28°20'N  81°33'W #> 2 rstu…  2018 32°43'N 117°10'W #> 3 rstu…  2019 30°16'N  97°44'W #> 4 rstu…  2020 37°47'N 122°25'W #> 5 rstu…  2021 28°30'N  81°24'W #> 6 rstu…  2022               NA #' @importFrom pillar pillar_shaft #' @export pillar_shaft.earth_latlon <- function(x, ...) {   out <- format(x)   pillar::new_pillar_shaft_simple(out, align = \"right\", min_width = 10) }  print(data, width = 30) #> # A tibble: 6 × 3 #>   venue        year        loc #>   <chr>       <int>   <latlon> #> 1 rstudio::c…  2017 28°20'N  … #> 2 rstudio::c…  2018 32°43'N 1… #> 3 rstudio::c…  2019 30°16'N  … #> 4 rstudio::c…  2020 37°47'N 1… #> 5 rstudio::c…  2021 28°30'N  … #> 6 rstudio::c…  2022         NA"},{"path":"https://vctrs.r-lib.org/dev/articles/pillar.html","id":"adaptive-rendering","dir":"Articles","previous_headings":"","what":"Adaptive rendering","title":"Printing vectors nicely in tibbles","text":"Truncation may useful character data, lat-lon data ’d nicer show full degrees remove minutes. ’ll first write function : use part sophisticated implementation pillar_shaft() method: Now pillar_shaft() method returns object class \"pillar_shaft_latlon\" created new_pillar_shaft(). object contains necessary information render values, also minimum maximum width values. simplicity, formats pre-rendered, minimum maximum widths computed . (get_max_extent() helper computes maximum display width occupied values character vector.) ’s left implement format() method new \"pillar_shaft_latlon\" class. method called width argument, determines formats choose. formatting choice passed new_ornament() function:","code":"deg <- function(x, direction) {   pm <- if (direction == \"lat\") c(\"N\", \"S\") else c(\"E\", \"W\")    sign <- sign(x)   x <- abs(x)   deg <- round(x)    ret <- sprintf(\"%d°%s\", deg, pm[ifelse(sign >= 0, 1, 2)])   format(ret, justify = \"right\") } #' @importFrom pillar pillar_shaft #' @export pillar_shaft.earth_latlon <- function(x, ...) {   deg <- format(x, formatter = deg)   deg_min <- format(x)    pillar::new_pillar_shaft(     list(deg = deg, deg_min = deg_min),     width = pillar::get_max_extent(deg_min),     min_width = pillar::get_max_extent(deg),     class = \"pillar_shaft_latlon\"   ) } #' @export format.pillar_shaft_latlon <- function(x, width, ...) {   if (get_max_extent(x$deg_min) <= width) {     ornament <- x$deg_min   } else {     ornament <- x$deg   }    pillar::new_ornament(ornament, align = \"right\") }  data #> # A tibble: 6 × 3 #>   venue          year              loc #>   <chr>         <int>         <latlon> #> 1 rstudio::conf  2017 28°20'N  81°33'W #> 2 rstudio::conf  2018 32°43'N 117°10'W #> 3 rstudio::conf  2019 30°16'N  97°44'W #> 4 rstudio::conf  2020 37°47'N 122°25'W #> 5 rstudio::conf  2021 28°30'N  81°24'W #> 6 rstudio::conf  2022               NA print(data, width = 30) #> # A tibble: 6 × 3 #>   venue        year        loc #>   <chr>       <int>   <latlon> #> 1 rstudio::c…  2017 28°N  82°W #> 2 rstudio::c…  2018 33°N 117°W #> 3 rstudio::c…  2019 30°N  98°W #> 4 rstudio::c…  2020 38°N 122°W #> 5 rstudio::c…  2021 28°N  81°W #> 6 rstudio::c…  2022         NA"},{"path":"https://vctrs.r-lib.org/dev/articles/pillar.html","id":"testing","dir":"Articles","previous_headings":"","what":"Testing","title":"Printing vectors nicely in tibbles","text":"want test output code, can compare known state recorded text file. testthat::expect_snapshot() function offers easy way test output-generating functions. takes care details Unicode, ANSI escapes, output width. Furthermore won’t make tests fail CRAN. important output may rely details control, fixed eventually lead package removed CRAN. Use testthat expectation one test files create snapshot test: See https://testthat.r-lib.org/articles/snapshotting.html information.","code":"expect_snapshot(pillar_shaft(data$loc))"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"basics","dir":"Articles","previous_headings":"","what":"Basics","title":"S3 vectors","text":"section ’ll learn create new vctrs class calling new_vctr(). creates object class vctrs_vctr number methods. designed make life easy possible. example: print() str() methods defined terms format() get pleasant, consistent display soon ’ve made format() method. can immediately put new vector class data frame .data.frame.vctrs_vctr() right thing. Subsetting ([, [[, $), length<-, rep() methods automatically preserve attributes use vec_restore(). default vec_restore() works classes attributes data-independent, can easily customised attributes depend data. Default subset-assignment methods ([<-, [[<-, $<-) follow principle new values coerced match existing vector. gives predictable behaviour clear error messages.","code":""},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"percent-class","dir":"Articles","previous_headings":"Basics","what":"Percent class","title":"S3 vectors","text":"section, ’ll show make percent class, .e., double vector printed percentage. start defining low-level constructor check types /sizes call new_vctr(). percent built double vector length doesn’t attributes. Note prefix name class name package. prevents conflicting definitions packages. packages implement one class (blob), ’s fine use package name without prefix class name. follow user friendly helper. ’ll use vec_cast() allow accept anything coercible double: go , check user-friendly constructor returns zero-length vector called arguments. makes easy use prototype. convenience users, consider implementing is_percent() function:","code":"new_percent <- function(x = double()) {   if (!is_double(x)) {     abort(\"`x` must be a double vector.\")   }   new_vctr(x, class = \"vctrs_percent\") }  x <- new_percent(c(seq(0, 1, length.out = 4), NA)) x #> <vctrs_percent[5]> #> [1] 0.0000000 0.3333333 0.6666667 1.0000000        NA  str(x) #>  vctrs_pr [1:5] 0.0000000, 0.3333333, 0.6666667, 1.0000000,        NA percent <- function(x = double()) {   x <- vec_cast(x, double())   new_percent(x) } new_percent() #> <vctrs_percent[0]> percent() #> <vctrs_percent[0]> is_percent <- function(x) {   inherits(x, \"vctrs_percent\") }"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"format-method","dir":"Articles","previous_headings":"Basics","what":"format() method","title":"S3 vectors","text":"first method every class almost always format() method. return character vector length x. easiest way rely one R’s low-level formatting functions like formatC(): (Note use vec_data() format() doesn’t get stuck infinite loop, take little care convert NA \"NA\"; leads better printing.) format method also used data frames, tibbles, str(): optimal display, recommend also defining abbreviated type name, 4-5 letters commonly used vectors. used tibbles str(): need control printing tibbles, implement method pillar::pillar_shaft(). See vignette(\"pillar\", package = \"vctrs\") details.","code":"format.vctrs_percent <- function(x, ...) {   out <- formatC(signif(vec_data(x) * 100, 3))   out[is.na(x)] <- NA   out[!is.na(x)] <- paste0(out[!is.na(x)], \"%\")   out } x #> <vctrs_percent[5]> #> [1] 0%    33.3% 66.7% 100%  <NA> data.frame(x) #>       x #> 1    0% #> 2 33.3% #> 3 66.7% #> 4  100% #> 5  <NA> vec_ptype_abbr.vctrs_percent <- function(x, ...) {   \"prcnt\" }  tibble::tibble(x) #> # A tibble: 5 × 1 #>         x #>   <prcnt> #> 1      0% #> 2   33.3% #> 3   66.7% #> 4    100% #> 5      NA  str(x) #>  prcnt [1:5] 0%, 33.3%, 66.7%, 100%, <NA>"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"casting-and-coercion","dir":"Articles","previous_headings":"","what":"Casting and coercion","title":"S3 vectors","text":"next set methods likely need related coercion casting. Coercion casting two sides coin: changing prototype existing object. change happens implicitly (e.g c()) call coercion; change happens explicitly (e.g. .integer(x)), call casting. One main goals vctrs put coercion casting robust theoretical footing ’s possible make accurate predictions (e.g.) c(x, y) x y different prototypes. vctrs achieves goal two generics: vec_ptype2(x, y) defines possible set coercions. returns prototype x y can safely coerced prototype; otherwise returns error. set automatic coercions usually quite small many tend make code harder reason silently propagate mistakes. vec_cast(x, ) defines possible sets casts. returns x translated prototype , throws error conversion isn’t possible. set possible casts superset possible coercions ’re requested explicitly.","code":""},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"double-dispatch","dir":"Articles","previous_headings":"Casting and coercion","what":"Double dispatch","title":"S3 vectors","text":"generics use double dispatch means implementation selected based class two arguments, just one. S3 natively support double dispatch, implement dispatch mechanism. practice, means: end method names two classes, like vec_ptype2.foo.bar(). don’t need implement default methods (never called ). can’t call NextMethod().","code":""},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"percent","dir":"Articles","previous_headings":"Casting and coercion","what":"Percent class","title":"S3 vectors","text":"’ll make percent class coercible back forth double vectors. vec_ptype2() provides user friendly error message coercion doesn’t exist makes sure NA handled standard way. NA technically logical vector, want stand missing value type. default simple cases, object class compatible : However works attributes objects . Also default methods bit slower. always good idea provide explicit coercion method case identical classes. ’ll start saying vctrs_percent combined vctrs_percent yields vctrs_percent, indicate returning prototype generated constructor. Next define methods say combining percent double yield double. avoid returning percent errors scale (1 vs. 0.01) obvious raw numbers. double dispatch bit hack, need provide two methods. ’s responsibility ensure member pair returns result: don’t get weird unpredictable behaviour. double dispatch mechanism requires us refer underlying type, double, method name. implemented vec_ptype2.vctrs_percent.numeric(), never called. can check ’ve implemented correctly vec_ptype_show(): vec_ptype2() methods define input richer type vctrs coerce . However, don’t perform conversion. job vec_cast(), implement next. ’ll provide method cast percent percent: converting back forth doubles. convert double percent use percent() helper (constructor; unvalidated user input). convert percent double, strip attributes. Note historical reasons order argument signature opposite vec_ptype2(). class comes first, class x comes second. , double dispatch mechanism requires us refer underlying type, double, method name. Implementing vec_cast.vctrs_percent.numeric() effect. can check works vec_cast(): ’ve implemented vec_ptype2() vec_cast(), get vec_c(), [<-, [[<- implementations free. ’ll also get mostly correct behaviour c(). exception use c() base R class: Unfortunately ’s way fix problem current design c(). , convenience, consider providing as_percent() function makes use casts defined vec_cast.vctrs_percent() methods: Occasionally, useful provide conversions go beyond ’s allowed casting. example, offer parsing method character vectors. case, as_percent() generic, default method cast, additional methods implement flexible conversion:","code":"vec_ptype2(\"bogus\", percent()) #> Error: #> ! Can't combine `\"bogus\"` <character> and `percent()` <vctrs_percent>. vec_ptype2(percent(), NA) #> <vctrs_percent[0]> vec_ptype2(NA, percent()) #> <vctrs_percent[0]> vec_ptype2(percent(), percent()) #> <vctrs_percent[0]> vec_ptype2.vctrs_percent.vctrs_percent <- function(x, y, ...) new_percent() vec_ptype2.vctrs_percent.double <- function(x, y, ...) double() vec_ptype2.double.vctrs_percent <- function(x, y, ...) double() vec_ptype_show(percent(), double(), percent()) #> Prototype: <double> #> 0. (                 , <vctrs_percent> ) = <vctrs_percent> #> 1. ( <vctrs_percent> , <double>        ) = <double>        #> 2. ( <double>        , <vctrs_percent> ) = <double> vec_cast.vctrs_percent.vctrs_percent <- function(x, to, ...) x vec_cast.vctrs_percent.double <- function(x, to, ...) percent(x) vec_cast.double.vctrs_percent <- function(x, to, ...) vec_data(x) vec_cast(0.5, percent()) #> <vctrs_percent[1]> #> [1] 50% vec_cast(percent(0.5), double()) #> [1] 0.5 vec_c(percent(0.5), 1) #> [1] 0.5 1.0 vec_c(NA, percent(0.5)) #> <vctrs_percent[2]> #> [1] <NA> 50% # but vec_c(TRUE, percent(0.5)) #> Error in `vec_c()`: #> ! Can't combine `..1` <logical> and `..2` <vctrs_percent>.  x <- percent(c(0.5, 1, 2)) x[1:2] <- 2:1 #> Error in `vec_restore_dispatch()`: #> ! Can't convert <integer> to <vctrs_percent>. x[[3]] <- 0.5 x #> <vctrs_percent[3]> #> [1] 50%  100% 50% # Correct c(percent(0.5), 1) #> [1] 0.5 1.0 c(percent(0.5), factor(1)) #> Error in `vec_c()`: #> ! Can't combine `..1` <vctrs_percent> and `..2` <factor<25c7e>>.  # Incorrect c(factor(1), percent(0.5)) #> [1] 1.0 0.5 as_percent <- function(x) {   vec_cast(x, new_percent()) } as_percent <- function(x, ...) {   UseMethod(\"as_percent\") }  as_percent.default <- function(x, ...) {   vec_cast(x, new_percent()) }  as_percent.character <- function(x) {   value <- as.numeric(gsub(\" *% *$\", \"\", x)) / 100   new_percent(value) }"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"decimal-class","dir":"Articles","previous_headings":"Casting and coercion","what":"Decimal class","title":"S3 vectors","text":"Now ’ve seen basics simple S3 class, ’ll gradually explore complicated scenarios. section creates decimal class prints specified number decimal places. similar percent now class needs attribute: number decimal places display (integer vector length 1). start , defining low-level constructor, user-friendly constructor, format() method, vec_ptype_abbr(). Note additional object attributes simply passed along new_vctr(): Note provide little helper extract digits attribute. makes code little easier read exported. default, vctrs assumes attributes independent data automatically preserved. ’ll see attributes data dependent next section. sake exposition, ’ll assume digits important attribute class included full type: Now consider vec_cast() vec_ptype2(). Casting coercing one decimal another requires little thought values digits attribute might different, need way reconcile . ’ve decided chose maximum two; reasonable options take value left-hand side throw error. Finally, can implement coercion types, like doubles. automatically coercing, choose richer type (.e., decimal). type x greater resolution y, inputs lose precision. generate errors using stop_lossy_cast(). can see action casting doubles integers; doubles can become integers without losing resolution.","code":"new_decimal <- function(x = double(), digits = 2L) {   if (!is_double(x)) {     abort(\"`x` must be a double vector.\")   }   if (!is_integer(digits)) {     abort(\"`digits` must be an integer vector.\")   }   vec_check_size(digits, size = 1L)    new_vctr(x, digits = digits, class = \"vctrs_decimal\") }  decimal <- function(x = double(), digits = 2L) {   x <- vec_cast(x, double())   digits <- vec_recycle(vec_cast(digits, integer()), 1L)    new_decimal(x, digits = digits) }  digits <- function(x) attr(x, \"digits\")  format.vctrs_decimal <- function(x, ...) {   sprintf(paste0(\"%-0.\", digits(x), \"f\"), x) }  vec_ptype_abbr.vctrs_decimal <- function(x, ...) {   \"dec\" }  x <- decimal(runif(10), 1L) x #> <vctrs_decimal[10]> #>  [1] 0.1 0.8 0.6 0.2 0.0 0.5 0.5 0.3 0.7 0.8 x[1:2] #> <vctrs_decimal[2]> #> [1] 0.1 0.8 x[[1]] #> <vctrs_decimal[1]> #> [1] 0.1 vec_ptype_full.vctrs_decimal <- function(x, ...) {   paste0(\"decimal<\", digits(x), \">\") }  x #> <decimal<1>[10]> #>  [1] 0.1 0.8 0.6 0.2 0.0 0.5 0.5 0.3 0.7 0.8 vec_ptype2.vctrs_decimal.vctrs_decimal <- function(x, y, ...) {   new_decimal(digits = max(digits(x), digits(y))) } vec_cast.vctrs_decimal.vctrs_decimal <- function(x, to, ...) {   new_decimal(vec_data(x), digits = digits(to)) }  vec_c(decimal(1/100, digits = 3), decimal(2/100, digits = 2)) #> <decimal<3>[2]> #> [1] 0.010 0.020 vec_ptype2.vctrs_decimal.double <- function(x, y, ...) x vec_ptype2.double.vctrs_decimal <- function(x, y, ...) y  vec_cast.vctrs_decimal.double  <- function(x, to, ...) new_decimal(x, digits = digits(to)) vec_cast.double.vctrs_decimal  <- function(x, to, ...) vec_data(x)  vec_c(decimal(1, digits = 1), pi) #> <decimal<1>[2]> #> [1] 1.0 3.1 vec_c(pi, decimal(1, digits = 1)) #> <decimal<1>[2]> #> [1] 3.1 1.0 vec_cast(c(1, 2, 10), to = integer()) #> [1]  1  2 10  vec_cast(c(1.5, 2, 10.5), to = integer()) #> Error: #> ! Can't convert from `c(1.5, 2, 10.5)` <double> to <integer> due to loss of precision. #> • Locations: 1, 3"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"cached-sum","dir":"Articles","previous_headings":"Casting and coercion","what":"Cached sum class","title":"S3 vectors","text":"next level complexity object data-dependent attributes. explore idea ’ll create vector caches sum values. usual, start low-level user-friendly constructors: class, can use default format() method, instead, ’ll customise obj_print_footer() method. good place display user facing attributes. ’ll also override sum() mean() use attribute. easiest vec_math(), ’ll learn later. mentioned , vctrs assumes attributes independent data. means take advantage default methods, ’ll work, return incorrect result: fix , need provide vec_restore() method. Note method dispatches argument. works vctrs methods dispatch underlying base function first stripping extra attributes vec_data() reapplying vec_restore(). default vec_restore() method copies attributes, appropriate attributes depend data. Note vec_restore.class subtly different vec_cast.class.class(). vec_restore() used restoring attributes lost; vec_cast() used coercions. easier understand concrete example. Imagine factors implemented new_vctr(). vec_restore.factor() restore attributes back integer vector, want allow manually casting integer factor vec_cast().","code":"new_cached_sum <- function(x = double(), sum = 0L) {   if (!is_double(x)) {     abort(\"`x` must be a double vector.\")   }   if (!is_double(sum)) {     abort(\"`sum` must be a double vector.\")   }   vec_check_size(sum, size = 1L)    new_vctr(x, sum = sum, class = \"vctrs_cached_sum\") }  cached_sum <- function(x) {   x <- vec_cast(x, double())   new_cached_sum(x, sum(x)) } obj_print_footer.vctrs_cached_sum <- function(x, ...) {   cat(\"# Sum: \", format(attr(x, \"sum\"), digits = 3), \"\\n\", sep = \"\") }  x <- cached_sum(runif(10)) x #> <vctrs_cached_sum[10]> #>  [1] 0.87460066 0.17494063 0.03424133 0.32038573 0.40232824 0.19566983 #>  [7] 0.40353812 0.06366146 0.38870131 0.97554784 #> # Sum: 3.83 vec_math.vctrs_cached_sum <- function(.fn, .x, ...) {   cat(\"Using cache\\n\")   switch(.fn,     sum = attr(.x, \"sum\"),     mean = attr(.x, \"sum\") / length(.x),     vec_math_base(.fn, .x, ...)   ) }  sum(x) #> Using cache #> [1] 3.833615 x[1:2] #> <vctrs_cached_sum[2]> #> [1] 0.8746007 0.1749406 #> # Sum: 3.83 vec_restore.vctrs_cached_sum <- function(x, to, ..., i = NULL) {   new_cached_sum(x, sum(x)) }  x[1] #> <vctrs_cached_sum[1]> #> [1] 0.8746007 #> # Sum: 0.875"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"record-style-objects","dir":"Articles","previous_headings":"","what":"Record-style objects","title":"S3 vectors","text":"Record-style objects use list equal-length vectors represent individual components object. best example POSIXlt, underneath hood list 11 fields like year, month, day. Record-style classes override length() subsetting methods conceal implementation detail. vctrs makes easy create new record-style classes using new_rcrd(), wide selection default methods.","code":"x <- as.POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3)) x #> [1] \"2020-01-01 00:00:01 UTC\" \"2020-01-01 00:00:02 UTC\" #> [3] \"2020-01-01 00:00:03 UTC\"  length(x) #> [1] 3 length(unclass(x)) #> [1] 11  x[[1]] # the first date time #> [1] \"2020-01-01 00:00:01 UTC\" unclass(x)[[1]] # the first component, the number of seconds #> [1] 1 2 3"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"rational-class","dir":"Articles","previous_headings":"Record-style objects","what":"Rational class","title":"S3 vectors","text":"fraction, rational number, can represented pair integer vectors representing numerator (number top) denominator (number bottom), length vector must . represent data structure turn new base data type: record (rcrd short). usual start low-level user-friendly constructors. low-level constructor calls new_rcrd(), needs named list equal-length vectors. user friendly constructor casts n d integers recycles length. Behind scenes, x named list two elements. details hidden behaves like vector: access underlying fields need use field() fields(): Notice can’t print() str() new rational vector x yet. Printing causes error: haven’t defined class can printed underlying data. Note want look hood development, can always call vec_data(x). generally best define formatting method early development class. format method defines display class can printed normal way: vctrs uses format() method str(), hiding underlying implementation details user: rational, vec_ptype2() vec_cast() follow pattern percent(). allow coercion integer doubles.","code":"new_rational <- function(n = integer(), d = integer()) {   if (!is_integer(n)) {     abort(\"`n` must be an integer vector.\")   }   if (!is_integer(d)) {     abort(\"`d` must be an integer vector.\")   }    new_rcrd(list(n = n, d = d), class = \"vctrs_rational\") } rational <- function(n = integer(), d = integer()) {   c(n, d) %<-% vec_cast_common(n, d, .to = integer())   c(n, d) %<-% vec_recycle_common(n, d)    new_rational(n, d) }  x <- rational(1, 1:10) names(x) #> NULL length(x) #> [1] 10 fields(x) #> [1] \"n\" \"d\" field(x, \"n\") #>  [1] 1 1 1 1 1 1 1 1 1 1 x #> <vctrs_rational[10]> #> Error in `format()`: #> ! `format.vctrs_rational()` not implemented.  str(x) #> Error in `format()`: #> ! `format.vctrs_rational()` not implemented. vec_data(x) #>    n  d #> 1  1  1 #> 2  1  2 #> 3  1  3 #> 4  1  4 #> 5  1  5 #> 6  1  6 #> 7  1  7 #> 8  1  8 #> 9  1  9 #> 10 1 10  str(vec_data(x)) #> 'data.frame':    10 obs. of  2 variables: #>  $ n: int  1 1 1 1 1 1 1 1 1 1 #>  $ d: int  1 2 3 4 5 6 7 8 9 10 format.vctrs_rational <- function(x, ...) {   n <- field(x, \"n\")   d <- field(x, \"d\")    out <- paste0(n, \"/\", d)   out[is.na(n) | is.na(d)] <- NA    out }  vec_ptype_abbr.vctrs_rational <- function(x, ...) \"rtnl\" vec_ptype_full.vctrs_rational <- function(x, ...) \"rational\"  x #> <rational[10]> #>  [1] 1/1  1/2  1/3  1/4  1/5  1/6  1/7  1/8  1/9  1/10 str(x) #>  rtnl [1:10] 1/1, 1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9, 1/10 vec_ptype2.vctrs_rational.vctrs_rational <- function(x, y, ...) new_rational() vec_ptype2.vctrs_rational.integer <- function(x, y, ...) new_rational() vec_ptype2.integer.vctrs_rational <- function(x, y, ...) new_rational()  vec_cast.vctrs_rational.vctrs_rational <- function(x, to, ...) x vec_cast.double.vctrs_rational <- function(x, to, ...) field(x, \"n\") / field(x, \"d\") vec_cast.vctrs_rational.integer <- function(x, to, ...) rational(x, 1)  vec_c(rational(1, 2), 1L, NA) #> <rational[3]> #> [1] 1/2  1/1  <NA>"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"decimal2-class","dir":"Articles","previous_headings":"Record-style objects","what":"Decimal2 class","title":"S3 vectors","text":"previous implementation decimal built top doubles. bad idea decimal vectors typically used care precise values (.e., dollars cents bank account), double values suffer floating point problems. better implementation decimal class use pair integers, one value left decimal point, value right (divided scale). following code quick sketch might start creating class:","code":"new_decimal2 <- function(l, r, scale = 2L) {   if (!is_integer(l)) {     abort(\"`l` must be an integer vector.\")   }   if (!is_integer(r)) {     abort(\"`r` must be an integer vector.\")   }   if (!is_integer(scale)) {     abort(\"`scale` must be an integer vector.\")   }   vec_check_size(scale, size = 1L)    new_rcrd(list(l = l, r = r), scale = scale, class = \"vctrs_decimal2\") }  decimal2 <- function(l, r, scale = 2L) {   l <- vec_cast(l, integer())   r <- vec_cast(r, integer())   c(l, r) %<-% vec_recycle_common(l, r)   scale <- vec_cast(scale, integer())    # should check that r < 10^scale   new_decimal2(l = l, r = r, scale = scale) }  format.vctrs_decimal2 <- function(x, ...) {   val <- field(x, \"l\") + field(x, \"r\") / 10^attr(x, \"scale\")   sprintf(paste0(\"%.0\", attr(x, \"scale\"), \"f\"), val) }  decimal2(10, c(0, 5, 99)) #> <vctrs_decimal2[3]> #> [1] 10.00 10.05 10.99"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"equality-and-comparison","dir":"Articles","previous_headings":"","what":"Equality and comparison","title":"S3 vectors","text":"vctrs provides four “proxy” generics. Two let control class determines equality comparison: vec_proxy_equal() returns data vector suitable comparison. underpins ==, !=, unique(), anyDuplicated(), .na(). vec_proxy_compare() specifies compare elements vector. proxy used <, <=, >=, >, min(), max(), median(), quantile(). Two proxy generic used sorting unordered data types accessing raw data exotic storage formats: vec_proxy_order() specifies sort elements vector. used xtfrm(), turn called order() sort() functions. proxy added implement behaviour lists, sortable (order proxy sorts first occurrence) comparable (comparison operators cause error). default implementation classes calls vec_proxy_compare() normally don’t need implement proxy. vec_proxy() returns actual data vector. useful store data field class. time, shouldn’t need implement vec_proxy(). default behavior follows: vec_proxy_equal() calls vec_proxy() vec_proxy_compare() calls vec_proxy_equal() vec_proxy_order() calls vec_proxy_compare() implement proxies preprocessing data needed make elements comparable. case, defining methods get lot behaviour relatively little work. proxy functions always return simple object (either bare vector data frame) possesses properties class. permits efficient implementation vctrs internals allows dispatch happen R, efficient computations can written C.","code":""},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"rational-class-1","dir":"Articles","previous_headings":"Equality and comparison","what":"Rational class","title":"S3 vectors","text":"Let’s explore ideas rational class started . default, vec_proxy() converts record data frame, default comparison works column column: makes sense default isn’t correct rational(1, 1) represents number rational(2, 2), equal. can fix implementing vec_proxy_equal() method divides n d greatest common divisor: vec_proxy_equal() also used unique(): now need fix comparison operations similarly, since comparison currently happens lexicographically n, d: easiest fix convert fraction floating point number use proxy: also fixes sort(), default implementation vec_proxy_order() calls vec_proxy_compare(). (used approach vec_proxy_equal(), working floating point numbers ’s necessarily true x == y implies d * x == d * y.)","code":"x <- rational(c(1, 2, 1, 2), c(1, 1, 2, 2)) x #> <rational[4]> #> [1] 1/1 2/1 1/2 2/2  vec_proxy(x) #>   n d #> 1 1 1 #> 2 2 1 #> 3 1 2 #> 4 2 2  x == rational(1, 1) #> [1]  TRUE FALSE FALSE FALSE # Thanks to Matthew Lundberg: https://stackoverflow.com/a/21504113/16632 gcd <- function(x, y) {   r <- x %% y   ifelse(r, gcd(y, r), y) }  vec_proxy_equal.vctrs_rational <- function(x, ...) {   n <- field(x, \"n\")   d <- field(x, \"d\")   gcd <- gcd(n, d)    data.frame(n = n / gcd, d = d / gcd) } vec_proxy_equal(x) #>   n d #> 1 1 1 #> 2 2 1 #> 3 1 2 #> 4 1 1  x == rational(1, 1) #> [1]  TRUE FALSE FALSE  TRUE unique(x) #> <rational[3]> #> [1] 1/1 2/1 1/2 rational(1, 2) < rational(2, 3) #> [1] TRUE rational(2, 4) < rational(2, 3) #> [1] TRUE vec_proxy_compare.vctrs_rational <- function(x, ...) {   field(x, \"n\") / field(x, \"d\") }  rational(2, 4) < rational(2, 3) #> [1] TRUE sort(x) #> <rational[4]> #> [1] 1/2 1/1 2/2 2/1"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"polynomial-class","dir":"Articles","previous_headings":"Equality and comparison","what":"Polynomial class","title":"S3 vectors","text":"related problem occurs build vector top list. following code defines polynomial class represents polynomials (like 1 + 3x - 2x^2) using list integer vectors (like c(1, 3, -2)). Note use new_list_of() constructor. resulting objects inherit vctrs_list_of class, provides tailored methods $, [[, corresponding assignment operators, methods. class implements list interface: fine internal implementation class appropriate behaved like atomic vector rather list.","code":"poly <- function(...) {   x <- vec_cast_common(..., .to = integer())   new_poly(x) } new_poly <- function(x) {   new_list_of(x, ptype = integer(), class = \"vctrs_poly_list\") }  vec_ptype_full.vctrs_poly_list <- function(x, ...) \"polynomial\" vec_ptype_abbr.vctrs_poly_list <- function(x, ...) \"poly\"  format.vctrs_poly_list <- function(x, ...) {   format_one <- function(x) {     if (length(x) == 0) {       return(\"\")     }      if (length(x) == 1) {       format(x)     } else {       suffix <- c(paste0(\"\\u22C5x^\", seq(length(x) - 1, 1)), \"\")       out <- paste0(x, suffix)       out <- out[x != 0L]       paste0(out, collapse = \" + \")     }   }    vapply(x, format_one, character(1)) }  obj_print_data.vctrs_poly_list <- function(x, ...) {   if (length(x) != 0) {     print(format(x), quote = FALSE)   } }  p <- poly(1, c(1, 0, 0, 0, 2), c(1, 0, 1)) p #> <polynomial[3]> #> [1] 1         1⋅x^4 + 2 1⋅x^2 + 1 class(p) #> [1] \"vctrs_poly_list\" \"vctrs_list_of\"   \"vctrs_vctr\"      #> [4] \"list\" p[2] #> <polynomial[1]> #> [1] 1⋅x^4 + 2 p[[2]] #> [1] 1 0 0 0 2 obj_is_list(p) #> [1] TRUE"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"make-an-atomic-polynomial-vector","dir":"Articles","previous_headings":"Equality and comparison > Polynomial class","what":"Make an atomic polynomial vector","title":"S3 vectors","text":"atomic vector vector like integer character [[ returns type. Unlike lists, can’t reach inside atomic vector. make polynomial class atomic vector, ’ll wrap internal list_of() class within record vector. Usually records used can store several fields data observation. one, use class anyway inherit atomicity. new format() method delegates one wrote internal list. vector looks just like : Making class atomic means obj_is_list() now returns FALSE. prevents recursive algorithms traverse lists reaching far inside polynomial internals. importantly, prevents users reaching internals [[:","code":"poly <- function(...) {   x <- vec_cast_common(..., .to = integer())   x <- new_poly(x)   new_rcrd(list(data = x), class = \"vctrs_poly\") } format.vctrs_poly <- function(x, ...) {   format(field(x, \"data\")) } p <- poly(1, c(1, 0, 0, 0, 2), c(1, 0, 1)) p #> <vctrs_poly[3]> #> [1] 1         1⋅x^4 + 2 1⋅x^2 + 1 obj_is_list(p) #> [1] FALSE p[[2]] #> <vctrs_poly[1]> #> [1] 1⋅x^4 + 2"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"implementing-equality-and-comparison","dir":"Articles","previous_headings":"Equality and comparison > Polynomial class","what":"Implementing equality and comparison","title":"S3 vectors","text":"Equality works box can tell two integer vectors equal: can’t compare individual elements, data stored list default lists comparable: enable comparison, implement vec_proxy_compare() method: Often, sufficient also implement sort(). However, lists, already default vec_proxy_order() method sorts first occurrence: ensure consistency ordering comparison, forward vec_proxy_order() vec_proxy_compare():","code":"p == poly(c(1, 0, 1)) #> [1] FALSE FALSE  TRUE p < p[2] #> Error in `vec_proxy_compare()`: #> ! `vec_proxy_compare.vctrs_poly_list()` not supported. vec_proxy_compare.vctrs_poly <- function(x, ...) {   # Get the list inside the record vector   x_raw <- vec_data(field(x, \"data\"))    # First figure out the maximum length   n <- max(vapply(x_raw, length, integer(1)))    # Then expand all vectors to this length by filling in with zeros   full <- lapply(x_raw, function(x) c(rep(0L, n - length(x)), x))    # Then turn into a data frame   as.data.frame(do.call(rbind, full)) }  p < p[2] #> [1]  TRUE FALSE  TRUE sort(p) #> <vctrs_poly[3]> #> [1] 1         1⋅x^2 + 1 1⋅x^4 + 2 sort(p[c(1:3, 1:2)]) #> <vctrs_poly[5]> #> [1] 1         1         1⋅x^2 + 1 1⋅x^4 + 2 1⋅x^4 + 2 vec_proxy_order.vctrs_poly <- function(x, ...) {   vec_proxy_compare(x, ...) }  sort(p) #> <vctrs_poly[3]> #> [1] 1         1⋅x^2 + 1 1⋅x^4 + 2"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"arithmetic","dir":"Articles","previous_headings":"","what":"Arithmetic","title":"S3 vectors","text":"vctrs also provides two mathematical generics allow define broad swath mathematical behaviour : vec_math(fn, x, ...) specifies behaviour mathematical functions like abs(), sum(), mean(). (Note var() sd() can’t overridden, see ?vec_math() complete list supported vec_math().) vec_arith(op, x, y) specifies behaviour arithmetic operations like +, -, %%. (See ?vec_arith() complete list.) generics define behaviour multiple functions sum.vctrs_vctr(x) calls vec_math.vctrs_vctr(\"sum\", x), x + y calls vec_math.x_class.y_class(\"+\", x, y). ’re accompanied vec_math_base() vec_arith_base() make easy call underlying base R functions. vec_arith() uses double dispatch needs following standard boilerplate: Correctly exporting vec_arith() methods package currently little awkward. See instructions Arithmetic section “Implementing vctrs S3 class package” section .","code":"vec_arith.MYCLASS <- function(op, x, y, ...) {   UseMethod(\"vec_arith.MYCLASS\", y) } vec_arith.MYCLASS.default <- function(op, x, y, ...) {   stop_incompatible_op(op, x, y) }"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"cached-sum-class","dir":"Articles","previous_headings":"Arithmetic","what":"Cached sum class","title":"S3 vectors","text":"showed example vec_math() define sum() mean() methods cached_sum. Now let’s talk exactly works. vec_math() functions similar form. use switch statement handle methods care fall back vec_math_base() don’t care .","code":"vec_math.vctrs_cached_sum <- function(.fn, .x, ...) {   switch(.fn,     sum = attr(.x, \"sum\"),     mean = attr(.x, \"sum\") / length(.x),     vec_math_base(.fn, .x, ...)   ) }"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"meter-class","dir":"Articles","previous_headings":"Arithmetic","what":"Meter class","title":"S3 vectors","text":"explore infix arithmetic operators exposed vec_arith() ’ll create new class represents measurement meters: meter built top double vector, basic mathematic operations work: can’t arithmetic: allow infix functions work, ’ll need provide vec_arith() generic. , let’s think combinations inputs support: makes sense add subtract meters: yields another meter. can divide meter another meter (yielding unitless number), can’t multiply meters (yield area). combination meter number multiplication division number acceptable. Addition subtraction don’t make much sense , strictly speaking, dealing objects different nature. vec_arith() another function uses double dispatch, usual start template. write method two meter objects. use switch statement cover cases care stop_incompatible_op() throw informative error message everything else. Next write pair methods arithmetic meter number. almost identical, meter(10) / 2 makes sense, 2 / meter(10) (neither addition subtraction). support doubles integers operands, dispatch numeric instead double. completeness, also need vec_arith.vctrs_meter.MISSING unary + - operators:","code":"new_meter <- function(x) {   stopifnot(is.double(x))   new_vctr(x, class = \"vctrs_meter\") }  format.vctrs_meter <- function(x, ...) {   paste0(format(vec_data(x)), \" m\") }  meter <- function(x) {   x <- vec_cast(x, double())   new_meter(x) }  x <- meter(1:10) x #> <vctrs_meter[10]> #>  [1]  1 m  2 m  3 m  4 m  5 m  6 m  7 m  8 m  9 m 10 m sum(x) #> <vctrs_meter[1]> #> [1] 55 m mean(x) #> <vctrs_meter[1]> #> [1] 5.5 m x + 1 #> Error in `vec_arith()`: #> ! <vctrs_meter> + <double> is not permitted meter(10) + meter(1) #> Error in `vec_arith()`: #> ! <vctrs_meter> + <vctrs_meter> is not permitted meter(10) * 3 #> Error in `vec_arith()`: #> ! <vctrs_meter> * <double> is not permitted vec_arith.vctrs_meter <- function(op, x, y, ...) {   UseMethod(\"vec_arith.vctrs_meter\", y) } vec_arith.vctrs_meter.default <- function(op, x, y, ...) {   stop_incompatible_op(op, x, y) } vec_arith.vctrs_meter.vctrs_meter <- function(op, x, y, ...) {   switch(     op,     \"+\" = ,     \"-\" = new_meter(vec_arith_base(op, x, y)),     \"/\" = vec_arith_base(op, x, y),     stop_incompatible_op(op, x, y)   ) }  meter(10) + meter(1) #> <vctrs_meter[1]> #> [1] 11 m meter(10) - meter(1) #> <vctrs_meter[1]> #> [1] 9 m meter(10) / meter(1) #> [1] 10 meter(10) * meter(1) #> Error in `vec_arith()`: #> ! <vctrs_meter> * <vctrs_meter> is not permitted vec_arith.vctrs_meter.numeric <- function(op, x, y, ...) {   switch(     op,     \"/\" = ,     \"*\" = new_meter(vec_arith_base(op, x, y)),     stop_incompatible_op(op, x, y)   ) } vec_arith.numeric.vctrs_meter <- function(op, x, y, ...) {   switch(     op,     \"*\" = new_meter(vec_arith_base(op, x, y)),     stop_incompatible_op(op, x, y)   ) }  meter(2) * 10 #> <vctrs_meter[1]> #> [1] 20 m meter(2) * as.integer(10) #> <vctrs_meter[1]> #> [1] 20 m 10 * meter(2) #> <vctrs_meter[1]> #> [1] 20 m meter(20) / 10 #> <vctrs_meter[1]> #> [1] 2 m 10 / meter(20) #> Error in `vec_arith()`: #> ! <double> / <vctrs_meter> is not permitted meter(20) + 10 #> Error in `vec_arith()`: #> ! <vctrs_meter> + <double> is not permitted vec_arith.vctrs_meter.MISSING <- function(op, x, y, ...) {   switch(op,     `-` = x * -1,     `+` = x,     stop_incompatible_op(op, x, y)   ) } -meter(1) #> <vctrs_meter[1]> #> [1] -1 m +meter(1) #> <vctrs_meter[1]> #> [1] 1 m"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"implementing-a-vctrs-s3-class-in-a-package","dir":"Articles","previous_headings":"","what":"Implementing a vctrs S3 class in a package","title":"S3 vectors","text":"Defining S3 methods interactively fine iteration exploration, class lives package, need things: Register S3 methods listing NAMESPACE file. Create documentation around methods, sake user satisfy R CMD check. Let’s assume percent class implemented pizza package file R/percent.R. walk major sections hypothetical file. ’ve seen code , now ’s augmented roxygen2 directives produce correct NAMESPACE entries help topics.","code":""},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"getting-started","dir":"Articles","previous_headings":"Implementing a vctrs S3 class in a package","what":"Getting started","title":"S3 vectors","text":"First, pizza package needs include vctrs Imports section DESCRIPTION (perhaps calling usethis::use_package(\"vctrs\"). vctrs active development, probably makes sense state minimum version. make vctrs functions available within pizza package including directive #' @import vctrs somewhere. Usually, ’s good practice @import entire namespace package, vctrs deliberately designed use case mind. put #' @import vctrs? two natural locations: package-level docs R/pizza-doc.R. can use usethis::use_package_doc() initiate package-level documentation. R/percent.R. makes sense vctrs S3 class modest self-contained part overall package. also must use one locations dump internal documentation ’s needed avoid R CMD check complaints. don’t expect human ever read documentation. ’s dummy documentation look, combined #' @import vctrs directive described . appear R/pizza-doc.R (package-level docs) R/percent.R (class-focused file). Remember call devtools::document() regularly, develop, regenerate NAMESPACE .Rd files. point , code shown expected appear R/percent.R.","code":"Imports:     a_package,     another_package,     ...     vctrs (>= x.y.z),     ... #' Internal vctrs methods #' #' @import vctrs #' @keywords internal #' @name pizza-vctrs NULL"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"low-level-and-user-friendly-constructors","dir":"Articles","previous_headings":"Implementing a vctrs S3 class in a package","what":"Low-level and user-friendly constructors","title":"S3 vectors","text":"Next add constructor: Note name package must included class name (pizza_percent), need included constructor name. need export constructor, unless want people extend class. can also add call setOldClass() compatibility S4: ’ve used function methods package, ’ll also need add methods Imports, (e.g.) usethis::use_package(\"methods\"). “free” dependency methods bundled every R install. Next implement, export, document user-friendly helper: percent(). (note package name appear class, need occur function, can already pizza::percent(); redundant pizza::pizza_percent().)","code":"new_percent <- function(x = double()) {   if (!is_double(x)) {     abort(\"`x` must be a double vector.\")   }   new_vctr(x, class = \"pizza_percent\") } # for compatibility with the S4 system methods::setOldClass(c(\"pizza_percent\", \"vctrs_vctr\")) #' `percent` vector #' #' This creates a double vector that represents percentages so when it is #' printed, it is multiplied by 100 and suffixed with `%`. #' #' @param x A numeric vector #' @return An S3 vector of class `pizza_percent`. #' @export #' @examples #' percent(c(0.25, 0.5, 0.75)) percent <- function(x = double()) {   x <- vec_cast(x, double())   new_percent(x) }"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"other-helpers","dir":"Articles","previous_headings":"Implementing a vctrs S3 class in a package","what":"Other helpers","title":"S3 vectors","text":"’s good idea provide function tests object class. , makes sense document user-friendly constructor percent(): ’ll also need update percent() documentation reflect x now means two different things: Next provide key methods make printing work. S3 methods, don’t need documented, need exported. Finally, implement methods vec_ptype2() vec_cast().","code":"#' @export #' @rdname percent is_percent <- function(x) {   inherits(x, \"pizza_percent\") } #' @param x #'  * For `percent()`: A numeric vector #'  * For `is_percent()`: An object to test. #' @export format.pizza_percent <- function(x, ...) {   out <- formatC(signif(vec_data(x) * 100, 3))   out[is.na(x)] <- NA   out[!is.na(x)] <- paste0(out[!is.na(x)], \"%\")   out }  #' @export vec_ptype_abbr.pizza_percent <- function(x, ...) {   \"prcnt\" } #' @export vec_ptype2.vctrs_percent.vctrs_percent <- function(x, y, ...) new_percent() #' @export vec_ptype2.double.vctrs_percent <- function(x, y, ...) double()  #' @export vec_cast.pizza_percent.pizza_percent <- function(x, to, ...) x #' @export vec_cast.pizza_percent.double <- function(x, to, ...) percent(x) #' @export vec_cast.double.pizza_percent <- function(x, to, ...) vec_data(x)"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"arithmetic-1","dir":"Articles","previous_headings":"Implementing a vctrs S3 class in a package","what":"Arithmetic","title":"S3 vectors","text":"Writing double dispatch methods vec_arith() currently awkward writing vec_ptype2() vec_cast(). plan improve future. now, can use following instructions. define new type want write vec_arith() methods , ’ll need provide new single dispatch S3 generic following form: Note actually functions S3 method vec_arith() S3 generic called vec_arith.my_type() dispatches y. roxygen2 recognizes S3 generic, register S3 method part explicit @method call. , can define double dispatch methods, still need explicit @method tag ensure registered correct generic: vctrs provides hybrid S3 generics/methods base R types, like vec_arith.integer(). don’t fully import vctrs @import vctrs, need explicitly import generic registering double dispatch methods @importFrom vctrs vec_arith.integer.","code":"#' @export #' @method vec_arith my_type vec_arith.my_type <- function(op, x, y, ...) {   UseMethod(\"vec_arith.my_type\", y) } #' @export #' @method vec_arith.my_type my_type vec_arith.my_type.my_type <- function(op, x, y, ...) {   # implementation here }  #' @export #' @method vec_arith.my_type integer vec_arith.my_type.integer <- function(op, x, y, ...) {   # implementation here }  #' @export #' @method vec_arith.integer my_type vec_arith.integer.my_type <- function(op, x, y, ...) {   # implementation here }"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"testing","dir":"Articles","previous_headings":"Implementing a vctrs S3 class in a package","what":"Testing","title":"S3 vectors","text":"’s good practice test new class. Specific recommendations: R/percent.R type file really want 100% test coverage. can use devtools::test_coverage_file() check . Make sure test behaviour zero-length inputs missing values. Use testthat::verify_output() test format method. Customised printing often primary motivation creating S3 class first place, alert unexpected changes printed output. Read verify_output() testthat v2.3.0 blog post; ’s example -called golden test. Check method symmetry; use expect_s3_class(), probably exact = TRUE, ensure vec_c(x, y) vec_c(y, x) return type output important xs ys domain. Use testthat::expect_error() check inputs can’t combined fail error. , generally checking class error, message. Relevant classes include vctrs_error_assert_ptype, vctrs_error_assert_size, vctrs_error_incompatible_type. tests pass run devtools::test(), fail run R CMD check, likely reflect problem S3 method registration. Carefully check roxygen2 comments generated NAMESPACE.","code":"expect_error(vec_c(1, \"a\"), class = \"vctrs_error_incompatible_type\")"},{"path":"https://vctrs.r-lib.org/dev/articles/s3-vector.html","id":"existing-classes","dir":"Articles","previous_headings":"Implementing a vctrs S3 class in a package","what":"Existing classes","title":"S3 vectors","text":"build class, might want consider using, subclassing existing classes. can check awesome-vctrs curated list R vector classes, built vctrs. ’ve built extended class, consider adding list people can use .","code":""},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"definitions","dir":"Articles","previous_headings":"","what":"Definitions","title":"Type and size stability","text":"say function type-stable iff: can predict output type knowing input types. order arguments … affect output type. Similarly, function size-stable iff: can predict output size knowing input sizes, single numeric input specifies output size. base R functions size-stable, ’ll also define slightly weaker condition. ’ll call function length-stable iff: can predict output length knowing input lengths, single numeric input specifies output length. (note length-stable particularly robust definition length() returns value things vectors.) ’ll call functions don’t obey principles type-unstable size-unstable respectively. top type- size-stability ’s also desirable single set rules applied consistently. want one set type-coercion size-recycling rules apply everywhere, many sets rules apply different functions. goal principles minimise cognitive overhead. Rather memorise many special cases, able learn one set principles apply .","code":""},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"examples","dir":"Articles","previous_headings":"Definitions","what":"Examples","title":"Type and size stability","text":"make ideas concrete, let’s apply base functions: mean() trivially type-stable size-stable always returns double vector length 1 (throws error). Surprisingly, median() type-unstable: , however, size-stable, since always returns vector length 1. sapply() type-unstable can’t predict output type knowing input types: ’s quite size-stable; vec_size(sapply(x, f)) vec_size(x) vectors matrices (output transposed) data frames (iterates columns). vapply() type-stable version sapply() vec_ptype_show(vapply(x, fn, template)) always vec_ptype_show(template). size-unstable reasons sapply(). c() type-unstable c(x, y) doesn’t always output type c(y, x). c() almost always length-stable length(c(x, y)) almost always equals length(x) + length(y). One common source instability dealing non-vectors (see later section “Non-vectors”): paste(x1, x2) length-stable length(paste(x1, x2)) equals max(length(x1), length(x2)). However, doesn’t follow usual arithmetic recycling rules paste(1:2, 1:3) doesn’t generate warning. ifelse() length-stable length(ifelse(cond, true, false)) always length(cond). ifelse() type-unstable output type depends value cond: read.csv(file) type-unstable size-unstable , know return data frame, don’t know columns return many rows . Similarly, df[[]] type-stable result depends value . many important functions can made type-stable size-stable! understanding type- size-stability hand, ’ll use analyse base R functions greater depth propose alternatives better properties.","code":"vec_ptype_show(median(c(1L, 1L))) #> Prototype: double vec_ptype_show(median(c(1L, 1L, 1L))) #> Prototype: integer vec_ptype_show(sapply(1L, function(x) c(x, x))) #> Prototype: integer[,1] vec_ptype_show(sapply(integer(), function(x) c(x, x))) #> Prototype: list vec_ptype_show(c(NA, Sys.Date())) #> Prototype: double vec_ptype_show(c(Sys.Date(), NA)) #> Prototype: date env <- new.env(parent = emptyenv()) length(env) #> [1] 0 length(mean) #> [1] 1 length(c(env, mean)) #> [1] 2 vec_ptype_show(ifelse(NA, 1L, 1L)) #> Prototype: logical vec_ptype_show(ifelse(FALSE, 1L, 1L)) #> Prototype: integer"},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"c-and-vctrsvec_c","dir":"Articles","previous_headings":"","what":"c() and vctrs::vec_c()","title":"Type and size stability","text":"section ’ll compare contrast c() vec_c(). vec_c() type- size-stable possesses following invariants: vec_ptype(vec_c(x, y)) equals vec_ptype_common(x, y). vec_size(vec_c(x, y)) equals vec_size(x) + vec_size(y). c() another undesirable property ’s consistent unlist(); .e., unlist(list(x, y)) always equal c(x, y); .e., base R multiple sets type-coercion rules. won’t consider problem . two goals : fully document quirks c(), hence motivating development alternative. discuss non-obvious consequences type- size-stability .","code":""},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"atomic-vectors","dir":"Articles","previous_headings":"c() and vctrs::vec_c()","what":"Atomic vectors","title":"Type and size stability","text":"consider atomic vectors, c() type-stable uses hierarchy types: character > complex > double > integer > logical. vec_c() obeys similar rules: automatically coerce character vectors lists:","code":"c(FALSE, 1L, 2.5) #> [1] 0.0 1.0 2.5 vec_c(FALSE, 1L, 2.5) #> [1] 0.0 1.0 2.5 c(FALSE, \"x\") #> [1] \"FALSE\" \"x\" vec_c(FALSE, \"x\") #> Error in `vec_c()`: #> ! Can't combine `..1` <logical> and `..2` <character>.  c(FALSE, list(1)) #> [[1]] #> [1] FALSE #>  #> [[2]] #> [1] 1 vec_c(FALSE, list(1)) #> Error in `vec_c()`: #> ! Can't combine `..1` <logical> and `..2` <list>."},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"incompatible-vectors-and-non-vectors","dir":"Articles","previous_headings":"c() and vctrs::vec_c()","what":"Incompatible vectors and non-vectors","title":"Type and size stability","text":"general, base methods throw error: inputs aren’t vectors, c() automatically puts list: numeric versions, depends order inputs. Version first error, otherwise input wrapped list: vec_c() throws error inputs vectors automatically coercible:","code":"c(10.5, factor(\"x\")) #> [1] 10.5  1.0 c(mean, globalenv()) #> [[1]] #> function (x, ...)  #> UseMethod(\"mean\") #> <bytecode: 0x560840ef6658> #> <environment: namespace:base> #>  #> [[2]] #> <environment: R_GlobalEnv> c(getRversion(), \"x\") #> Error: invalid version specification 'x'  c(\"x\", getRversion()) #> [[1]] #> [1] \"x\" #>  #> [[2]] #> [1] 4 5 1 vec_c(mean, globalenv()) #> Error in `vec_c()`: #> ! `..1` must be a vector, not a function.  vec_c(Sys.Date(), factor(\"x\"), \"x\") #> Error in `vec_c()`: #> ! Can't combine `..1` <date> and `..2` <factor<bf275>>."},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"factors","dir":"Articles","previous_headings":"c() and vctrs::vec_c()","what":"Factors","title":"Type and size stability","text":"Combining two factors returns integer vector: (documented c() still undesirable.) vec_c() returns factor taking union levels. behaviour motivated pragmatics: many places base R automatically convert character vectors factors, enforcing stricter behaviour unnecessarily onerous. (backed experience dplyr::bind_rows(), stricter common source user difficulty.)","code":"fa <- factor(\"a\") fb <- factor(\"b\")  c(fa, fb) #> [1] a b #> Levels: a b vec_c(fa, fb) #> [1] a b #> Levels: a b vec_c(fb, fa) #> [1] b a #> Levels: b a"},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"date-times","dir":"Articles","previous_headings":"c() and vctrs::vec_c()","what":"Date-times","title":"Type and size stability","text":"c() strips time zone associated date-times: behaviour documented ?DateTimeClasses source considerable user pain. vec_c() preserves time zones: time zone output inputs different time zones? One option strict force user manually align time zones. However, onerous (particularly ’s easy way change time zone base R), vctrs chooses use first non-local time zone:","code":"datetime_nz <- as.POSIXct(\"2020-01-01 09:00\", tz = \"Pacific/Auckland\") c(datetime_nz) #> [1] \"2020-01-01 09:00:00 NZDT\" vec_c(datetime_nz) #> [1] \"2020-01-01 09:00:00 NZDT\" datetime_local <- as.POSIXct(\"2020-01-01 09:00\") datetime_houston <- as.POSIXct(\"2020-01-01 09:00\", tz = \"US/Central\")  vec_c(datetime_local, datetime_houston, datetime_nz) #> [1] \"2020-01-01 03:00:00 CST\" \"2020-01-01 09:00:00 CST\" #> [3] \"2019-12-31 14:00:00 CST\" vec_c(datetime_houston, datetime_nz) #> [1] \"2020-01-01 09:00:00 CST\" \"2019-12-31 14:00:00 CST\" vec_c(datetime_nz, datetime_houston) #> [1] \"2020-01-01 09:00:00 NZDT\" \"2020-01-02 04:00:00 NZDT\""},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"dates-and-date-times","dir":"Articles","previous_headings":"c() and vctrs::vec_c()","what":"Dates and date-times","title":"Type and size stability","text":"Combining dates date-times c() gives silently incorrect results: behaviour arises neither c.Date() c.POSIXct() check inputs type. vec_c() uses standard set rules avoid problem. mix dates date-times, vctrs returns date-time converts dates date-times midnight (timezone date-time).","code":"date <- as.Date(\"2020-01-01\") datetime <- as.POSIXct(\"2020-01-01 09:00\")  c(date, datetime) #> [1] \"2020-01-01\" \"2020-01-01\" c(datetime, date) #> [1] \"2020-01-01 09:00:00 UTC\" \"2020-01-01 00:00:00 UTC\" vec_c(date, datetime) #> [1] \"2020-01-01 00:00:00 UTC\" \"2020-01-01 09:00:00 UTC\" vec_c(date, datetime_nz) #> [1] \"2020-01-01 00:00:00 NZDT\" \"2020-01-01 09:00:00 NZDT\""},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"missing-values","dir":"Articles","previous_headings":"c() and vctrs::vec_c()","what":"Missing values","title":"Type and size stability","text":"missing value comes beginning inputs, c() falls back internal behaviour, strips attributes: vec_c() takes different approach treating logical vector consisting NA unspecified() class can converted 1d type:","code":"c(NA, fa) #> [1] NA  1 c(NA, date) #> [1]    NA 18262 c(NA, datetime) #> [1]         NA 1577869200 vec_c(NA, fa) #> [1] <NA> a    #> Levels: a vec_c(NA, date) #> [1] NA           \"2020-01-01\" vec_c(NA, datetime) #> [1] NA                        \"2020-01-01 09:00:00 UTC\""},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"data-frames","dir":"Articles","previous_headings":"c() and vctrs::vec_c()","what":"Data frames","title":"Type and size stability","text":"almost always length-stable, c() combines data frames column wise (list): vec_c() size-stable, implies row-bind data frames:","code":"df1 <- data.frame(x = 1) df2 <- data.frame(x = 2) str(c(df1, df1)) #> List of 2 #>  $ x: num 1 #>  $ x: num 1 vec_c(df1, df2) #>   x #> 1 1 #> 2 2"},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"matrices-and-arrays","dir":"Articles","previous_headings":"c() and vctrs::vec_c()","what":"Matrices and arrays","title":"Type and size stability","text":"reasoning applies matrices: One difference vec_c() “broadcast” vector match dimensions matrix:","code":"m <- matrix(1:4, nrow = 2) c(m, m) #> [1] 1 2 3 4 1 2 3 4 vec_c(m, m) #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #> [3,]    1    3 #> [4,]    2    4 c(m, 1) #> [1] 1 2 3 4 1  vec_c(m, 1) #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #> [3,]    1    1"},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"implementation","dir":"Articles","previous_headings":"c() and vctrs::vec_c()","what":"Implementation","title":"Type and size stability","text":"basic implementation vec_c() reasonably simple. first figure properties output, .e. common type total size, allocate vec_init(), insert input correct place output. (real vec_c() bit complicated order handle inner outer names).","code":"vec_c <- function(...) {   args <- compact(list2(...))    ptype <- vec_ptype_common(!!!args)   if (is.null(ptype))     return(NULL)    ns <- map_int(args, vec_size)   out <- vec_init(ptype, sum(ns))    pos <- 1   for (i in seq_along(ns)) {     n <- ns[[i]]          x <- vec_cast(args[[i]], to = ptype)     vec_slice(out, pos:(pos + n - 1)) <- x     pos <- pos + n   }    out }"},{"path":"https://vctrs.r-lib.org/dev/articles/stability.html","id":"ifelse","dir":"Articles","previous_headings":"","what":"ifelse()","title":"Type and size stability","text":"One functions motivate development vctrs ifelse(). surprising property result value “vector length attributes (including dimensions class) test”. , seems reasonable type output controlled type yes arguments. dplyr::if_else() swung far towards strictness: throws error yes type. annoying practice requires typed missing values (NA_character_ etc), checks class (full prototype), ’s easy create invalid output. found much easier understand ifelse() internalised ideas type- size-stability: first argument must logical. vec_ptype(if_else(test, yes, )) equals vec_ptype_common(yes, ). Unlike ifelse() implies if_else() must always evaluate yes order figure correct type. think consistent && (scalar operation, short circuits) & (vectorised, evaluates sides). vec_size(if_else(test, yes, )) equals vec_size_common(test, yes, ). think output size test (.e., behaviour ifelse), think general rule inputs either mutually recycling . leads following implementation: using vec_size() vec_slice(), definition if_else() automatically works data.frames matrices:","code":"if_else <- function(test, yes, no) {   if (!is_logical(test)) {     abort(\"`test` must be a logical vector.\")   }      c(yes, no) %<-% vec_cast_common(yes, no)   c(test, yes, no) %<-% vec_recycle_common(test, yes, no)    out <- vec_init(yes, vec_size(yes))   vec_slice(out, test) <- vec_slice(yes, test)   vec_slice(out, !test) <- vec_slice(no, !test)    out }  x <- c(NA, 1:4) if_else(x > 2, \"small\", \"big\") #> [1] NA      \"big\"   \"big\"   \"small\" \"small\" if_else(x > 2, factor(\"small\"), factor(\"big\")) #> [1] <NA>  big   big   small small #> Levels: small big if_else(x > 2, Sys.Date(), Sys.Date() + 7) #> [1] NA           \"2025-09-03\" \"2025-09-03\" \"2025-08-27\" \"2025-08-27\" if_else(x > 2, data.frame(x = 1), data.frame(y = 2)) #>    x  y #> 1 NA NA #> 2 NA  2 #> 3 NA  2 #> 4  1 NA #> 5  1 NA  if_else(x > 2, matrix(1:10, ncol = 2), cbind(30, 30)) #>      [,1] [,2] #> [1,]   NA   NA #> [2,]   30   30 #> [3,]   30   30 #> [4,]    4    9 #> [5,]    5   10"},{"path":"https://vctrs.r-lib.org/dev/articles/type-size.html","id":"prototype","dir":"Articles","previous_headings":"","what":"Prototype","title":"Prototypes and sizes","text":"idea prototype capture metadata associated vector without capturing data. Unfortunately, class() object inadequate purpose: class() doesn’t include attributes. Attributes important , example, store levels factor timezone POSIXct. combine two factors two POSIXcts without thinking attributes. class() matrix “matrix” doesn’t include type underlying vector dimensionality. Instead, vctrs takes advantage R’s vectorised nature uses prototype, 0-observation slice vector (basically x[0] subtleties ’ll come back later). miniature version vector contains attributes none data. Conveniently, can create many prototypes using existing base functions (e.g, double() factor(levels = c(\"\", \"b\"))). vctrs provides helpers (e.g. new_date(), new_datetime(), new_duration()) equivalents base R missing.","code":""},{"path":"https://vctrs.r-lib.org/dev/articles/type-size.html","id":"base-prototypes","dir":"Articles","previous_headings":"Prototype","what":"Base prototypes","title":"Prototypes and sizes","text":"vec_ptype() creates prototype existing object. However, many base vectors uninformative printing methods 0-length subsets, vctrs also provides vec_ptype_show(), prints prototype friendly way (returns nothing). Using vec_ptype_show() allows us see prototypes base R classes: Atomic vectors attributes just display underlying typeof(): prototype matrices arrays include base type dimensions first: prototype factor includes levels. Levels character vector, can arbitrarily long, prototype just shows hash. hash two factors equal, ’s highly likely levels also equal. vec_ptype_show() prints hash, prototype object contain levels: Base R three key date time classes: dates, date-times (POSIXct), durations (difftime). Date-times timezone, durations unit. Data frames complex prototype: prototype data frame name prototype column: Data frames can columns data frames, making “recursive” type:","code":"vec_ptype_show(FALSE) #> Prototype: logical vec_ptype_show(1L) #> Prototype: integer vec_ptype_show(2.5) #> Prototype: double vec_ptype_show(\"three\") #> Prototype: character vec_ptype_show(list(1, 2, 3)) #> Prototype: list vec_ptype_show(array(logical(), c(2, 3))) #> Prototype: logical[,3] vec_ptype_show(array(integer(), c(2, 3, 4))) #> Prototype: integer[,3,4] vec_ptype_show(array(character(), c(2, 3, 4, 5))) #> Prototype: character[,3,4,5] vec_ptype_show(factor(\"a\")) #> Prototype: factor<4d52a> vec_ptype_show(ordered(\"b\")) #> Prototype: ordered<9b7e3> vec_ptype(factor(\"a\")) #> factor() #> Levels: a vec_ptype_show(Sys.Date()) #> Prototype: date vec_ptype_show(Sys.time()) #> Prototype: datetime<local> vec_ptype_show(as.difftime(10, units = \"mins\")) #> Prototype: duration<mins> vec_ptype_show(data.frame(a = FALSE, b = 1L, c = 2.5, d = \"x\")) #> Prototype: data.frame< #>   a: logical #>   b: integer #>   c: double #>   d: character #> > df <- data.frame(x = FALSE) df$y <- data.frame(a = 1L, b = 2.5) vec_ptype_show(df) #> Prototype: data.frame< #>   x: logical #>   y:  #>     data.frame< #>       a: integer #>       b: double #>     > #> >"},{"path":"https://vctrs.r-lib.org/dev/articles/type-size.html","id":"coercing-to-common-type","dir":"Articles","previous_headings":"Prototype","what":"Coercing to common type","title":"Prototypes and sizes","text":"’s often important combine vectors multiple types. vctrs provides consistent set rules coercion, via vec_ptype_common(). vec_ptype_common() possesses following invariants: class(vec_ptype_common(x, y)) equals class(vec_ptype_common(y, x)). class(vec_ptype_common(x, vec_ptype_common(y, z)) equals class(vec_ptype_common(vec_ptype_common(x, y), z)). vec_ptype_common(x, NULL) == vec_ptype(x). .e., vec_ptype_common() commutative associative (respect class) identity element, NULL; .e., ’s commutative monoid. means underlying implementation quite simple: can find common type number objects progressively finding common type pairs objects. Like vec_ptype(), easiest way explore vec_ptype_common() vec_ptype_show(): given multiple inputs, print common prototype. (words: program vec_ptype_common() play vec_ptype_show().) common type atomic vectors computed similar rules base R, except coerce character automatically: Matrices arrays automatically broadcast higher dimensions: Provided dimensions follow vctrs recycling rules: Factors combine levels order appear. Combining date date-time yields date-time: combining two date times, timezone taken first input: Unless ’s local timezone, case explicit time zone win: common type two data frames common type column occurs data frames: union columns occur one: Note new columns added right-hand side. consistent way factor levels time zones handled.","code":"vec_ptype_show(logical(), integer(), double()) #> Prototype: <double> #> 0. (           , <logical> ) = <logical> #> 1. ( <logical> , <integer> ) = <integer> #> 2. ( <integer> , <double>  ) = <double>  vec_ptype_show(logical(), character()) #> Error in `vec_ptype_show()`: #> ! Can't combine `out_types[[i - 1]]` <logical> and `in_types[[i]]` <character>. vec_ptype_show(   array(1, c(0, 1)),    array(1, c(0, 2)) ) #> Prototype: <double[,2]> #> 0. (              , <double[,1]> ) = <double[,1]> #> 1. ( <double[,1]> , <double[,2]> ) = <double[,2]>  vec_ptype_show(   array(1, c(0, 1)),    array(1, c(0, 3)),   array(1, c(0, 3, 4)),   array(1, c(0, 3, 4, 5)) ) #> Prototype: <double[,3,4,5]> #> 0. (                , <double[,1]>     ) = <double[,1]>     #> 1. ( <double[,1]>   , <double[,3]>     ) = <double[,3]>     #> 2. ( <double[,3]>   , <double[,3,4]>   ) = <double[,3,4]>   #> 3. ( <double[,3,4]> , <double[,3,4,5]> ) = <double[,3,4,5]> vec_ptype_show(   array(1, c(0, 2)),    array(1, c(0, 3)) ) #> Error: #> ! Can't combine `out_types[[i - 1]]` <double[,2]> and `in_types[[i]]` <double[,3]>. #> ✖ Incompatible sizes 2 and 3 along axis 2. fa <- factor(\"a\") fb <- factor(\"b\")  levels(vec_ptype_common(fa, fb)) #> [1] \"a\" \"b\" levels(vec_ptype_common(fb, fa)) #> [1] \"b\" \"a\" vec_ptype_show(new_date(), new_datetime()) #> Prototype: <datetime<local>> #> 0. (        , <date>            ) = <date>            #> 1. ( <date> , <datetime<local>> ) = <datetime<local>> vec_ptype_show(   new_datetime(tzone = \"US/Central\"),    new_datetime(tzone = \"Pacific/Auckland\") ) #> Prototype: <datetime<US/Central>> #> 0. (                        , <datetime<US/Central>>       ) = <datetime<US/Central>> #> 1. ( <datetime<US/Central>> , <datetime<Pacific/Auckland>> ) = <datetime<US/Central>> vec_ptype_show(   new_datetime(tzone = \"\"),    new_datetime(tzone = \"\"),    new_datetime(tzone = \"Pacific/Auckland\") ) #> Prototype: <datetime<Pacific/Auckland>> #> 0. (                   , <datetime<local>>            ) = <datetime<local>>            #> 1. ( <datetime<local>> , <datetime<local>>            ) = <datetime<local>>            #> 2. ( <datetime<local>> , <datetime<Pacific/Auckland>> ) = <datetime<Pacific/Auckland>> vec_ptype_show(   data.frame(x = FALSE),    data.frame(x = 1L),   data.frame(x = 2.5) ) #> Prototype: <data.frame<x:double>> #> 0. (                         , <data.frame<x:logical>> ) = <data.frame<x:logical>> #> 1. ( <data.frame<x:logical>> , <data.frame<x:integer>> ) = <data.frame<x:integer>> #> 2. ( <data.frame<x:integer>> , <data.frame<x:double>>  ) = <data.frame<x:double>> vec_ptype_show(data.frame(x = 1, y = 1), data.frame(y = 1, z = 1)) #> Prototype: <data.frame< #>   x: double #>   y: double #>   z: double #> >> #> 0. ┌              , <data.frame< ┐ = <data.frame< #>    │                  x: double  │     x: double  #>    │                  y: double  │     y: double  #>    └                >>           ┘   >>           #> 1. ┌ <data.frame< , <data.frame< ┐ = <data.frame< #>    │   x: double      y: double  │     x: double  #>    │   y: double      z: double  │     y: double  #>    │ >>             >>           │     z: double  #>    └                             ┘   >>"},{"path":"https://vctrs.r-lib.org/dev/articles/type-size.html","id":"casting-to-specified-type","dir":"Articles","previous_headings":"Prototype","what":"Casting to specified type","title":"Prototypes and sizes","text":"vec_ptype_common() finds common type set vector. Typically, however, want set vectors coerced common type. ’s job vec_cast_common(): Alternatively, can cast specific prototype using vec_cast(): cast possible general (.e., double -> integer), information lost specific input (e.g. 1.5 -> 1), generate error. can suppress lossy cast errors allow_lossy_cast(): suppress lossy cast errors. Supply prototypes want specific type lossy cast allowed: set casts permissive set coercions. enforced expected classes follow rule keep coercion ecosystem sound.","code":"str(vec_cast_common(   FALSE,    1:5,    2.5 )) #> List of 3 #>  $ : num 0 #>  $ : num [1:5] 1 2 3 4 5 #>  $ : num 2.5  str(vec_cast_common(   factor(\"x\"),    factor(\"y\") )) #> List of 2 #>  $ : Factor w/ 2 levels \"x\",\"y\": 1 #>  $ : Factor w/ 2 levels \"x\",\"y\": 2  str(vec_cast_common(   data.frame(x = 1),   data.frame(y = 1:2) )) #> List of 2 #>  $ :'data.frame':    1 obs. of  2 variables: #>   ..$ x: num 1 #>   ..$ y: int NA #>  $ :'data.frame':    2 obs. of  2 variables: #>   ..$ x: num [1:2] NA NA #>   ..$ y: int [1:2] 1 2 # Cast succeeds vec_cast(c(1, 2), integer()) #> [1] 1 2  # Cast fails vec_cast(c(1.5, 2.5), factor(\"a\")) #> Error: #> ! Can't convert `c(1.5, 2.5)` <double> to <factor<4d52a>>. vec_cast(c(1.5, 2), integer()) #> Error: #> ! Can't convert from `c(1.5, 2)` <double> to <integer> due to loss of precision. #> • Locations: 1 allow_lossy_cast(   vec_cast(c(1.5, 2), integer()) ) #> [1] 1 2 allow_lossy_cast(   vec_cast(c(1.5, 2), integer()),   x_ptype = double(),   to_ptype = integer() ) #> [1] 1 2"},{"path":"https://vctrs.r-lib.org/dev/articles/type-size.html","id":"size","dir":"Articles","previous_headings":"","what":"Size","title":"Prototypes and sizes","text":"vec_size() motivated need invariant describes number “observations” data structure. particularly important data frames, ’s useful function f(data.frame(x)) equals f(x). base function property: length(data.frame(x)) equals 1 length data frame number columns. nrow(data.frame(x)) equal nrow(x) nrow() vector NULL. NROW(data.frame(x)) equals NROW(x) vector x, almost want. NROW() defined terms length(), returns value every object, even types can’t go data frame, e.g. data.frame(mean) errors even though NROW(mean) 1. define vec_size() follows: length 1d vectors. number rows data frames, matrices, arrays. throws error non vectors. Given vec_size(), can give precise definition data frame: data frame list vectors every vector size. desirable property trivially supporting matrix data frame columns.","code":""},{"path":"https://vctrs.r-lib.org/dev/articles/type-size.html","id":"slicing","dir":"Articles","previous_headings":"Size","what":"Slicing","title":"Prototypes and sizes","text":"vec_slice() vec_size() [ length(); .e., allows select observations regardless dimensionality underlying object. vec_slice(x, ) equivalent : x[] x vector. x[, , drop = FALSE] x data frame. x[, , , drop = FALSE] x 3d array. vec_slice(data.frame(x), ) equals data.frame(vec_slice(x, )) (modulo variable row names). Prototypes generated vec_slice(x, 0L); given prototype, can initialize vector given size (filled NAs) vec_init().","code":"x <- sample(1:10) df <- data.frame(x = x)  vec_slice(x, 5:6) #> [1] 4 1 vec_slice(df, 5:6) #>   x #> 1 4 #> 2 1"},{"path":"https://vctrs.r-lib.org/dev/articles/type-size.html","id":"common-sizes-recycling-rules","dir":"Articles","previous_headings":"Size","what":"Common sizes: recycling rules","title":"Prototypes and sizes","text":"Closely related definition size recycling rules. recycling rules determine size output two vectors different sizes combined. vctrs, recycling rules encoded vec_size_common(), gives common size set vectors: vctrs obeys stricter set recycling rules base R. Vectors size 1 recycled size. size combinations generate error. strictness prevents common mistakes like dest == c(\"IAH\", \"HOU\")), cost occasionally requiring explicit calls rep(). can apply recycling rules two ways: vector desired size, use vec_recycle(): multiple vectors want recycle size, use vec_recycle_common():","code":"vec_size_common(1:3, 1:3, 1:3) #> [1] 3 vec_size_common(1:10, 1) #> [1] 10 vec_size_common(integer(), 1) #> [1] 0 vec_recycle(1:3, 3) #> [1] 1 2 3 vec_recycle(1, 10) #>  [1] 1 1 1 1 1 1 1 1 1 1 vec_recycle_common(1:3, 1:3) #> [[1]] #> [1] 1 2 3 #>  #> [[2]] #> [1] 1 2 3 vec_recycle_common(1:10, 1) #> [[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  #> [[2]] #>  [1] 1 1 1 1 1 1 1 1 1 1"},{"path":"https://vctrs.r-lib.org/dev/articles/type-size.html","id":"appendix-recycling-in-base-r","dir":"Articles","previous_headings":"","what":"Appendix: recycling in base R","title":"Prototypes and sizes","text":"recycling rules base R described R Language Definition implemented single function thus applied consistently. , give brief overview common realisation, well showing exceptions. Generally, base R, pair vectors length, shorter vector recycled length longer: length longer vector integer multiple length shorter, usually get warning: functions recycle silently: data.frame() throws error: R language definition states “arithmetic operation involving zero-length vector zero-length result”. outside arithmetic, rule consistently followed:","code":"rep(1, 6) + 1 #> [1] 2 2 2 2 2 2 rep(1, 6) + 1:2 #> [1] 2 3 2 3 2 3 rep(1, 6) + 1:3 #> [1] 2 3 4 2 3 4 invisible(pmax(1:2, 1:3)) #> Warning in pmax(1:2, 1:3): an argument will be fractionally recycled invisible(1:2 + 1:3) #> Warning in 1:2 + 1:3: longer object length is not a multiple of #> shorter object length invisible(cbind(1:2, 1:3)) #> Warning in cbind(1:2, 1:3): number of rows of result is not a multiple #> of vector length (arg 1) length(atan2(1:3, 1:2)) #> [1] 3 length(paste(1:3, 1:2)) #> [1] 3 length(ifelse(1:3, 1:2, 1:2)) #> [1] 3 data.frame(1:2, 1:3) #> Error in data.frame(1:2, 1:3): arguments imply differing number of rows: 2, 3 # length-0 output 1:2 + integer() #> integer(0) atan2(1:2, integer()) #> numeric(0) pmax(1:2, integer()) #> integer(0)  # dropped cbind(1:2, integer()) #>      [,1] #> [1,]    1 #> [2,]    2  # recycled to length of first ifelse(rep(TRUE, 4), integer(), character()) #> [1] NA NA NA NA  # preserved-ish paste(1:2, integer()) #> [1] \"1 \" \"2 \"  # Errors data.frame(1:2, integer()) #> Error in data.frame(1:2, integer()): arguments imply differing number of rows: 2, 0"},{"path":"https://vctrs.r-lib.org/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Hadley Wickham. Author. Lionel Henry. Author. Davis Vaughan. Author, maintainer. data.table team. Copyright holder.           Radix sort based data.table's forder() contribution R's order() . Copyright holder, funder.","code":""},{"path":"https://vctrs.r-lib.org/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wickham H, Henry L, Vaughan D (2025). vctrs: Vector Helpers. R package version 0.6.5.9000, https://vctrs.r-lib.org/.","code":"@Manual{,   title = {vctrs: Vector Helpers},   author = {Hadley Wickham and Lionel Henry and Davis Vaughan},   year = {2025},   note = {R package version 0.6.5.9000},   url = {https://vctrs.r-lib.org/}, }"},{"path":"https://vctrs.r-lib.org/dev/index.html","id":"vctrs-","dir":"","previous_headings":"","what":"Vector Helpers","title":"Vector Helpers","text":"three main goals vctrs package, described vignette: propose vec_size() vec_ptype() alternatives length() class(); vignette(\"type-size\"). definitions paired framework size-recycling type-coercion. ptype evoke notion prototype, .e. original typical form something. define size- type-stability desirable function properties, use analyse existing base functions, propose better alternatives; vignette(\"stability\"). work particularly motivated thinking ideal properties c(), ifelse(), rbind(). provide new vctr base class makes easy create new S3 vectors; vignette(\"s3-vector\"). vctrs provides methods many base generics terms new vctrs generics, making implementation considerably simpler robust. vctrs developer-focussed package. Understanding extending vctrs requires effort developers, invisible users. ’s hope underlying theory mean users can build accurate mental model without explicitly learning theory. vctrs typically used packages, making easy provide new classes S3 vectors supported throughout tidyverse (beyond). reason, vctrs dependencies.","code":""},{"path":"https://vctrs.r-lib.org/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Vector Helpers","text":"Install vctrs CRAN : Alternatively, need development version, install :","code":"install.packages(\"vctrs\") # install.packages(\"pak\") pak::pak(\"r-lib/vctrs\")"},{"path":"https://vctrs.r-lib.org/dev/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Vector Helpers","text":"","code":"library(vctrs)  # Sizes str(vec_size_common(1, 1:10)) #>  int 10 str(vec_recycle_common(1, 1:10)) #> List of 2 #>  $ : num [1:10] 1 1 1 1 1 1 1 1 1 1 #>  $ : int [1:10] 1 2 3 4 5 6 7 8 9 10  # Prototypes str(vec_ptype_common(FALSE, 1L, 2.5)) #>  num(0) str(vec_cast_common(FALSE, 1L, 2.5)) #> List of 3 #>  $ : num 0 #>  $ : num 1 #>  $ : num 2.5"},{"path":"https://vctrs.r-lib.org/dev/index.html","id":"motivation","dir":"","previous_headings":"","what":"Motivation","title":"Vector Helpers","text":"original motivation vctrs comes two separate related problems. first problem base::c() rather undesirable behaviour mix different S3 vectors: behaviour arises c() dual purposes: well primary duty combining vectors, secondary duty stripping attributes. example, ?POSIXct suggests use c() want reset timezone. second problem dplyr::bind_rows() extensible others. Currently, handles arbitrary S3 classes using heuristics, often fail, feels like really need think problem order build principled solution. intersects need cleanly support types data frame columns, including lists data frames, data frames, matrices.","code":"# combining factors makes integers c(factor(\"a\"), factor(\"b\")) #> [1] 1 1  # combining dates and date-times gives incorrect values; also, order matters dt <- as.Date(\"2020-01-01\") dttm <- as.POSIXct(dt)  c(dt, dttm) #> [1] \"2020-01-01\"    \"4321940-06-07\" c(dttm, dt) #> [1] \"2019-12-31 19:00:00 EST\" \"1970-01-01 00:04:22 EST\""},{"path":"https://vctrs.r-lib.org/dev/reference/as-is.html","id":null,"dir":"Reference","previous_headings":"","what":"AsIs S3 class — as-is","title":"AsIs S3 class — as-is","text":"functions help base AsIs class fit vctrs type system providing coercion casting functions.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/as-is.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AsIs S3 class — as-is","text":"","code":"# S3 method for class 'AsIs' vec_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\")"},{"path":"https://vctrs.r-lib.org/dev/reference/data_frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a data frame — data_frame","title":"Construct a data frame — data_frame","text":"data_frame() constructs data frame. similar base::data.frame(), notable differences make line vctrs principles. Properties section outlines .","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/data_frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a data frame — data_frame","text":"","code":"data_frame(   ...,   .size = NULL,   .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\", \"unique_quiet\",     \"universal_quiet\"),   .error_call = current_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/data_frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a data frame — data_frame","text":"... Vectors become columns data frame. inputs named, names used column names. .size number rows data frame. NULL, computed common size inputs. .name_repair One \"check_unique\", \"unique\", \"universal\", \"minimal\", \"unique_quiet\", \"universal_quiet\". See vec_as_names() meaning options. .error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/data_frame.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a data frame — data_frame","text":"column names supplied, \"\" used default name columns. applied name repair occurs, default name repair \"check_unique\" error unnamed inputs supplied \"unique\" (\"unique_quiet\") repair empty string column names appropriately. column names matter, use \"minimal\" name repair convenience performance.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/data_frame.html","id":"properties","dir":"Reference","previous_headings":"","what":"Properties","title":"Construct a data frame — data_frame","text":"Inputs recycled common size vec_recycle_common(). exception data frames, inputs modified way. Character vectors never converted factors, lists stored -easy creation list-columns. Unnamed data frame inputs automatically unpacked. Named data frame inputs stored unmodified data frame columns. NULL inputs completely ignored. dots dynamic, allowing splicing lists !!! unquoting.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/data_frame.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a data frame — data_frame","text":"","code":"data_frame(x = 1, y = 2) #>   x y #> 1 1 2  # Inputs are recycled using tidyverse recycling rules data_frame(x = 1, y = 1:3) #>   x y #> 1 1 1 #> 2 1 2 #> 3 1 3  # Strings are never converted to factors class(data_frame(x = \"foo\")$x) #> [1] \"character\"  # List columns can be easily created df <- data_frame(x = list(1:2, 2, 3:4), y = 3:1)  # However, the base print method is suboptimal for displaying them, # so it is recommended to convert them to tibble if (rlang::is_installed(\"tibble\")) {   tibble::as_tibble(df) } #> # A tibble: 3 × 2 #>   x             y #>   <list>    <int> #> 1 <int [2]>     3 #> 2 <dbl [1]>     2 #> 3 <int [2]>     1  # Named data frame inputs create data frame columns df <- data_frame(x = data_frame(y = 1:2, z = \"a\"))  # The `x` column itself is another data frame df$x #>   y z #> 1 1 a #> 2 2 a  # Again, it is recommended to convert these to tibbles for a better # print method if (rlang::is_installed(\"tibble\")) {   tibble::as_tibble(df) } #> # A tibble: 2 × 1 #>     x$y $z    #>   <int> <chr> #> 1     1 a     #> 2     2 a      # Unnamed data frame input is automatically unpacked data_frame(x = 1, data_frame(y = 1:2, z = \"a\")) #>   x y z #> 1 1 1 a #> 2 1 2 a"},{"path":"https://vctrs.r-lib.org/dev/reference/df_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Collect columns for data frame construction — df_list","title":"Collect columns for data frame construction — df_list","text":"df_list() constructs data structure underlying data frame, named list equal-length vectors. often used combination new_data_frame() safely consistently create helper function data frame subclasses.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/df_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collect columns for data frame construction — df_list","text":"","code":"df_list(   ...,   .size = NULL,   .unpack = TRUE,   .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\", \"unique_quiet\",     \"universal_quiet\"),   .error_call = current_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/df_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collect columns for data frame construction — df_list","text":"... Vectors equal-length. inputs named, names used names resulting list. .size common size vectors supplied .... NULL, computed common size inputs. .unpack unnamed data frame inputs unpacked? Defaults TRUE. .name_repair One \"check_unique\", \"unique\", \"universal\", \"minimal\", \"unique_quiet\", \"universal_quiet\". See vec_as_names() meaning options. .error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/df_list.html","id":"properties","dir":"Reference","previous_headings":"","what":"Properties","title":"Collect columns for data frame construction — df_list","text":"Inputs recycled common size vec_recycle_common(). exception data frames, inputs modified way. Character vectors never converted factors, lists stored -easy creation list-columns. Unnamed data frame inputs automatically unpacked. Named data frame inputs stored unmodified data frame columns. NULL inputs completely ignored. dots dynamic, allowing splicing lists !!! unquoting.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/df_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collect columns for data frame construction — df_list","text":"","code":"# `new_data_frame()` can be used to create custom data frame constructors new_fancy_df <- function(x = list(), n = NULL, ..., class = NULL) {   new_data_frame(x, n = n, ..., class = c(class, \"fancy_df\")) }  # Combine this constructor with `df_list()` to create a safe, # consistent helper function for your data frame subclass fancy_df <- function(...) {   data <- df_list(...)   new_fancy_df(data) }  df <- fancy_df(x = 1) class(df) #> [1] \"fancy_df\"   \"data.frame\""},{"path":"https://vctrs.r-lib.org/dev/reference/df_ptype2.html","id":null,"dir":"Reference","previous_headings":"","what":"Coercion between two data frames — df_ptype2","title":"Coercion between two data frames — df_ptype2","text":"df_ptype2() df_cast() two functions need call vec_ptype2() vec_cast() methods data frame subclasses. See ?howto-faq-coercion-data-frame. main job determine common type two data frames, adding coercing columns needed, throwing incompatible type error columns compatible.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/df_ptype2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coercion between two data frames — df_ptype2","text":"","code":"df_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\", call = caller_env())  df_cast(x, to, ..., x_arg = \"\", to_arg = \"\", call = caller_env())  tib_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\", call = caller_env())  tib_cast(x, to, ..., x_arg = \"\", to_arg = \"\", call = caller_env())"},{"path":"https://vctrs.r-lib.org/dev/reference/df_ptype2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coercion between two data frames — df_ptype2","text":"x, y, Subclasses data frame. ... call df_ptype2() df_cast() vec_ptype2() vec_cast() method, must forward dots passed method df_ptype2() df_cast(). x_arg, y_arg Argument names x y. used error messages inform user locations incompatible types (see stop_incompatible_type()). call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. to_arg Argument name used error messages inform user locations incompatible types (see stop_incompatible_type()).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/df_ptype2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coercion between two data frames — df_ptype2","text":"x y compatible, error class vctrs_error_incompatible_type thrown. x y compatible, df_ptype2() returns common type bare data frame. tib_ptype2() returns common type bare tibble.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/faq-compatibility-types.html","id":null,"dir":"Reference","previous_headings":"","what":"FAQ - How is the compatibility of vector types decided? — faq-compatibility-types","title":"FAQ - How is the compatibility of vector types decided? — faq-compatibility-types","text":"Two vectors compatible can safely: Combine one larger vector. Assign values one vectors vector. Examples compatible types integer double vectors. hand, integer character vectors compatible.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/faq-compatibility-types.html","id":"common-type-of-multiple-vectors","dir":"Reference","previous_headings":"","what":"Common type of multiple vectors","title":"FAQ - How is the compatibility of vector types decided? — faq-compatibility-types","text":"two possible outcomes multiple vectors different types combined larger vector: incompatible type error thrown types compatible:   vectors combined vector common type inputs. example, common type integer logical integer:   general, common type richer type, words type can represent values. Logical vectors bottom hierarchy numeric types can represent two values (counting missing values). come integer vectors, doubles. vctrs type hierarchy fundamental vectors:","code":"df1 <- data.frame(x = 1:3) df2 <- data.frame(x = \"foo\") dplyr::bind_rows(df1, df2) #> Error in `dplyr::bind_rows()`: #> ! Can't combine `..1$x` <integer> and `..2$x` <character>. df1 <- data.frame(x = 1:3) df2 <- data.frame(x = FALSE) dplyr::bind_rows(df1, df2) #>   x #> 1 1 #> 2 2 #> 3 3 #> 4 0"},{"path":"https://vctrs.r-lib.org/dev/reference/faq-compatibility-types.html","id":"type-conversion-and-lossy-cast-errors","dir":"Reference","previous_headings":"","what":"Type conversion and lossy cast errors","title":"FAQ - How is the compatibility of vector types decided? — faq-compatibility-types","text":"Type compatibility necessarily mean can convert one type type. ’s one types might support larger set possible values. instance, integer double vectors compatible, double vectors can’t converted integer contain fractional values. vctrs can’t convert vector target type rich source type, throws lossy cast error. Assigning fractional number integer vector typical example lossy cast error:","code":"int_vector <- 1:3 vec_assign(int_vector, 2, 0.001) #> Error in `vec_assign()`: #> ! Can't convert from <double> to <integer> due to loss of precision. #> * Locations: 1"},{"path":"https://vctrs.r-lib.org/dev/reference/faq-compatibility-types.html","id":"how-to-make-two-vector-classes-compatible-","dir":"Reference","previous_headings":"","what":"How to make two vector classes compatible?","title":"FAQ - How is the compatibility of vector types decided? — faq-compatibility-types","text":"encounter two vector types think compatible, might need implement coercion methods. Reach author(s) classes ask makes sense classes compatible. developer FAQ items provide guides implementing coercion methods: example implementing coercion methods simple vectors, see ?howto-faq-coercion. example implementing coercion methods data frame subclasses, see ?howto-faq-coercion-data-frame.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/faq-error-incompatible-attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"FAQ - Error/Warning: Some attributes are incompatible — faq-error-incompatible-attributes","title":"FAQ - Error/Warning: Some attributes are incompatible — faq-error-incompatible-attributes","text":"error occurs vec_ptype2() vec_cast() supplied vectors classes different attributes. case, vctrs know combine inputs. fix error, maintainer class implement self--self coercion methods vec_ptype2() vec_cast().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/faq-error-incompatible-attributes.html","id":"implementing-coercion-methods","dir":"Reference","previous_headings":"","what":"Implementing coercion methods","title":"FAQ - Error/Warning: Some attributes are incompatible — faq-error-incompatible-attributes","text":"overview generics work roles vctrs, see ?theory-faq-coercion. example implementing coercion methods simple vectors, see ?howto-faq-coercion. example implementing coercion methods data frame subclasses, see ?howto-faq-coercion-data-frame. tutorial implementing vctrs classes scratch, see vignette(\"s3-vector\").","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/faq-error-scalar-type.html","id":null,"dir":"Reference","previous_headings":"","what":"FAQ - Error: Input must be a vector — faq-error-scalar-type","title":"FAQ - Error: Input must be a vector — faq-error-scalar-type","text":"error occurs function expects vector gets scalar object instead. commonly happens code attempts assign scalar object column data frame:","code":"fn <- function() NULL tibble::tibble(x = fn) #> Error in `tibble::tibble()`: #> ! All columns in a tibble must be vectors. #> x Column `x` is a function.  fit <- lm(1:3 ~ 1) tibble::tibble(x = fit) #> Error in `tibble::tibble()`: #> ! All columns in a tibble must be vectors. #> x Column `x` is a `lm` object."},{"path":"https://vctrs.r-lib.org/dev/reference/faq-error-scalar-type.html","id":"vectorness-in-base-r-and-in-the-tidyverse","dir":"Reference","previous_headings":"","what":"Vectorness in base R and in the tidyverse","title":"FAQ - Error: Input must be a vector — faq-error-scalar-type","text":"base R, almost everything vector behaves like vector. tidyverse chosen bit stricter considered vector. main question ask decide vectorness type whether makes sense include object column data frame. main difference S3 lists considered vectors base R tidyverse ’s case default:   Defused function calls another (esoteric) example:","code":"fit <- lm(1:3 ~ 1)  typeof(fit) #> [1] \"list\" class(fit) #> [1] \"lm\"  # S3 lists can be subset like a vector using base R: fit[c(1, 4)] #> $coefficients #> (Intercept) #>           2 #> #> $rank #> [1] 1  # But not in vctrs vctrs::vec_slice(fit, c(1, 4)) #> Error in `vctrs::vec_slice()`: #> ! `x` must be a vector, not a <lm> object. call <- quote(foo(bar = TRUE, baz = FALSE)) call #> foo(bar = TRUE, baz = FALSE)  # They can be subset like a vector using base R: call[1:2] #> foo(bar = TRUE) lapply(call, function(x) x) #> [[1]] #> foo #> #> $bar #> [1] TRUE #> #> $baz #> [1] FALSE  # But not with vctrs: vctrs::vec_slice(call, 1:2) #> Error in `vctrs::vec_slice()`: #> ! `x` must be a vector, not a call."},{"path":"https://vctrs.r-lib.org/dev/reference/faq-error-scalar-type.html","id":"i-get-a-scalar-type-error-but-i-think-this-is-a-bug","dir":"Reference","previous_headings":"","what":"I get a scalar type error but I think this is a bug","title":"FAQ - Error: Input must be a vector — faq-error-scalar-type","text":"’s possible author class needs work declare class vector. Consider reaching author. written developer FAQ page help fix issue.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/fields.html","id":null,"dir":"Reference","previous_headings":"","what":"Tools for accessing the fields of a record. — fields","title":"Tools for accessing the fields of a record. — fields","text":"rcrd behaves like vector, length(), names(), $ can provide access fields underlying list. helpers : fields() equivalent names(); n_fields() equivalent length(); field() equivalent $.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/fields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tools for accessing the fields of a record. — fields","text":"","code":"fields(x)  n_fields(x)  field(x, i)  field(x, i) <- value"},{"path":"https://vctrs.r-lib.org/dev/reference/fields.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tools for accessing the fields of a record. — fields","text":"x rcrd, .e. list equal length vectors unique names.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/fields.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tools for accessing the fields of a record. — fields","text":"","code":"x <- new_rcrd(list(x = 1:3, y = 3:1, z = letters[1:3])) n_fields(x) #> [1] 3 fields(x) #> [1] \"x\" \"y\" \"z\"  field(x, \"y\") #> [1] 3 2 1 field(x, \"y\") <- runif(3) field(x, \"y\") #> [1] 0.4977774 0.2897672 0.7328820"},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion-data-frame.html","id":null,"dir":"Reference","previous_headings":"","what":"FAQ - How to implement ptype2 and cast methods? (Data frames) — howto-faq-coercion-data-frame","title":"FAQ - How to implement ptype2 and cast methods? (Data frames) — howto-faq-coercion-data-frame","text":"guide provides practical recipe implementing vec_ptype2() vec_cast() methods coercions data frame subclasses. Related topics: overview coercion mechanism vctrs, see ?theory-faq-coercion. example implementing coercion methods simple vectors, see ?howto-faq-coercion. Coercion data frames occurs different data frame classes combined way. two main methods combination currently row-binding vec_rbind() col-binding vec_cbind() (turn used number dplyr tidyr functions). functions take multiple data frame inputs automatically coerce common type. vctrs generally strict kind automatic coercions performed combining inputs. case data frames decided bit less strict convenience. Instead throwing incompatible type error, fall back base data frame tibble don’t know combine two data frame subclasses. still good idea specify proper coercion behaviour data frame subclasses soon possible. see two examples guide. first example data frame subclass particular attributes manage. second example, implement coercion methods tibble subclass includes potentially incompatible attributes.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion-data-frame.html","id":"roxygen-workflow","dir":"Reference","previous_headings":"","what":"Roxygen workflow","title":"FAQ - How to implement ptype2 and cast methods? (Data frames) — howto-faq-coercion-data-frame","text":"implement methods generics, first import generics namespace redocument:   Note batches methods add package, need export methods redocument immediately, even development. Otherwise won’t scope run unit tests e.g. testthat. Implementing double dispatch methods similar implementing regular S3 methods. examples using roxygen2 tags register methods, can also register methods manually NAMESPACE file lazily s3_register().","code":"#' @importFrom vctrs vec_ptype2 vec_cast NULL"},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion-data-frame.html","id":"parent-methods","dir":"Reference","previous_headings":"","what":"Parent methods","title":"FAQ - How to implement ptype2 and cast methods? (Data frames) — howto-faq-coercion-data-frame","text":"common type determination performed parent class. vctrs, double dispatch implemented way need call methods parent class manually. vec_ptype2() means need call df_ptype2() (data frame subclasses) tib_ptype2() (tibble subclasses). Similarly, df_cast() tib_cast() workhorses vec_cast() methods subtypes data.frame tbl_df. functions take union columns x y, ensure shared columns type. functions much less strict vec_ptype2() vec_cast() accept subclass data frame input. always return data.frame tbl_df. probably want write similar functions subclass avoid repetition code. may want export well expecting people derive class.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion-data-frame.html","id":"a-data-table-example","dir":"Reference","previous_headings":"","what":"A data.table example","title":"FAQ - How to implement ptype2 and cast methods? (Data frames) — howto-faq-coercion-data-frame","text":"example actual implementation vctrs coercion methods data.table. simple example don’t keep track attributes class manage incompatibilities. See tibble section complicated example. first create dt_ptype2() dt_cast() helpers. wrap around parent methods df_ptype2() df_cast(), transform common type converted input data table. may want export helpers expect packages derive data frame class. helpers always return data tables. end use conversion generic .data.table(). Depending tools available particular class hand, constructor might appropriate well.   start self-self method:   data frame data table, consider richer type data table. decision based value coverage data structures, idea data tables richer behaviour. Since data tables richer type, call dt_type2() vec_ptype2() method. always returns data table, matter order arguments:   vec_cast() methods follow pattern, note method coercing data frame uses df_cast() rather dt_cast(). Also, please note historical reasons, order classes method name reverse order arguments function signature. first class represents , whereas second class represents x.   methods vctrs now able combine data tables data frames:","code":"dt_ptype2 <- function(x, y, ...) {   as.data.table(df_ptype2(x, y, ...)) } dt_cast <- function(x, to, ...) {   as.data.table(df_cast(x, to, ...)) } #' @export vec_ptype2.data.table.data.table <- function(x, y, ...) {   dt_ptype2(x, y, ...) } #' @export vec_ptype2.data.table.data.frame <- function(x, y, ...) {   dt_ptype2(x, y, ...) } #' @export vec_ptype2.data.frame.data.table <- function(x, y, ...) {   dt_ptype2(x, y, ...) } #' @export vec_cast.data.table.data.table <- function(x, to, ...) {   dt_cast(x, to, ...) } #' @export vec_cast.data.table.data.frame <- function(x, to, ...) {   # `x` is a data.frame to be converted to a data.table   dt_cast(x, to, ...) } #' @export vec_cast.data.frame.data.table <- function(x, to, ...) {   # `x` is a data.table to be converted to a data.frame   df_cast(x, to, ...) } vec_cbind(data.frame(x = 1:3), data.table(y = \"foo\")) #>        x      y #>    <int> <char> #> 1:     1    foo #> 2:     2    foo #> 3:     3    foo"},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion-data-frame.html","id":"a-tibble-example","dir":"Reference","previous_headings":"","what":"A tibble example","title":"FAQ - How to implement ptype2 and cast methods? (Data frames) — howto-faq-coercion-data-frame","text":"example implement coercion methods tibble subclass carries colour scalar metadata:   subclass simple. modify header.   Combinations work properly box, instead vctrs falls back bare tibble:   Instead falling back data frame, like return <my_tibble> combined data frame tibble. subclass metadata normal data frames (colour), supertype tibble data frame, .e. richer type. similar grouped tibble general type tibble data frame. Conceptually, latter pinned single constant group. coercion methods data frames operate two steps: check compatible subclass attributes. case tibble colour , undefined. call parent methods, case tib_ptype2() tib_cast() subclass tibble. eventually calls data frame methods df_ptype2() tib_ptype2() match columns types. process usually wrapped two functions avoid repetition. Consider exporting expect class derived subclasses. first implement helper determine two data frames compatible colours. use df_colour() accessor returns NULL data frame colour undefined.   Next implement coercion helpers. colours compatible, call stop_incompatible_cast() stop_incompatible_type(). strict coercion semantics justified class colour data attribute. non essential detail attribute, like timezone datetime, just standardise value left-hand side. simpler cases (like data.table example), methods need take arguments suffixed _arg. need take arguments can pass stop_ functions detect incompatibility. also passed parent methods.   Let’s now implement coercion methods, starting self-self methods.   can now combine compatible instances class!   methods combining class tibbles follow pattern. ptype2 return class cases richer type:   cast careful returning tibble casting tibble. Note call vctrs::tib_cast():   point, get correct combinations tibbles:   However done yet. coercion hierarchy different class hierarchy, inheritance coercion methods. ’re getting correct behaviour data frames yet haven’t explicitly specified methods class:   Let’s finish boiler plate:   completes implementation:","code":"# User constructor my_tibble <- function(colour = NULL, ...) {   new_my_tibble(tibble::tibble(...), colour = colour) } # Developer constructor new_my_tibble <- function(x, colour = NULL) {   stopifnot(is.data.frame(x))   tibble::new_tibble(     x,     colour = colour,     class = \"my_tibble\",     nrow = nrow(x)   ) }  df_colour <- function(x) {   if (inherits(x, \"my_tibble\")) {     attr(x, \"colour\")   } else {     NULL   } }  #'@export print.my_tibble <- function(x, ...) {   cat(sprintf(\"<%s: %s>\\n\", class(x)[[1]], df_colour(x)))   cli::cat_line(format(x)[-1]) } red <- my_tibble(\"red\", x = 1, y = 1:2) red #> <my_tibble: red> #>       x     y #>   <dbl> <int> #> 1     1     1 #> 2     1     2  red[2] #> <my_tibble: red> #>       y #>   <int> #> 1     1 #> 2     2  green <- my_tibble(\"green\", z = TRUE) green #> <my_tibble: green> #>   z #>   <lgl> #> 1 TRUE vec_rbind(red, tibble::tibble(x = 10:12)) #> # A tibble: 5 x 2 #>       x     y #>   <dbl> <int> #> 1     1     1 #> 2     1     2 #> 3    10    NA #> 4    11    NA #> 5    12    NA has_compatible_colours <- function(x, y) {   x_colour <- df_colour(x) %||% df_colour(y)   y_colour <- df_colour(y) %||% x_colour   identical(x_colour, y_colour) } #' @export my_tib_cast <- function(x, to, ..., x_arg = \"\", to_arg = \"\") {   out <- tib_cast(x, to, ..., x_arg = x_arg, to_arg = to_arg)    if (!has_compatible_colours(x, to)) {     stop_incompatible_cast(       x,       to,       x_arg = x_arg,       to_arg = to_arg,       details = \"Can't combine colours.\"     )   }    colour <- df_colour(x) %||% df_colour(to)   new_my_tibble(out, colour = colour) } #' @export my_tib_ptype2 <- function(x, y, ..., x_arg = \"\", y_arg = \"\") {   out <- tib_ptype2(x, y, ..., x_arg = x_arg, y_arg = y_arg)    if (!has_compatible_colours(x, y)) {     stop_incompatible_type(       x,       y,       x_arg = x_arg,       y_arg = y_arg,       details = \"Can't combine colours.\"     )   }    colour <- df_colour(x) %||% df_colour(y)   new_my_tibble(out, colour = colour) } #' @export vec_ptype2.my_tibble.my_tibble <- function(x, y, ...) {   my_tib_ptype2(x, y, ...) } #' @export vec_cast.my_tibble.my_tibble <- function(x, to, ...) {   my_tib_cast(x, to, ...) } vec_rbind(red, red) #> <my_tibble: red> #>       x     y #>   <dbl> <int> #> 1     1     1 #> 2     1     2 #> 3     1     1 #> 4     1     2  vec_rbind(green, green) #> <my_tibble: green> #>   z #>   <lgl> #> 1 TRUE #> 2 TRUE  vec_rbind(green, red) #> Error in `my_tib_ptype2()`: #> ! Can't combine `..1` <my_tibble> and `..2` <my_tibble>. #> Can't combine colours. #' @export vec_ptype2.my_tibble.tbl_df <- function(x, y, ...) {   my_tib_ptype2(x, y, ...) } #' @export vec_ptype2.tbl_df.my_tibble <- function(x, y, ...) {   my_tib_ptype2(x, y, ...) } #' @export vec_cast.my_tibble.tbl_df <- function(x, to, ...) {   my_tib_cast(x, to, ...) } #' @export vec_cast.tbl_df.my_tibble <- function(x, to, ...) {   tib_cast(x, to, ...) } vec_rbind(red, tibble::tibble(x = 10:12)) #> <my_tibble: red> #>       x     y #>   <dbl> <int> #> 1     1     1 #> 2     1     2 #> 3    10    NA #> 4    11    NA #> 5    12    NA vec_rbind(red, data.frame(x = 10:12)) #> # A tibble: 5 x 2 #>       x     y #>   <dbl> <int> #> 1     1     1 #> 2     1     2 #> 3    10    NA #> 4    11    NA #> 5    12    NA #' @export vec_ptype2.my_tibble.data.frame <- function(x, y, ...) {   my_tib_ptype2(x, y, ...) } #' @export vec_ptype2.data.frame.my_tibble <- function(x, y, ...) {   my_tib_ptype2(x, y, ...) }  #' @export vec_cast.my_tibble.data.frame <- function(x, to, ...) {   my_tib_cast(x, to, ...) } #' @export vec_cast.data.frame.my_tibble <- function(x, to, ...) {   df_cast(x, to, ...) } vec_rbind(red, data.frame(x = 10:12)) #> <my_tibble: red> #>       x     y #>   <dbl> <int> #> 1     1     1 #> 2     1     2 #> 3    10    NA #> 4    11    NA #> 5    12    NA"},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion.html","id":null,"dir":"Reference","previous_headings":"","what":"FAQ - How to implement ptype2 and cast methods? — howto-faq-coercion","title":"FAQ - How to implement ptype2 and cast methods? — howto-faq-coercion","text":"guide illustrates implement vec_ptype2() vec_cast() methods existing classes. Related topics: overview generics work roles vctrs, see ?theory-faq-coercion. example implementing coercion methods data frame subclasses, see ?howto-faq-coercion-data-frame. tutorial implementing vctrs classes scratch, see vignette(\"s3-vector\")","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion.html","id":"the-natural-number-class","dir":"Reference","previous_headings":"","what":"The natural number class","title":"FAQ - How to implement ptype2 and cast methods? — howto-faq-coercion","text":"’ll illustrate implement coercion methods simple class represents natural numbers. scenario existing class already features constructor methods print() subset.","code":"#' @export new_natural <- function(x) {   if (is.numeric(x) || is.logical(x)) {     stopifnot(is_whole(x))     x <- as.integer(x)   } else {     stop(\"Can't construct natural from unknown type.\")   }   structure(x, class = \"my_natural\") } is_whole <- function(x) {   all(x %% 1 == 0 | is.na(x)) }  #' @export print.my_natural <- function(x, ...) {   cat(\"<natural>\\n\")   x <- unclass(x)   NextMethod() } #' @export `[.my_natural` <- function(x, i, ...) {   new_natural(NextMethod()) } new_natural(1:3) #> <natural> #> [1] 1 2 3 new_natural(c(1, NA)) #> <natural> #> [1]  1 NA"},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion.html","id":"roxygen-workflow","dir":"Reference","previous_headings":"","what":"Roxygen workflow","title":"FAQ - How to implement ptype2 and cast methods? — howto-faq-coercion","text":"implement methods generics, first import generics namespace redocument:   Note batches methods add package, need export methods redocument immediately, even development. Otherwise won’t scope run unit tests e.g. testthat. Implementing double dispatch methods similar implementing regular S3 methods. examples using roxygen2 tags register methods, can also register methods manually NAMESPACE file lazily s3_register().","code":"#' @importFrom vctrs vec_ptype2 vec_cast NULL"},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion.html","id":"the-self-self-method","dir":"Reference","previous_headings":"","what":"The self-self method","title":"FAQ - How to implement ptype2 and cast methods? — howto-faq-coercion","text":"first method implement one signals class compatible :   vec_ptype2() implements fallback try compatible simple classes, may seem don’t need implement self-self coercion method. However, must implement explicitly vctrs knows class implementing vctrs methods (instance disable fallbacks base::c()). Also, makes class bit efficient.","code":"#' @export vec_ptype2.my_natural.my_natural <- function(x, y, ...) {   x }  vec_ptype2(new_natural(1), new_natural(2:3)) #> <natural> #> integer(0)"},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion.html","id":"the-parent-and-children-methods","dir":"Reference","previous_headings":"","what":"The parent and children methods","title":"FAQ - How to implement ptype2 and cast methods? — howto-faq-coercion","text":"natural number class conceptually parent <logical> child <integer>, class compatible logical, integer, double vectors yet:   ’ll specify twin methods classes, returning richer class case.   natural number integer, latter richer class:   longer get common type errors logical integer:   done yet. Pairwise coercion methods must implemented connected nodes coercion hierarchy, include double vectors . coercion methods grand-parent types must implemented separately:","code":"vec_ptype2(TRUE, new_natural(2:3)) #> Error: #> ! Can't combine `TRUE` <logical> and `new_natural(2:3)` <my_natural>.  vec_ptype2(new_natural(1), 2:3) #> Error: #> ! Can't combine `new_natural(1)` <my_natural> and `2:3` <integer>. #' @export vec_ptype2.my_natural.logical <- function(x, y, ...) {   # The order of the classes in the method name follows the order of   # the arguments in the function signature, so `x` is the natural   # number and `y` is the logical   x } #' @export vec_ptype2.logical.my_natural <- function(x, y, ...) {   # In this case `y` is the richer natural number   y } #' @export vec_ptype2.my_natural.integer <- function(x, y, ...) {   y } #' @export vec_ptype2.integer.my_natural <- function(x, y, ...) {   x } vec_ptype2(TRUE, new_natural(2:3)) #> <natural> #> integer(0)  vec_ptype2(new_natural(1), 2:3) #> integer(0) #' @export vec_ptype2.my_natural.double <- function(x, y, ...) {   y } #' @export vec_ptype2.double.my_natural <- function(x, y, ...) {   x }"},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion.html","id":"incompatible-attributes","dir":"Reference","previous_headings":"","what":"Incompatible attributes","title":"FAQ - How to implement ptype2 and cast methods? — howto-faq-coercion","text":"time, inputs incompatible different classes vec_ptype2() method implemented. rarely, inputs incompatible attributes. case incompatibility signalled calling stop_incompatible_type(). following example, implement self-self ptype2 method hypothetical subclass <factor> stricter combination semantics. method throws error levels two factors compatible.   Note methods need take x_arg y_arg parameters pass stop_incompatible_type(). argument tags help create informative error messages common type determination column data frame. part generic signature can usually left used.","code":"#' @export vec_ptype2.my_strict_factor.my_strict_factor <- function(x, y, ..., x_arg = \"\", y_arg = \"\") {   if (!setequal(levels(x), levels(y))) {     stop_incompatible_type(x, y, x_arg = x_arg, y_arg = y_arg)   }    x }"},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-coercion.html","id":"implementing-vec-cast-","dir":"Reference","previous_headings":"","what":"Implementing vec_cast()","title":"FAQ - How to implement ptype2 and cast methods? — howto-faq-coercion","text":"Corresponding vec_cast() methods must implemented vec_ptype2() methods. general pattern convert argument x type . methods validate values x make sure conform values . Please note historical reasons, order classes method name reverse order arguments function signature. first class represents , whereas second class represents x. self-self method easy case, just returns target input:   types need validated. perform input validation new_natural() constructor, ’s good fit vec_cast() implementations.   methods, vctrs now able combine logical natural vectors. properly returns richer type two, natural vector:   haven’t implemented conversions natural, still doesn’t know combine natural richer integer double types:   quick work completes implementation coercion methods vctrs:   now get expected combinations.","code":"#' @export vec_cast.my_natural.my_natural <- function(x, to, ...) {   x } #' @export vec_cast.my_natural.logical <- function(x, to, ...) {   # The order of the classes in the method name is in reverse order   # of the arguments in the function signature, so `to` is the natural   # number and `x` is the logical   new_natural(x) } vec_cast.my_natural.integer <- function(x, to, ...) {   new_natural(x) } vec_cast.my_natural.double <- function(x, to, ...) {   new_natural(x) } vec_c(TRUE, new_natural(1), FALSE) #> <natural> #> [1] 1 1 0 vec_c(new_natural(1), 10L) #> Error in `vec_c()`: #> ! Can't convert `..1` <my_natural> to <integer>. vec_c(1.5, new_natural(1)) #> Error in `vec_c()`: #> ! Can't convert `..2` <my_natural> to <double>. #' @export vec_cast.logical.my_natural <- function(x, to, ...) {   # In this case `to` is the logical and `x` is the natural number   attributes(x) <- NULL   as.logical(x) } #' @export vec_cast.integer.my_natural <- function(x, to, ...) {   attributes(x) <- NULL   as.integer(x) } #' @export vec_cast.double.my_natural <- function(x, to, ...) {   attributes(x) <- NULL   as.double(x) } vec_c(new_natural(1), 10L) #> [1]  1 10  vec_c(1.5, new_natural(1)) #> [1] 1.5 1.0"},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-fix-scalar-type-error.html","id":null,"dir":"Reference","previous_headings":"","what":"FAQ - Why isn't my class treated as a vector? — howto-faq-fix-scalar-type-error","title":"FAQ - Why isn't my class treated as a vector? — howto-faq-fix-scalar-type-error","text":"tidyverse bit stricter base R regarding kind objects considered vectors (see user FAQ topic). Sometimes vctrs won’t treat class vector .","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-fix-scalar-type-error.html","id":"why-isn-t-my-list-class-considered-a-vector-","dir":"Reference","previous_headings":"","what":"Why isn’t my list class considered a vector?","title":"FAQ - Why isn't my class treated as a vector? — howto-faq-fix-scalar-type-error","text":"default, S3 lists considered vectors vctrs:   treated vector, class must either inherit \"list\" explicitly:   implement vec_proxy() method returns input explicit inheritance possible troublesome:   Note explicit inheritance preferred way makes possible class dispatch list methods S3 generics:","code":"my_list <- structure(list(), class = \"my_class\")  vctrs::vec_is(my_list) #> [1] FALSE my_explicit_list <- structure(list(), class = c(\"my_class\", \"list\")) vctrs::vec_is(my_explicit_list) #> [1] TRUE #' @export vec_proxy.my_class <- function(x, ...) x  vctrs::vec_is(my_list) #> [1] FALSE my_generic <- function(x) UseMethod(\"my_generic\") my_generic.list <- function(x) \"dispatched!\"  my_generic(my_list) #> Error in UseMethod(\"my_generic\"): no applicable method for 'my_generic' applied to an object of class \"my_class\"  my_generic(my_explicit_list) #> [1] \"dispatched!\""},{"path":"https://vctrs.r-lib.org/dev/reference/howto-faq-fix-scalar-type-error.html","id":"why-isn-t-my-data-frame-class-considered-a-vector-","dir":"Reference","previous_headings":"","what":"Why isn’t my data frame class considered a vector?","title":"FAQ - Why isn't my class treated as a vector? — howto-faq-fix-scalar-type-error","text":"likely explanation data frame properly constructed. However, get “Input must vector” error data frame subclass, probably means data frame properly constructed. main cause errors data frames whose base class \"data.frame\":   problematic many tidyverse functions won’t work properly:   generally appropriate declare class superclass another class. generally consider undefined behaviour (UB). fix errors, can simply change construction data frame class \"data.frame\" base class, .e. come last class vector:","code":"my_df <- data.frame(x = 1) class(my_df) <- c(\"data.frame\", \"my_class\")  vctrs::obj_check_vector(my_df) #> Error: #> ! `my_df` must be a vector, not a <data.frame/my_class> object. dplyr::slice(my_df, 1) #> Error in `vec_slice()`: #> ! `x` must be a vector, not a <data.frame/my_class> object. class(my_df) <- c(\"my_class\", \"data.frame\")  vctrs::obj_check_vector(my_df)  dplyr::slice(my_df, 1) #>   x #> 1 1"},{"path":"https://vctrs.r-lib.org/dev/reference/int64.html","id":null,"dir":"Reference","previous_headings":"","what":"64 bit integers — vec_ptype_full.integer64","title":"64 bit integers — vec_ptype_full.integer64","text":"integer64 64 bits integer vector, implemented bit64 package.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/int64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"64 bit integers — vec_ptype_full.integer64","text":"","code":"# S3 method for class 'integer64' vec_ptype_full(x, ...)  # S3 method for class 'integer64' vec_ptype_abbr(x, ...)  # S3 method for class 'integer64' vec_ptype2(x, y, ...)  # S3 method for class 'integer64' vec_cast(x, to, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/int64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"64 bit integers — vec_ptype_full.integer64","text":"functions help integer64 class bit64 vctrs type system providing coercion functions casting functions.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/internal-faq-matches-algorithm.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal FAQ - Implementation of vec_locate_matches() — internal-faq-matches-algorithm","title":"Internal FAQ - Implementation of vec_locate_matches() — internal-faq-matches-algorithm","text":"vec_locate_matches() similar vec_match(), detects matches default, can match conditions equality (like >= <). also various arguments limit adjust exactly kinds matches returned. example:","code":"x <- c(\"a\", \"b\", \"a\", \"c\", \"d\") y <- c(\"d\", \"b\", \"a\", \"d\", \"a\", \"e\")  # For each value of `x`, find all matches in `y` # - The \"c\" in `x` doesn't have a match, so it gets an NA location by default # - The \"e\" in `y` isn't matched by anything in `x`, so it is dropped by default vec_locate_matches(x, y) #>   needles haystack #> 1       1        3 #> 2       1        5 #> 3       2        2 #> 4       3        3 #> 5       3        5 #> 6       4       NA #> 7       5        1 #> 8       5        4"},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/internal-faq-matches-algorithm.html","id":"overview-and-","dir":"Reference","previous_headings":"","what":"Overview and ==","title":"Internal FAQ - Implementation of vec_locate_matches() — internal-faq-matches-algorithm","text":"simplest (approximate) way think algorithm df_locate_matches_recurse() uses sorts inputs, starts midpoint needles uses binary search find needle haystack. Since might multiple needle, find location lower upper duplicate needle handle duplicates needle . Similarly, duplicates matching haystack value, find lower upper duplicates match. condition ==, pretty much . needle, record 3 things: location needle, location lower match haystack, match size (.e. loc_upper_match - loc_lower_match + 1). later gets expanded expand_compact_indices() actual output. recording matches single needle, perform procedure LHS RHS needle (remember started midpoint needle). .e. [1, loc_needle-1] [loc_needle+1, size_needles], taking midpoint two ranges, finding respective needle haystack, recording matches, continuing next needle. iteration proceeds run needles. data frame multiple columns, add layer recursion . first column, find locations lower/upper duplicate current needle, find locations lower/upper matches haystack. final column data frame, record matches, otherwise pass information another call df_locate_matches_recurse(), bumping column index using refined lower/upper bounds starting bounds next column. think example useful , step process iterations:   real code, rather comparing double values columns directly, replace column pseudo \"joint ranks\" computed -th column needles -th column haystack. approximately like vec_rank(vec_c(needles$x, haystack$x), type = \"dense\"), splitting resulting ranks back corresponding needle/haystack columns. keeps recursion code simpler, worry comparing integers.","code":"# these are sorted already for simplicity needles <- data_frame(x = c(1, 1, 2, 2, 2, 3), y = c(1, 2, 3, 4, 5, 3)) haystack <- data_frame(x = c(1, 1, 2, 2, 3), y = c(2, 3, 4, 4, 1))  needles #>   x y #> 1 1 1 #> 2 1 2 #> 3 2 3 #> 4 2 4 #> 5 2 5 #> 6 3 3  haystack #>   x y #> 1 1 2 #> 2 1 3 #> 3 2 4 #> 4 2 4 #> 5 3 1  ## Column 1, iteration 1  # start at midpoint in needles # this corresponds to x==2 loc_mid_needles <- 3L  # finding all x==2 values in needles gives us: loc_lower_duplicate_needles <- 3L loc_upper_duplicate_needles <- 5L  # finding matches in haystack give us: loc_lower_match_haystack <- 3L loc_upper_match_haystack <- 4L  # compute LHS/RHS bounds for next needle lhs_loc_lower_bound_needles <- 1L # original lower bound lhs_loc_upper_bound_needles <- 2L # lower_duplicate-1  rhs_loc_lower_bound_needles <- 6L # upper_duplicate+1 rhs_loc_upper_bound_needles <- 6L # original upper bound  # We still have a 2nd column to check. So recurse and pass on the current # duplicate and match bounds to start the 2nd column with.  ## Column 2, iteration 1  # midpoint of [3, 5] # value y==4 loc_mid_needles <- 4L  loc_lower_duplicate_needles <- 4L loc_upper_duplicate_needles <- 4L  loc_lower_match_haystack <- 3L loc_upper_match_haystack <- 4L  # last column, so record matches # - this was location 4 in needles # - lower match in haystack is at loc 3 # - match size is 2  # Now handle LHS and RHS of needle midpoint lhs_loc_lower_bound_needles <- 3L # original lower bound lhs_loc_upper_bound_needles <- 3L # lower_duplicate-1  rhs_loc_lower_bound_needles <- 5L # upper_duplicate+1 rhs_loc_upper_bound_needles <- 5L # original upper bound  ## Column 2, iteration 2 (using LHS bounds)  # midpoint of [3,3] # value of y==3 loc_mid_needles <- 3L  loc_lower_duplicate_needles <- 3L loc_upper_duplicate_needles <- 3L  # no match! no y==3 in haystack for x==2 # lower-match will always end up > upper-match in this case loc_lower_match_haystack <- 3L loc_upper_match_haystack <- 2L  # no LHS or RHS needle values to do, so we are done here  ## Column 2, iteration 3 (using RHS bounds)  # same as above, range of [5,5], value of y==5, which has no match in haystack  ## Column 1, iteration 2 (LHS of first x needle)  # Now we are done with the x needles from [3,5], so move on to the LHS and RHS # of that. Here we would do the LHS:  # midpoint of [1,2] loc_mid_needles <- 1L  # ...  ## Column 1, iteration 3 (RHS of first x needle)  # midpoint of [6,6] loc_mid_needles <- 6L  # ..."},{"path":"https://vctrs.r-lib.org/dev/reference/internal-faq-matches-algorithm.html","id":"non-equi-conditions-and-containers","dir":"Reference","previous_headings":"","what":"Non-equi conditions and containers","title":"Internal FAQ - Implementation of vec_locate_matches() — internal-faq-matches-algorithm","text":"point can talk non-equi conditions like < >=. general idea pretty simple, just builds algorithm. example, start x column needles/haystack :   used condition <=, everything : Midpoint needles location 3, value x==2 Find lower/upper duplicates needles, giving locations [3, 5] Find lower/upper exact match haystack, giving locations [3, 4] point, need \"adjust\" haystack match bounds account condition. Since haystack ordered, \"rule\" <= keep lower match location , extend upper match location upper bound, end [3, 5]. know can extend upper match location every haystack value exact match less needle. just record matches continue normally. approach really nice, exactly match needle haystack. compare needle every value haystack, take massive amount time. However, gets slightly complex data frames multiple columns. go back original needles haystack data frames apply condition <= column. another worked example, shows case \"rule\" falls apart second column.   read example, see rule work . problem haystack ordered (vec_order()s standards), column ordered independently others. Instead, column ordered within \"group\" created previous columns. Concretely, haystack ordered x column, look haystack$y , ordered (1 end). causes rule fail.   fix , need create haystack \"containers\" values within container totally ordered. haystack create 2 containers look like:   essentially computing_nesting_container_ids() . can actually see ids helper, compute_nesting_container_info():   idea needle, look haystack container find matches, aggregate matches end. df_locate_matches_with_containers() job iterating containers. Computing totally ordered containers can expensive, luckily happen often normal usage. == conditions, need containers (.e. equi join) 1 non-equi condition conditions , need containers (.e. rolling joins) Otherwise typical case need containers something like date >= lower, date <= upper. Even , computation cost generally scales number columns haystack compute containers (2), really slows around 4 columns , ever seen real life example .","code":"needles$x #> [1] 1 1 2 2 2 3  haystack$x #> [1] 1 1 2 2 3 needles #>   x y #> 1 1 1 #> 2 1 2 #> 3 2 3 #> 4 2 4 #> 5 2 5 #> 6 3 3  haystack #>   x y #> 1 1 2 #> 2 1 3 #> 3 2 4 #> 4 2 4 #> 5 3 1  # `condition = c(\"<=\", \"<=\")`  ## Column 1, iteration 1  # x == 2 loc_mid_needles <- 3L  loc_lower_duplicate_needles <- 3L loc_upper_duplicate_needles <- 5L  # finding exact matches in haystack give us: loc_lower_match_haystack <- 3L loc_upper_match_haystack <- 4L  # because haystack is ordered we know we can expand the upper bound automatically # to include everything past the match. i.e. needle of x==2 must be less than # the haystack value at loc 5, which we can check by seeing that it is x==3. loc_lower_match_haystack <- 3L loc_upper_match_haystack <- 5L  ## Column 2, iteration 1  # needles range of [3, 5] # y == 4 loc_mid_needles <- 4L  loc_lower_duplicate_needles <- 4L loc_upper_duplicate_needles <- 4L  # finding exact matches in haystack give us: loc_lower_match_haystack <- 3L loc_upper_match_haystack <- 4L  # lets try using our rule, which tells us we should be able to extend the upper # bound: loc_lower_match_haystack <- 3L loc_upper_match_haystack <- 5L  # but the haystack value of y at location 5 is y==1, which is not less than y==4 # in the needles! looks like our rule failed us. haystack #>   x y #> 1 1 2 #> 2 1 3 #> 3 2 4 #> 4 2 4 #> 5 3 1 haystack[1:4,] #> # A tibble: 4 × 2 #>       x     y #>   <dbl> <dbl> #> 1     1     2 #> 2     1     3 #> 3     2     4 #> 4     2     4  haystack[5,] #> # A tibble: 1 × 2 #>       x     y #>   <dbl> <dbl> #> 1     3     1 haystack2 <- haystack  # we really pass along the integer ranks, but in this case that is equivalent # to converting our double columns to integers haystack2$x <- as.integer(haystack2$x) haystack2$y <- as.integer(haystack2$y)  info <- compute_nesting_container_info(haystack2, condition = c(\"<=\", \"<=\"))  # the ids are in the second slot. # container ids break haystack into [1, 4] and [5, 5]. info[[2]] #> [1] 0 0 0 0 1"},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/internal-faq-ptype2-identity.html","id":"promotion-monoid","dir":"Reference","previous_headings":"","what":"Promotion monoid","title":"Internal FAQ - vec_ptype2(), NULL, and unspecified vectors — internal-faq-ptype2-identity","text":"Promotions (.e. automatic coercions) always transform inputs richer type avoid losing values precision. vec_ptype2() returns richer type two vectors, throws incompatible type error none two vector types include . example, richer type integer double latter double covers larger range values integer. vec_ptype2() monoid vectors, practical terms means well behaved operation reduction. Reduction important operation promotions richer type multiple elements computed. monoid, vec_ptype2() needs identity element, .e. value doesn’t change result reduction. vctrs two identity values, NULL unspecified vectors.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/internal-faq-ptype2-identity.html","id":"the-null-identity","dir":"Reference","previous_headings":"","what":"The NULL identity","title":"Internal FAQ - vec_ptype2(), NULL, and unspecified vectors — internal-faq-ptype2-identity","text":"identity element shouldn’t influence determination common type set vectors, NULL promoted type:   common type NULL NULL identity NULL:   way result vec_ptype2(NULL, NULL) influence subsequent promotions:","code":"vec_ptype2(NULL, \"\") #> character(0) vec_ptype2(1L, NULL) #> integer(0) vec_ptype2(NULL, NULL) #> NULL vec_ptype2(   vec_ptype2(NULL, NULL),   \"\" ) #> character(0)"},{"path":"https://vctrs.r-lib.org/dev/reference/internal-faq-ptype2-identity.html","id":"unspecified-vectors","dir":"Reference","previous_headings":"","what":"Unspecified vectors","title":"Internal FAQ - vec_ptype2(), NULL, and unspecified vectors — internal-faq-ptype2-identity","text":"vctrs coercion system, logical vectors missing values also automatically promoted type vector, just like NULL. call vectors unspecified. special coercion semantics unspecified vectors serve two purposes: makes possible assign vectors NA inside type vectors, even coercible logical:   can’t put NULL data frame, need identity element behaves like vector. Logical vectors NA seem natural fit . Unspecified vectors thus promoted type, just like NULL:","code":"x <- letters[1:5] vec_assign(x, 1:2, c(NA, NA)) #> [1] NA  NA  \"c\" \"d\" \"e\" vec_ptype2(NA, \"\") #> character(0) vec_ptype2(1L, c(NA, NA)) #> integer(0)"},{"path":"https://vctrs.r-lib.org/dev/reference/internal-faq-ptype2-identity.html","id":"finalising-common-types","dir":"Reference","previous_headings":"","what":"Finalising common types","title":"Internal FAQ - vec_ptype2(), NULL, and unspecified vectors — internal-faq-ptype2-identity","text":"vctrs internal vector type class vctrs_unspecified. Users normally don’t see vectors wild, come taking common type unspecified vector another identity value:   can’t return NA vec_ptype2() normally returns empty vectors. also can’t return NULL unspecified vectors need recognised logical vectors haven’t promoted end reduction.   See output vec_ptype_common() performs reduction finalises type, ready used caller:   Note partial types vctrs make use mechanism. finalised vec_ptype_finalise().","code":"vec_ptype2(NA, NA) #> <unspecified> [0] vec_ptype2(NA, NULL) #> <unspecified> [0] vec_ptype2(NULL, NA) #> <unspecified> [0] vec_ptype_finalise(vec_ptype2(NULL, NA)) #> logical(0) vec_ptype_common(NULL, NULL) #> NULL vec_ptype_common(NA, NULL) #> logical(0)"},{"path":"https://vctrs.r-lib.org/dev/reference/list_drop_empty.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop empty elements from a list — list_drop_empty","title":"Drop empty elements from a list — list_drop_empty","text":"list_drop_empty() removes empty elements list. includes NULL elements along empty vectors, like integer(0). equivalent , faster , vec_slice(x, list_sizes(x) != 0L).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/list_drop_empty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop empty elements from a list — list_drop_empty","text":"","code":"list_drop_empty(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/list_drop_empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop empty elements from a list — list_drop_empty","text":"x list.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/list_drop_empty.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Drop empty elements from a list — list_drop_empty","text":"vec_slice()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/list_drop_empty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Drop empty elements from a list — list_drop_empty","text":"","code":"x <- list(1, NULL, integer(), 2) list_drop_empty(x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>"},{"path":"https://vctrs.r-lib.org/dev/reference/list_of.html","id":null,"dir":"Reference","previous_headings":"","what":"list_of S3 class for homogenous lists — list_of","title":"list_of S3 class for homogenous lists — list_of","text":"list_of object list element type. Modifying list $, [, [[ preserves constraint coercing input items.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/list_of.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"list_of S3 class for homogenous lists — list_of","text":"","code":"list_of(..., .ptype = NULL)  as_list_of(x, ...)  is_list_of(x)  # S3 method for class 'vctrs_list_of' vec_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\")  # S3 method for class 'vctrs_list_of' vec_cast(x, to, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/list_of.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"list_of S3 class for homogenous lists — list_of","text":"... Vectors coerce. .ptype NULL, default, output type determined computing common type across elements .... Alternatively, can supply .ptype give output known type. getOption(\"vctrs.no_guessing\") TRUE must supply value: convenient way make production code demand fixed types. x as_list_of(), vector coerced list_of. y, Arguments vec_ptype2() vec_cast(). x_arg, y_arg Argument names x y. used error messages inform user locations incompatible types (see stop_incompatible_type()).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/list_of.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"list_of S3 class for homogenous lists — list_of","text":"Unlike regular lists, setting list element NULL using [[ remove .","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/list_of.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"list_of S3 class for homogenous lists — list_of","text":"","code":"x <- list_of(1:3, 5:6, 10:15) if (requireNamespace(\"tibble\", quietly = TRUE)) {   tibble::tibble(x = x) } #> # A tibble: 3 × 1 #>             x #>   <list<int>> #> 1         [3] #> 2         [2] #> 3         [6]  vec_c(list_of(1, 2), list_of(FALSE, TRUE)) #> <list_of<double>[4]> #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 0 #>  #> [[4]] #> [1] 1 #>"},{"path":"https://vctrs.r-lib.org/dev/reference/maybe_lossy_cast.html","id":null,"dir":"Reference","previous_headings":"","what":"Lossy cast error — maybe_lossy_cast","title":"Lossy cast error — maybe_lossy_cast","text":"default, lossy casts error. Use allow_lossy_cast() silence errors continue partial results. case lost values typically set NA lower value resolution, depending type cast. Lossy cast errors thrown maybe_lossy_cast(). Unlike functions prefixed stop_, maybe_lossy_cast() usually returns result. lossy cast detected, throws error, unless wrapped allow_lossy_cast(). case, returns result silently.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/maybe_lossy_cast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lossy cast error — maybe_lossy_cast","text":"","code":"maybe_lossy_cast(   result,   x,   to,   lossy = NULL,   locations = NULL,   ...,   loss_type = c(\"precision\", \"generality\"),   x_arg,   to_arg,   call = caller_env(),   details = NULL,   message = NULL,   class = NULL,   .deprecation = FALSE )"},{"path":"https://vctrs.r-lib.org/dev/reference/maybe_lossy_cast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lossy cast error — maybe_lossy_cast","text":"result result potentially lossy cast. x Vectors cast. Type cast . lossy logical vector indicating elements result lossy. Can also single TRUE, note locations picks locations vector default. case, supply location vector, possibly empty. locations optional integer vector giving locations x lost information. ..., class use fields creating subclass. loss_type kind lossy cast mentioned error messages. Can loss precision (instance double integer) loss generality (character factor). x_arg Argument name x, used error messages inform user locations incompatible types (see stop_incompatible_type()). to_arg Argument name used error messages inform user locations incompatible types (see stop_incompatible_type()). call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. details additional human readable details. message overriding message error. details message mutually exclusive, supplying error. .deprecation TRUE, error downgraded deprecation warning. useful transitioning class stricter conversion scheme. warning advises users wrap code allow_lossy_cast().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/missing.html","id":null,"dir":"Reference","previous_headings":"","what":"Missing values — missing","title":"Missing values — missing","text":"vec_detect_missing() returns logical vector size x. element x, returns TRUE element missing, FALSE otherwise. vec_any_missing() returns single TRUE FALSE depending whether x missing values.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/missing.html","id":"differences-with-is-na-","dir":"Reference","previous_headings":"","what":"Differences with is.na()","title":"Missing values — missing","text":"Data frame rows considered missing every element row missing. Similarly, record vector elements considered missing every field record missing. Put another way, rows missing values considered incomplete, rows missing values considered missing. List elements considered missing NULL.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/missing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Missing values — missing","text":"","code":"vec_detect_missing(x)  vec_any_missing(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/missing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Missing values — missing","text":"x vector","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/missing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Missing values — missing","text":"vec_detect_missing() returns logical vector size x. vec_any_missing() returns single TRUE FALSE.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/missing.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Missing values — missing","text":"vec_proxy_equal()","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/missing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Missing values — missing","text":"","code":"x <- c(1, 2, NA, 4, NA)  vec_detect_missing(x) #> [1] FALSE FALSE  TRUE FALSE  TRUE vec_any_missing(x) #> [1] TRUE  # Data frames are iterated over rowwise, and only report a row as missing # if every element of that row is missing. If a row is only partially # missing, it is said to be incomplete, but not missing. y <- c(\"a\", \"b\", NA, \"d\", \"e\") df <- data_frame(x = x, y = y)  df$missing <- vec_detect_missing(df) df$incomplete <- !vec_detect_complete(df) df #>    x    y missing incomplete #> 1  1    a   FALSE      FALSE #> 2  2    b   FALSE      FALSE #> 3 NA <NA>    TRUE       TRUE #> 4  4    d   FALSE      FALSE #> 5 NA    e   FALSE       TRUE"},{"path":"https://vctrs.r-lib.org/dev/reference/name_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Name specifications — name_spec","title":"Name specifications — name_spec","text":"name specification describes combine inner outer names. sort name combination arises concatenating vectors flattening lists. two possible cases: Named vector:   Unnamed vector:   r-lib tidyverse packages, cases errors default, behaviour works well every case. Instead, can provide name specification describes combine inner outer names inputs. Name specifications can refer : outer: external name recycled size input vector. inner: Either names input vector, sequence integer 1 size vector unnamed.","code":"vec_c(outer = c(inner1 = 1, inner2 = 2)) vec_c(outer = 1:2)"},{"path":"https://vctrs.r-lib.org/dev/reference/name_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name specifications — name_spec","text":"name_spec, .name_spec name specification combining inner outer names. relevant inputs passed name, inputs named, like outer = c(inner = 1), length greater 1: outer = 1:2. default, cases trigger error. can resolve error providing specification describes combine names indices inner vector name input. specification can : function two arguments. outer name passed string first argument, inner names positions passed second argument. anonymous function purrr-style formula. glue specification form \"{outer}_{inner}\". rlang::zap() object, case outer inner names ignored result unnamed. See name specification topic.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/name_spec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Name specifications — name_spec","text":"","code":"# By default, named inputs must be length 1: vec_c(name = 1)         # ok #> name  #>    1  try(vec_c(name = 1:3))  # bad #> Error in vec_c(name = 1:3) :  #>   Can't merge the outer name `name` with a vector of length > 1. #> Please supply a `.name_spec` specification.  # They also can't have internal names, even if scalar: try(vec_c(name = c(internal = 1)))  # bad #> Error in vec_c(name = c(internal = 1)) :  #>   Can't merge the outer name `name` with a named vector. #> Please supply a `.name_spec` specification.  # Pass a name specification to work around this. A specification # can be a glue string referring to `outer` and `inner`: vec_c(name = 1:3, other = 4:5, .name_spec = \"{outer}\") #>  name  name  name other other  #>     1     2     3     4     5  vec_c(name = 1:3, other = 4:5, .name_spec = \"{outer}_{inner}\") #>  name_1  name_2  name_3 other_1 other_2  #>       1       2       3       4       5   # They can also be functions: my_spec <- function(outer, inner) paste(outer, inner, sep = \"_\") vec_c(name = 1:3, other = 4:5, .name_spec = my_spec) #>  name_1  name_2  name_3 other_1 other_2  #>       1       2       3       4       5   # Or purrr-style formulas for anonymous functions: vec_c(name = 1:3, other = 4:5, .name_spec = ~ paste0(.x, .y)) #>  name1  name2  name3 other1 other2  #>      1      2      3      4      5"},{"path":"https://vctrs.r-lib.org/dev/reference/new_data_frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Assemble attributes for data frame construction — new_data_frame","title":"Assemble attributes for data frame construction — new_data_frame","text":"new_data_frame() constructs new data frame existing list. meant performant, check inputs correctness way. safe use call df_list(), collects validates columns used construct data frame.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_data_frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assemble attributes for data frame construction — new_data_frame","text":"","code":"new_data_frame(x = list(), n = NULL, ..., class = NULL)"},{"path":"https://vctrs.r-lib.org/dev/reference/new_data_frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assemble attributes for data frame construction — new_data_frame","text":"x named list equal-length vectors. lengths checked; responsibility caller make sure equal. n Number rows. NULL, computed length first element x. ..., class Additional arguments creating subclasses. following attributes special behavior: \"names\" preferred provided, overriding existing names x. \"row.names\" preferred provided, overriding n size implied x.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/new_data_frame.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assemble attributes for data frame construction — new_data_frame","text":"","code":"new_data_frame(list(x = 1:10, y = 10:1)) #>     x  y #> 1   1 10 #> 2   2  9 #> 3   3  8 #> 4   4  7 #> 5   5  6 #> 6   6  5 #> 7   7  4 #> 8   8  3 #> 9   9  2 #> 10 10  1"},{"path":"https://vctrs.r-lib.org/dev/reference/new_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Date, date-time, and duration S3 classes — new_date","title":"Date, date-time, and duration S3 classes — new_date","text":"date (Date) double vector. value represent number days since Unix \"epoch\", 1970-01-01. attributes. datetime (POSIXct double vector. value represents number seconds since Unix \"Epoch\", 1970-01-01. single attribute: timezone (tzone)) duration (difftime)","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Date, date-time, and duration S3 classes — new_date","text":"","code":"new_date(x = double())  new_datetime(x = double(), tzone = \"\")  new_duration(x = double(), units = c(\"secs\", \"mins\", \"hours\", \"days\", \"weeks\"))  # S3 method for class 'Date' vec_ptype2(x, y, ...)  # S3 method for class 'POSIXct' vec_ptype2(x, y, ...)  # S3 method for class 'POSIXlt' vec_ptype2(x, y, ...)  # S3 method for class 'difftime' vec_ptype2(x, y, ...)  # S3 method for class 'Date' vec_cast(x, to, ...)  # S3 method for class 'POSIXct' vec_cast(x, to, ...)  # S3 method for class 'POSIXlt' vec_cast(x, to, ...)  # S3 method for class 'difftime' vec_cast(x, to, ...)  # S3 method for class 'Date' vec_arith(op, x, y, ...)  # S3 method for class 'POSIXct' vec_arith(op, x, y, ...)  # S3 method for class 'POSIXlt' vec_arith(op, x, y, ...)  # S3 method for class 'difftime' vec_arith(op, x, y, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/new_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Date, date-time, and duration S3 classes — new_date","text":"x double vector representing number days since UNIX epoch new_date(), number seconds since UNIX epoch new_datetime(), number units new_duration(). tzone Time zone. character vector length 1. Either \"\" local time zone, value OlsonNames() units Units duration.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_date.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Date, date-time, and duration S3 classes — new_date","text":"function help base Date, POSIXct, difftime classes fit vctrs type system providing constructors, coercion functions, casting functions.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Date, date-time, and duration S3 classes — new_date","text":"","code":"new_date(0) #> [1] \"1970-01-01\" new_datetime(0, tzone = \"UTC\") #> [1] \"1970-01-01 UTC\" new_duration(1, \"hours\") #> Time difference of 1 hours"},{"path":"https://vctrs.r-lib.org/dev/reference/new_factor.html","id":null,"dir":"Reference","previous_headings":"","what":"Factor/ordered factor S3 class — new_factor","title":"Factor/ordered factor S3 class — new_factor","text":"factor integer attribute levels, character vector. one level integer 1 max(x). ordered factor properties factor, possesses extra class marks levels total ordering.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_factor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Factor/ordered factor S3 class — new_factor","text":"","code":"new_factor(x = integer(), levels = character(), ..., class = character())  new_ordered(x = integer(), levels = character())  # S3 method for class 'factor' vec_ptype2(x, y, ...)  # S3 method for class 'ordered' vec_ptype2(x, y, ...)  # S3 method for class 'factor' vec_cast(x, to, ...)  # S3 method for class 'ordered' vec_cast(x, to, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/new_factor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Factor/ordered factor S3 class — new_factor","text":"x Integer values index levels. levels Character vector labels. ..., class Used subclasses.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_factor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Factor/ordered factor S3 class — new_factor","text":"functions help base factor ordered factor classes fit vctrs type system providing constructors, coercion functions, casting functions. new_factor() new_ordered() low-level constructors - check types, values, valid, expert use .","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_list_of.html","id":null,"dir":"Reference","previous_headings":"","what":"Create list_of subclass — new_list_of","title":"Create list_of subclass — new_list_of","text":"Create list_of subclass","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_list_of.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create list_of subclass — new_list_of","text":"","code":"new_list_of(x = list(), ptype = logical(), ..., class = character())"},{"path":"https://vctrs.r-lib.org/dev/reference/new_list_of.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create list_of subclass — new_list_of","text":"x list ptype prototype every element x belongs ... Additional attributes used subclass class Optional subclass name","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_partial.html","id":null,"dir":"Reference","previous_headings":"","what":"Partial type — new_partial","title":"Partial type — new_partial","text":"Use new_partial() constructing new partial type subclass; use is_partial() test type partial. subclasses need provide vec_ptype_finalise() method.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_partial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partial type — new_partial","text":"","code":"new_partial(..., class = character())  is_partial(x)  vec_ptype_finalise(x, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/new_partial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partial type — new_partial","text":"... Attributes partial type class Name subclass.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_partial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Partial type — new_partial","text":"name suggests, partial type partially specifies type, must combined data yield full type. useful example partial type partial_frame(), makes possible specify type just columns data frame. Use constructor making partial type.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_rcrd.html","id":null,"dir":"Reference","previous_headings":"","what":"rcrd (record) S3 class — new_rcrd","title":"rcrd (record) S3 class — new_rcrd","text":"rcrd class extends vctr. rcrd composed 1 fields, must vectors length. designed specifically classes can naturally decomposed multiple vectors length, like POSIXlt, organisation considered implementation detail invisible user (unlike data.frame).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_rcrd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rcrd (record) S3 class — new_rcrd","text":"","code":"new_rcrd(fields, ..., class = character())"},{"path":"https://vctrs.r-lib.org/dev/reference/new_rcrd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rcrd (record) S3 class — new_rcrd","text":"fields list data frame. Lists must rectangular (sizes), contain uniquely named vectors (least one). fields validated df_list() ensure uniquely named vectors. ... Additional attributes class Name subclass.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_rcrd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"rcrd (record) S3 class — new_rcrd","text":"Record-style objects created new_rcrd() much . instance default format() method, means printing object causes error. See Record-style objects details implementing methods record vectors.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_vctr.html","id":null,"dir":"Reference","previous_headings":"","what":"vctr (vector) S3 class — new_vctr","title":"vctr (vector) S3 class — new_vctr","text":"abstract class provides set useful default methods makes considerably easier get started new S3 vector class. See vignette(\"s3-vector\") learn use create S3 vector classes.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_vctr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"vctr (vector) S3 class — new_vctr","text":"","code":"new_vctr(.data, ..., class = character(), inherit_base_type = NULL)"},{"path":"https://vctrs.r-lib.org/dev/reference/new_vctr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"vctr (vector) S3 class — new_vctr","text":".data Foundation class. Must vector ... Name-value pairs defining attributes class Name subclass. inherit_base_type single logical, NULL. class extend base type .data? .e. resulting object extend behaviour underlying type? Defaults FALSE types except lists, required inherit base type.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_vctr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"vctr (vector) S3 class — new_vctr","text":"List vctrs special cases. created new_vctr(), resulting list vctr always recognized list obj_is_list(). , inherit_base_type FALSE error thrown.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/new_vctr.html","id":"base-methods","dir":"Reference","previous_headings":"","what":"Base methods","title":"vctr (vector) S3 class — new_vctr","text":"vctr class provides methods many base generics using smaller set generics defined package. Generally, think carefully overriding methods vctrs implements carefully planned internally consistent. [[ [ use NextMethod() dispatch underlying base function, restore attributes vec_restore(). rep() length<- work similarly. [[<- [<- cast value type x, call NextMethod(). .logical(), .integer(), .numeric(), .character(), .Date() .POSIXct() methods call vec_cast(). .list() method calls [[ repeatedly, .data.frame() method uses standard technique wrap vector data frame. .factor(), .ordered() .difftime() generic functions base R, reimplemented generics generics package. vctrs extends calls vec_cast(). inherit behaviour package, import re-export generic interest generics. ==, !=, unique(), anyDuplicated(), .na() use vec_proxy(). <, <=, >=, >, min(), max(), range(), median(), quantile(), xtfrm() methods use vec_proxy_compare(). +, -, /, *, ^, %%, %/%, !, &, | operators use vec_arith(). Mathematical operations including Summary group generics (prod(), sum(), (), ()), Math group generics (abs(), sign(), etc), mean(), .nan(), .finite(), .infinite() use vec_math(). dims(), dims<-, dimnames(), dimnames<-, levels(), levels<- methods throw errors.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/obj_is_list.html","id":null,"dir":"Reference","previous_headings":"","what":"List checks — obj_is_list","title":"List checks — obj_is_list","text":"obj_is_list() tests x considered list vctrs sense. returns TRUE : x bare list class. x list explicitly inheriting \"list\". list_all_vectors() takes list returns TRUE elements list vectors. list_all_size() takes list returns TRUE elements list size. obj_check_list(), list_check_all_vectors(), list_check_all_size() use functions, throw standardized informative error return FALSE.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/obj_is_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List checks — obj_is_list","text":"","code":"obj_is_list(x)  obj_check_list(x, ..., arg = caller_arg(x), call = caller_env())  list_all_vectors(x)  list_check_all_vectors(x, ..., arg = caller_arg(x), call = caller_env())  list_all_size(x, size)  list_check_all_size(x, size, ..., arg = caller_arg(x), call = caller_env())"},{"path":"https://vctrs.r-lib.org/dev/reference/obj_is_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List checks — obj_is_list","text":"x vec_*() functions, object. list_*() functions, list. ... dots future extensions must empty. arg argument name string. argument mentioned error messages input origin problem. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. size size check element .","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/obj_is_list.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"List checks — obj_is_list","text":"Notably, data frames S3 record style classes like POSIXlt considered lists.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/obj_is_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List checks — obj_is_list","text":"","code":"obj_is_list(list()) #> [1] TRUE obj_is_list(list_of(1)) #> [1] TRUE obj_is_list(data.frame()) #> [1] FALSE  list_all_vectors(list(1, mtcars)) #> [1] TRUE list_all_vectors(list(1, environment())) #> [1] FALSE  list_all_size(list(1:2, 2:3), 2) #> [1] TRUE list_all_size(list(1:2, 2:4), 2) #> [1] FALSE  # `list_`-prefixed functions assume a list: try(list_all_vectors(environment())) #> Error in list_all_vectors(environment()) :  #>   `x` must be a list, not an environment."},{"path":"https://vctrs.r-lib.org/dev/reference/obj_print.html","id":null,"dir":"Reference","previous_headings":"","what":"print() and str() generics. — obj_print","title":"print() and str() generics. — obj_print","text":"constructed easily extensible since can override _header(), _data() _footer() components individually. default methods built top format().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/obj_print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"print() and str() generics. — obj_print","text":"","code":"obj_print(x, ...)  obj_print_header(x, ...)  obj_print_data(x, ...)  obj_print_footer(x, ...)  obj_str(x, ...)  obj_str_header(x, ...)  obj_str_data(x, ...)  obj_str_footer(x, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/obj_print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"print() and str() generics. — obj_print","text":"x vector ... Additional arguments passed methods. See print() str() commonly used options","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/op-empty-default.html","id":null,"dir":"Reference","previous_headings":"","what":"Default value for empty vectors — %0%","title":"Default value for empty vectors — %0%","text":"Use inline operator need provide default value empty (defined vec_is_empty()) vectors.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/op-empty-default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default value for empty vectors — %0%","text":"","code":"x %0% y"},{"path":"https://vctrs.r-lib.org/dev/reference/op-empty-default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default value for empty vectors — %0%","text":"x vector y Value use x empty. preserve type-stability, type x.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/op-empty-default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Default value for empty vectors — %0%","text":"","code":"1:10 %0% 5 #>  [1]  1  2  3  4  5  6  7  8  9 10 integer() %0% 5 #> [1] 5"},{"path":"https://vctrs.r-lib.org/dev/reference/order-radix.html","id":null,"dir":"Reference","previous_headings":"","what":"Order and sort vectors — order-radix","title":"Order and sort vectors — order-radix","text":"vec_order_radix() computes order x. data frames, order computed along rows computing order first column using subsequent columns break ties. vec_sort_radix() sorts x. equivalent vec_slice(x, vec_order_radix(x)).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/order-radix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Order and sort vectors — order-radix","text":"","code":"vec_order_radix(   x,   ...,   direction = \"asc\",   na_value = \"largest\",   nan_distinct = FALSE,   chr_proxy_collate = NULL )  vec_sort_radix(   x,   ...,   direction = \"asc\",   na_value = \"largest\",   nan_distinct = FALSE,   chr_proxy_collate = NULL )"},{"path":"https://vctrs.r-lib.org/dev/reference/order-radix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Order and sort vectors — order-radix","text":"x vector ... dots future extensions must empty. direction Direction sort . single \"asc\" \"desc\" ascending descending order respectively. data frames, length 1 ncol(x) character vector containing \"asc\" \"desc\", specifying direction column. na_value Ordering missing values. single \"largest\" \"smallest\" ordering missing values largest smallest values respectively. data frames, length 1 ncol(x) character vector containing \"largest\" \"smallest\", specifying missing values ordered within column. nan_distinct single logical specifying whether NaN considered distinct NA double complex vectors. TRUE, NaN always ordered NA non-missing numbers. chr_proxy_collate function generating alternate representation character vectors use collation, often used locale-aware ordering. NULL, transformation done. Otherwise, must function one argument. input contains character vector, passed function translated UTF-8. function return character vector length input. result sort expected C-locale, regardless encoding. data frames, chr_proxy_collate applied character columns. Common transformation functions include: tolower() case-insensitive ordering stringi::stri_sort_key() locale-aware ordering.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/order-radix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Order and sort vectors — order-radix","text":"vec_order_radix() integer vector size x. vec_sort_radix() vector size type x.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/order-radix.html","id":"differences-with-order-","dir":"Reference","previous_headings":"","what":"Differences with order()","title":"Order and sort vectors — order-radix","text":"Unlike na.last argument order() decides positions missing values irrespective decreasing argument, na_value argument vec_order_radix() interacts direction. missing values considered largest value, appear last ascending order, first descending order. Character vectors ordered C-locale. different base::order(), respects base::Sys.setlocale(). Sorting consistent locale can produce reproducible results different sessions platforms, however, results sorting C-locale can surprising. example, capital letters sort lower case letters. Sorting c(\"b\", \"C\", \"\") vec_sort_radix() return c(\"C\", \"\", \"b\"), base::order() return c(\"\", \"b\", \"C\") unless base::order(method = \"radix\") explicitly set, also uses C-locale. sorting C-locale can useful algorithmic efficiency, many real world uses can cause data analysis mistakes. balance trade-offs, can supply chr_proxy_collate function transform character vectors alternative representation orders C-locale less surprising way. example, providing base::tolower() transform order original vector case-insensitive manner. Locale-aware ordering can achieved providing stringi::stri_sort_key() transform, setting collation options appropriate locale. Character vectors always translated UTF-8 ordering, transform applied chr_proxy_collate. complex vectors, either real imaginary component NA NaN, entire observation considered missing.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/order-radix.html","id":"dependencies-of-vec-order-radix-","dir":"Reference","previous_headings":"","what":"Dependencies of vec_order_radix()","title":"Order and sort vectors — order-radix","text":"vec_proxy_order()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/order-radix.html","id":"dependencies-of-vec-sort-radix-","dir":"Reference","previous_headings":"","what":"Dependencies of vec_sort_radix()","title":"Order and sort vectors — order-radix","text":"vec_order_radix() vec_slice()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/order-radix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Order and sort vectors — order-radix","text":"","code":"if (FALSE) {  x <- round(sample(runif(5), 9, replace = TRUE), 3) x <- c(x, NA)  vec_order_radix(x) vec_sort_radix(x) vec_sort_radix(x, direction = \"desc\")  # Can also handle data frames df <- data.frame(g = sample(2, 10, replace = TRUE), x = x) vec_order_radix(df) vec_sort_radix(df) vec_sort_radix(df, direction = \"desc\")  # For data frames, `direction` and `na_value` are allowed to be vectors # with length equal to the number of columns in the data frame vec_sort_radix(   df,   direction = c(\"desc\", \"asc\"),   na_value = c(\"largest\", \"smallest\") )  # Character vectors are ordered in the C locale, which orders capital letters # below lowercase ones y <- c(\"B\", \"A\", \"a\") vec_sort_radix(y)  # To order in a case-insensitive manner, provide a `chr_proxy_collate` # function that transforms the strings to all lowercase vec_sort_radix(y, chr_proxy_collate = tolower)  }"},{"path":"https://vctrs.r-lib.org/dev/reference/partial_factor.html","id":null,"dir":"Reference","previous_headings":"","what":"Partially specify a factor — partial_factor","title":"Partially specify a factor — partial_factor","text":"special class can passed ptype order specify result factor contains least specified levels.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/partial_factor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partially specify a factor — partial_factor","text":"","code":"partial_factor(levels = character())"},{"path":"https://vctrs.r-lib.org/dev/reference/partial_factor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partially specify a factor — partial_factor","text":"levels Character vector labels.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/partial_factor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partially specify a factor — partial_factor","text":"","code":"pf <- partial_factor(levels = c(\"x\", \"y\")) pf #> partial_factor< #>   5ec15 {partial} #> >  vec_ptype_common(factor(\"v\"), factor(\"w\"), .ptype = pf) #> factor() #> Levels: v w x y"},{"path":"https://vctrs.r-lib.org/dev/reference/partial_frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Partially specify columns of a data frame — partial_frame","title":"Partially specify columns of a data frame — partial_frame","text":"special class can passed .ptype order specify types columns data frame.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/partial_frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partially specify columns of a data frame — partial_frame","text":"","code":"partial_frame(...)"},{"path":"https://vctrs.r-lib.org/dev/reference/partial_frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partially specify columns of a data frame — partial_frame","text":"... Attributes subclass","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/partial_frame.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partially specify columns of a data frame — partial_frame","text":"","code":"pf <- partial_frame(x = double()) pf #> partial_frame< #>   x: double {partial} #> >  vec_rbind(   data.frame(x = 1L, y = \"a\"),   data.frame(x = FALSE, z = 10),   .ptype = partial_frame(x = double(), a = character()) ) #>   x    y  z    a #> 1 1    a NA <NA> #> 2 0 <NA> 10 <NA>"},{"path":"https://vctrs.r-lib.org/dev/reference/reference-faq-compatibility.html","id":null,"dir":"Reference","previous_headings":"","what":"FAQ - Is my class compatible with vctrs? — reference-faq-compatibility","title":"FAQ - Is my class compatible with vctrs? — reference-faq-compatibility","text":"vctrs provides framework working vector classes generic way. However, implements several compatibility fallbacks base R methods. reference find vctrs tries compatible vector class, base methods need implement compatibility. ’re starting scratch, think ’ll find easier start using new_vctr() documented vignette(\"s3-vector\"). guide aimed developers existing vector classes.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/reference-faq-compatibility.html","id":"aggregate-operations-with-fallbacks","dir":"Reference","previous_headings":"","what":"Aggregate operations with fallbacks","title":"FAQ - Is my class compatible with vctrs? — reference-faq-compatibility","text":"vctrs operations based four primitive generics described next section. However many higher level operations. important ones implement fallbacks base generics maximum compatibility existing classes. vec_slice() falls back base [ generic vec_proxy() method implemented. way foreign classes implement vec_restore() can restore attributes based new subsetted contents. vec_c() vec_rbind() now fall back base::c() inputs common parent class c() method (self--self vec_ptype2() method). vctrs works hard make c() method success various situations (NULL NA inputs, even first input normally prevent dispatch method). main downside compared using vctrs primitives can’t combine vectors different classes since extensible mechanism coercion c(), less efficient cases.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/reference-faq-compatibility.html","id":"the-vctrs-primitives","dir":"Reference","previous_headings":"","what":"The vctrs primitives","title":"FAQ - Is my class compatible with vctrs? — reference-faq-compatibility","text":"functions vctrs aggregate operations: call vctrs functions call vctrs functions. dependencies vctrs functions listed Dependencies section documentation page. Take look vec_count() example. dependencies form tree whose leaves four vctrs primitives. diagram vec_count():","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/reference-faq-compatibility.html","id":"the-coercion-generics","dir":"Reference","previous_headings":"","what":"The coercion generics","title":"FAQ - Is my class compatible with vctrs? — reference-faq-compatibility","text":"coercion mechanism vctrs based two generics: vec_ptype2() vec_cast() See theory overview. Two objects class attributes always considered compatible ptype2 cast. attributes classes differ, throw incompatible type error. Coercion errors main source incompatibility vctrs. See howto guide need implement methods generics.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/reference-faq-compatibility.html","id":"the-proxy-and-restoration-generics","dir":"Reference","previous_headings":"","what":"The proxy and restoration generics","title":"FAQ - Is my class compatible with vctrs? — reference-faq-compatibility","text":"vec_proxy() vec_restore() generics essential vctrs mostly optional. vec_proxy() defaults identity function normally don’t need implement . proxy vector must one atomic vector types, list, data frame. default, S3 lists inherit \"list\" identity proxy. case, need explicitly implement vec_proxy() make class inherit list.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/runs.html","id":null,"dir":"Reference","previous_headings":"","what":"Runs — runs","title":"Runs — runs","text":"vec_identify_runs() returns vector identifiers elements x indicate run repeated values fall . number runs also returned attribute, n. vec_run_sizes() returns integer vector corresponding size run. identical times column vec_unrep(), faster need run keys. vec_unrep() generalized base::rle(). documented alongside \"repeat\" functions vec_rep() vec_rep_each(); look information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/runs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Runs — runs","text":"","code":"vec_identify_runs(x)  vec_run_sizes(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/runs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Runs — runs","text":"x vector.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/runs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Runs — runs","text":"vec_identify_runs(), integer vector size x. scalar integer attribute, n, attached. vec_run_sizes(), integer vector size equal number runs x.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/runs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Runs — runs","text":"Unlike base::rle(), adjacent missing values considered identical constructing runs. example, vec_identify_runs(c(NA, NA)) return c(1, 1), c(1, 2).","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/runs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Runs — runs","text":"","code":"x <- c(\"a\", \"z\", \"z\", \"c\", \"a\", \"a\")  vec_identify_runs(x) #> [1] 1 2 2 3 4 4 #> attr(,\"n\") #> [1] 4 vec_run_sizes(x) #> [1] 1 2 1 2 vec_unrep(x) #>   key times #> 1   a     1 #> 2   z     2 #> 3   c     1 #> 4   a     2  y <- c(1, 1, 1, 2, 2, 3)  # With multiple columns, the runs are constructed rowwise df <- data_frame(   x = x,   y = y )  vec_identify_runs(df) #> [1] 1 2 2 3 4 5 #> attr(,\"n\") #> [1] 5 vec_run_sizes(df) #> [1] 1 2 1 1 1 vec_unrep(df) #>   key.x key.y times #> 1     a     1     1 #> 2     z     1     2 #> 3     c     2     1 #> 4     a     2     1 #> 5     a     3     1"},{"path":"https://vctrs.r-lib.org/dev/reference/s3_register.html","id":null,"dir":"Reference","previous_headings":"","what":"Register a method for a suggested dependency — s3_register","title":"Register a method for a suggested dependency — s3_register","text":"Generally, recommend way register S3 method use S3Method() namespace directive (often generated automatically @export roxygen2 tag). However, technique requires generic imported package, sometimes want suggest package, provide method package loaded. s3_register() can called package's .onLoad() dynamically register method generic's package loaded.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/s3_register.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register a method for a suggested dependency — s3_register","text":"generic Name generic form pkg::generic. class Name class method Optionally, implementation method. default, found looking function called generic.class package environment. Note providing method can dangerous use devtools. namespace method reloaded devtools::load_all(), function keep inheriting old namespace. might cause crashes dangling .Call() pointers.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/s3_register.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Register a method for a suggested dependency — s3_register","text":"R 3.5.0 later, s3_register() also useful demonstrating class creation vignette, since method lookup longer always involves lexical scope. R 3.6.0 later, can achieve similar effect using \"delayed method registration\", .e. placing following NAMESPACE file:","code":"if (getRversion() >= \"3.6.0\") {   S3method(package::generic, class) }"},{"path":"https://vctrs.r-lib.org/dev/reference/s3_register.html","id":"usage-in-other-packages","dir":"Reference","previous_headings":"","what":"Usage in other packages","title":"Register a method for a suggested dependency — s3_register","text":"avoid taking dependency vctrs, copy source s3_register() package. licensed permissive unlicense make crystal clear happy . need include license even credit us using function.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/s3_register.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Register a method for a suggested dependency — s3_register","text":"","code":"# A typical use case is to dynamically register tibble/pillar methods # for your class. That way you avoid creating a hard dependency on packages # that are not essential, while still providing finer control over # printing when they are used.  .onLoad <- function(...) {   s3_register(\"pillar::pillar_shaft\", \"vctrs_vctr\")   s3_register(\"tibble::type_sum\", \"vctrs_vctr\") }"},{"path":"https://vctrs.r-lib.org/dev/reference/table.html","id":null,"dir":"Reference","previous_headings":"","what":"Table S3 class — table","title":"Table S3 class — table","text":"functions help base table class fit vctrs type system providing coercion casting functions.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":null,"dir":"Reference","previous_headings":"","what":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"overview usage vec_ptype2() vec_cast() role vctrs coercion mechanism. Related topics: example implementing coercion methods simple vectors, see ?howto-faq-coercion. example implementing coercion methods data frame subclasses, see ?howto-faq-coercion-data-frame. tutorial implementing vctrs classes scratch, see vignette(\"s3-vector\").","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":"combination-mechanism-in-vctrs","dir":"Reference","previous_headings":"","what":"Combination mechanism in vctrs","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"coercion system vctrs designed make combination multiple inputs consistent extensible. Combinations occur many places, row-binding, joins, subset-assignment, grouped summary functions use split-apply-combine strategy. example:   One major goal vctrs provide central place implementing coercion methods make generic combinations possible. two relevant generics vec_ptype2() vec_cast(). take two arguments perform double dispatch, meaning method selected based classes inputs. general mechanism combining multiple inputs : Find common type set inputs reducing (base::Reduce() purrr::reduce()) vec_ptype2() binary function set. Convert inputs common type vec_cast(). Initialise output vector instance common type vec_init(). Fill output vector elements inputs using vec_assign(). last two steps may require vec_proxy() vec_restore() implementations, unless attributes class constant depend contents vector. focus first two steps, require vec_ptype2() vec_cast() implementations.","code":"vec_c(TRUE, 1) #> [1] 1 1  vec_c(\"a\", 1) #> Error in `vec_c()`: #> ! Can't combine `..1` <character> and `..2` <double>.  vec_rbind(   data.frame(x = TRUE),   data.frame(x = 1, y = 2) ) #>   x  y #> 1 1 NA #> 2 1  2  vec_rbind(   data.frame(x = \"a\"),   data.frame(x = 1, y = 2) ) #> Error in `vec_rbind()`: #> ! Can't combine `..1$x` <character> and `..2$x` <double>."},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":"vec-ptype-","dir":"Reference","previous_headings":"","what":"vec_ptype2()","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"Methods vec_ptype2() passed two prototypes, .e. two inputs emptied elements. implement two behaviours: types inputs compatible, indicate richer type returning . types equal resolution, return two. Throw error stop_incompatible_type() can determined attributes types inputs compatible.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":"type-compatibility","dir":"Reference","previous_headings":"","what":"Type compatibility","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"type compatible another type values represents subset superset values type. notion “value” interpreted high level, particular memory representation. example, factors represented memory integers values related character vectors round numbers:","code":"# Two factors are compatible vec_ptype2(factor(\"a\"), factor(\"b\")) #> factor() #> Levels: a b  # Factors are compatible with a character vec_ptype2(factor(\"a\"), \"b\") #> character(0)  # But they are incompatible with integers vec_ptype2(factor(\"a\"), 1L) #> Error: #> ! Can't combine `factor(\"a\")` <factor<4d52a>> and `1L` <integer>."},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":"richness-of-type","dir":"Reference","previous_headings":"","what":"Richness of type","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"Richness type precise notion. can richer data (instance double vector covers values integer vector), richer behaviour (data.table richer behaviour data.frame), . trouble determining one two types richer, probably means shouldn’t automatically coercible. Let’s look happens combine factor character:   ptype2 method <character> <factor<\"\">> returns <character> former richer type. factor can contain \"\" strings, whereas character can contain strings. sense, factors subset character. Note another valid behaviour throw incompatible type error. strict factor implementation . decided laxer vctrs easy inadvertently create factors instead character vectors, especially older versions R stringsAsFactors still true default.","code":"vec_ptype2(factor(\"a\"), \"b\") #> character(0)"},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":"consistency-and-symmetry-on-permutation","dir":"Reference","previous_headings":"","what":"Consistency and symmetry on permutation","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"ptype2 method strive exactly behaviour inputs permuted. always possible, example factor levels aggregated order:   case, permuting input return fundamentally different type introduce incompatible type error.","code":"vec_ptype2(factor(c(\"a\", \"c\")), factor(\"b\")) #> factor() #> Levels: a c b  vec_ptype2(factor(\"b\"), factor(c(\"a\", \"c\"))) #> factor() #> Levels: b a c"},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":"coercion-hierarchy","dir":"Reference","previous_headings":"","what":"Coercion hierarchy","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"classes can coerce together form coercion (subtyping) hierarchy. schema hierarchy base types like integer factor. diagram directions arrows express type richer. flow bottom (constrained types) top (richer types).  coercion hierarchy distinct structural hierarchy implied memory types classes. instance, structural hierarchy, factors built top integers. coercion hierarchy related character vectors. Similarly, subclasses necessarily coercible superclasses coercion structural hierarchies separate.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":"implementing-a-coercion-hierarchy","dir":"Reference","previous_headings":"","what":"Implementing a coercion hierarchy","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"class implementor, two options. simplest create entirely separate hierarchy. date date-time classes example S3-based hierarchy completely separate. Alternatively, can integrate class existing hierarchy, typically adding parent nodes top hierarchy (class richer), adding children node root hierarchy (class constrained), inserting node tree. coercion hierarchies implicit, sense implied vec_ptype2() implementations. structured way create modify hierarchy, instead need implement appropriate coercion methods types hierarchy, diligently return richer type case. vec_ptype2() implementations transitive inherited, pairwise methods classes lying given path must implemented manually. something might make easier future.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":"vec-cast-","dir":"Reference","previous_headings":"","what":"vec_cast()","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"second generic, vec_cast(), one looks data actually performs conversion. access information vec_ptype2(), may stricter cause error cases. vec_cast() three possible behaviours: Determine prototypes two inputs compatible. must decided exactly way vec_ptype2(). Call stop_incompatible_cast() can determine attributes types compatible. Detect incompatible values. Usually target type restricted values supported input type. example, fractional number can’t converted integer. method throw error case. Return input vector converted target type values compatible. Whereas vec_ptype2() must return type inputs permuted, vec_cast() directional. always returns type right-hand side, dies trying.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":"double-dispatch","dir":"Reference","previous_headings":"","what":"Double dispatch","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"dispatch mechanism vec_ptype2() vec_cast() looks like S3 actually custom mechanism. Compared S3, following differences: dispatches classes first two inputs. inheritance ptype2 cast methods. S3 class hierarchy necessarily coercion hierarchy. NextMethod() work. Parent methods must called explicitly necessary. default method hard-coded.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":"data-frames","dir":"Reference","previous_headings":"","what":"Data frames","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"determination common type data frames vec_ptype2() happens three steps: Match columns two input data frames. columns don’t exist, created filled adequately typed NA values. Find common type column calling vec_ptype2() pair matched columns. Find common data frame type. example common type grouped tibble tibble grouped tibble latter richer type. common type data table data frame data table. vec_cast() operates similarly. data frame cast target type fewer columns, error. implementing coercion methods data frames, need explicitly call parent methods perform common type determination type conversion described . exported df_ptype2() df_cast().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-coercion.html","id":"data-frame-fallbacks","dir":"Reference","previous_headings":"","what":"Data frame fallbacks","title":"FAQ - How does coercion work in vctrs? — theory-faq-coercion","text":"strict data frame combinations cause much pain many data frame subclasses wild don’t implement vctrs methods. decided implement special fallback behaviour foreign data frames. Incompatible data frames fall back base data frame:   tibble involved, fall back tibble:   fallbacks ideal make sense data frames share common data structure. generally case vectors. example factors characters different representations, possible find fallback time mechanically. However fallback big downside: implementing vctrs methods data frame subclass breaking behaviour change. proper coercion behaviour data frame class specified soon possible limit consequences changing behaviour class R scripts.","code":"df1 <- data.frame(x = 1) df2 <- structure(df1, class = c(\"foreign_df\", \"data.frame\"))  vec_rbind(df1, df2) #>   x #> 1 1 #> 2 1 df3 <- tibble::as_tibble(df1)  vec_rbind(df1, df3) #> # A tibble: 2 x 1 #>       x #>   <dbl> #> 1     1 #> 2     1"},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-recycling.html","id":null,"dir":"Reference","previous_headings":"","what":"FAQ - How does recycling work in vctrs and the tidyverse? — theory-faq-recycling","title":"FAQ - How does recycling work in vctrs and the tidyverse? — theory-faq-recycling","text":"Recycling describes concept repeating elements one vector match size another. two rules underlie “tidyverse” recycling rules: Vectors size 1 recycled size vector Otherwise, vectors must size","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-recycling.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"FAQ - How does recycling work in vctrs and the tidyverse? — theory-faq-recycling","text":"Vectors size 1 recycled size vector:   includes vectors size 0:   vectors aren’t size 1, must size. Otherwise, error thrown:","code":"tibble(x = 1:3, y = 1L) #> # A tibble: 3 x 2 #>       x     y #>   <int> <int> #> 1     1     1 #> 2     2     1 #> 3     3     1 tibble(x = integer(), y = 1L) #> # A tibble: 0 x 2 #> # i 2 variables: x <int>, y <int> tibble(x = 1:3, y = 4:7) #> Error in `tibble()`: #> ! Tibble columns must have compatible sizes. #> * Size 3: Existing data. #> * Size 4: Column `y`. #> i Only values of size one are recycled."},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-recycling.html","id":"vctrs-backend","dir":"Reference","previous_headings":"","what":"vctrs backend","title":"FAQ - How does recycling work in vctrs and the tidyverse? — theory-faq-recycling","text":"Packages r-lib tidyverse generally use vec_size_common() vec_recycle_common() backends handling recycling rules. vec_size_common() returns common size multiple vectors, applying recycling rules vec_recycle_common() goes one step , actually recycles vectors common size","code":"vec_size_common(1:3, \"x\") #> [1] 3  vec_recycle_common(1:3, \"x\") #> [[1]] #> [1] 1 2 3 #> #> [[2]] #> [1] \"x\" \"x\" \"x\"  vec_size_common(1:3, c(\"x\", \"y\")) #> Error: #> ! Can't recycle `..1` (size 3) to match `..2` (size 2)."},{"path":"https://vctrs.r-lib.org/dev/reference/theory-faq-recycling.html","id":"base-r-recycling-rules","dir":"Reference","previous_headings":"","what":"Base R recycling rules","title":"FAQ - How does recycling work in vctrs and the tidyverse? — theory-faq-recycling","text":"recycling rules described stricter ones generally used base R, : vector length 0, output length 0 Otherwise, output length max(length_x, length_y), warning thrown length longer vector integer multiple length shorter vector. explore base R rules detail vignette(\"type-size\").","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/unspecified.html","id":null,"dir":"Reference","previous_headings":"","what":"A 1d vector of unspecified type — unspecified","title":"A 1d vector of unspecified type — unspecified","text":"partial type used represent logical vectors contain NA. require special handling want allow NA specify missingness without requiring type.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/unspecified.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A 1d vector of unspecified type — unspecified","text":"","code":"unspecified(n = 0)"},{"path":"https://vctrs.r-lib.org/dev/reference/unspecified.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A 1d vector of unspecified type — unspecified","text":"n Length vector","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/unspecified.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A 1d vector of unspecified type — unspecified","text":"","code":"vec_ptype_show() #> Prototype: NULL vec_ptype_show(NA) #> Prototype: logical  vec_c(NA, factor(\"x\")) #> [1] <NA> x    #> Levels: x vec_c(NA, Sys.Date()) #> [1] NA           \"2025-08-27\" vec_c(NA, Sys.time()) #> [1] NA                        \"2025-08-27 16:38:29 UTC\" vec_c(NA, list(1:3, 4:5)) #> [[1]] #> NULL #>  #> [[2]] #> [1] 1 2 3 #>  #> [[3]] #> [1] 4 5 #>"},{"path":"https://vctrs.r-lib.org/dev/reference/vctrs-conditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom conditions for vctrs package — vctrs-conditions","title":"Custom conditions for vctrs package — vctrs-conditions","text":"functions called side effect raising errors warnings. conditions custom classes structures make testing easier.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vctrs-conditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom conditions for vctrs package — vctrs-conditions","text":"","code":"stop_incompatible_type(   x,   y,   ...,   x_arg,   y_arg,   action = c(\"combine\", \"convert\"),   details = NULL,   message = NULL,   class = NULL,   call = caller_env() )  stop_incompatible_cast(   x,   to,   ...,   x_arg,   to_arg,   details = NULL,   message = NULL,   class = NULL,   call = caller_env() )  stop_incompatible_op(   op,   x,   y,   details = NULL,   ...,   message = NULL,   class = NULL,   call = caller_env() )  stop_incompatible_size(   x,   y,   x_size,   y_size,   ...,   x_arg,   y_arg,   details = NULL,   message = NULL,   class = NULL,   call = caller_env() )  allow_lossy_cast(expr, x_ptype = NULL, to_ptype = NULL)"},{"path":"https://vctrs.r-lib.org/dev/reference/vctrs-conditions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Custom conditions for vctrs package — vctrs-conditions","text":"x, y, Vectors ..., class use fields creating subclass. x_arg, y_arg, to_arg Argument names x, y, . Used error messages inform user locations incompatible types. action option customize incompatible type message depending context. Errors thrown vec_ptype2() use \"combine\" thrown vec_cast() use \"convert\". details additional human readable details. message overriding message error. details message mutually exclusive, supplying error. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. x_ptype, to_ptype Suppress casting errors x match prototypes.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vctrs-conditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Custom conditions for vctrs package — vctrs-conditions","text":"stop_incompatible_*() unconditionally raise error class \"vctrs_error_incompatible_*\" \"vctrs_error_incompatible\".","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vctrs-conditions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Custom conditions for vctrs package — vctrs-conditions","text":"","code":"# Most of the time, `maybe_lossy_cast()` returns its input normally: maybe_lossy_cast(   c(\"foo\", \"bar\"),   NA,   \"\",   lossy = c(FALSE, FALSE),   x_arg = \"\",   to_arg = \"\" ) #> [1] \"foo\" \"bar\"  # If `lossy` has any `TRUE`, an error is thrown: try(maybe_lossy_cast(   c(\"foo\", \"bar\"),   NA,   \"\",   lossy = c(FALSE, TRUE),   x_arg = \"\",   to_arg = \"\" )) #> Error in eval(expr, envir) :  #>   Can't convert from <logical> to <character> due to loss of precision. #> • Locations: 2  # Unless lossy casts are allowed: allow_lossy_cast(   maybe_lossy_cast(     c(\"foo\", \"bar\"),     NA,     \"\",     lossy = c(FALSE, TRUE),     x_arg = \"\",     to_arg = \"\"   ) ) #> [1] \"foo\" \"bar\""},{"path":"https://vctrs.r-lib.org/dev/reference/vctrs-data-frame.html","id":null,"dir":"Reference","previous_headings":"","what":"vctrs methods for data frames — vctrs-data-frame","title":"vctrs methods for data frames — vctrs-data-frame","text":"functions help base data.frame class fit vctrs type system providing coercion casting functions.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vctrs-data-frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"vctrs methods for data frames — vctrs-data-frame","text":"","code":"# S3 method for class 'data.frame' vec_ptype2(x, y, ...)  # S3 method for class 'data.frame' vec_cast(x, to, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/vctrs-package.html","id":null,"dir":"Reference","previous_headings":"","what":"vctrs: Vector Helpers — vctrs-package","title":"vctrs: Vector Helpers — vctrs-package","text":"Defines new notions prototype size used provide tools consistent well-founded type-coercion size-recycling, turn connected ideas type- size-stability useful analysing function interfaces.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vctrs-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"vctrs: Vector Helpers — vctrs-package","text":"Maintainer: Davis Vaughan davis@posit.co Authors: Hadley Wickham hadley@posit.co Lionel Henry lionel@posit.co contributors: data.table team (Radix sort based data.table's forder() contribution R's order()) [copyright holder] Posit Software, PBC [copyright holder, funder]","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-rep.html","id":null,"dir":"Reference","previous_headings":"","what":"Repeat a vector — vec-rep","title":"Repeat a vector — vec-rep","text":"vec_rep() repeats entire vector set number times. vec_rep_each() repeats element vector set number times. vec_unrep() compresses vector repeated values. repeated values returned key alongside number times key repeated.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-rep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Repeat a vector — vec-rep","text":"","code":"vec_rep(   x,   times,   ...,   error_call = current_env(),   x_arg = \"x\",   times_arg = \"times\" )  vec_rep_each(   x,   times,   ...,   error_call = current_env(),   x_arg = \"x\",   times_arg = \"times\" )  vec_unrep(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec-rep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Repeat a vector — vec-rep","text":"x vector. times vec_rep(), single integer number times repeat entire vector. vec_rep_each(), integer vector number times repeat element x. times recycled size x. ... dots future extensions must empty. error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. x_arg, times_arg Argument names errors.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-rep.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Repeat a vector — vec-rep","text":"vec_rep(), vector type x size vec_size(x) * times. vec_rep_each(), vector type x size sum(vec_recycle(times, vec_size(x))). vec_unrep(), data frame two columns, key times. key vector type x, times integer vector.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-rep.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Repeat a vector — vec-rep","text":"Using vec_unrep() vec_rep_each() together similar using base::rle() base::inverse.rle(). following invariant shows relationship two functions:   two main differences vec_unrep() base::rle(): vec_unrep() treats adjacent missing values equivalent, rle() treats different values. vec_unrep() works along size x, rle() works along length. means vec_unrep() works data frames compressing repeated rows.","code":"compressed <- vec_unrep(x) identical(x, vec_rep_each(compressed$key, compressed$times))"},{"path":"https://vctrs.r-lib.org/dev/reference/vec-rep.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Repeat a vector — vec-rep","text":"vec_slice()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-rep.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Repeat a vector — vec-rep","text":"","code":"# Repeat the entire vector vec_rep(1:2, 3) #> [1] 1 2 1 2 1 2  # Repeat within each vector vec_rep_each(1:2, 3) #> [1] 1 1 1 2 2 2 x <- vec_rep_each(1:2, c(3, 4)) x #> [1] 1 1 1 2 2 2 2  # After using `vec_rep_each()`, you can recover the original vector # with `vec_unrep()` vec_unrep(x) #>   key times #> 1   1     3 #> 2   2     4  df <- data.frame(x = 1:2, y = 3:4)  # `rep()` repeats columns of data frames, and returns lists rep(df, each = 2) #> $x #> [1] 1 2 #>  #> $x #> [1] 1 2 #>  #> $y #> [1] 3 4 #>  #> $y #> [1] 3 4 #>   # `vec_rep()` and `vec_rep_each()` repeat rows, and return data frames vec_rep(df, 2) #>   x y #> 1 1 3 #> 2 2 4 #> 3 1 3 #> 4 2 4 vec_rep_each(df, 2) #>   x y #> 1 1 3 #> 2 1 3 #> 3 2 4 #> 4 2 4  # `rle()` treats adjacent missing values as different y <- c(1, NA, NA, 2) rle(y) #> Run Length Encoding #>   lengths: int [1:4] 1 1 1 1 #>   values : num [1:4] 1 NA NA 2  # `vec_unrep()` treats them as equivalent vec_unrep(y) #>   key times #> 1   1     1 #> 2  NA     2 #> 3   2     1"},{"path":"https://vctrs.r-lib.org/dev/reference/vec-set.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — vec-set","title":"Set operations — vec-set","text":"vec_set_intersect() returns values x y. vec_set_difference() returns values x y. Note asymmetric set difference, meaning commutative. vec_set_union() returns values either x y. vec_set_symmetric_difference() returns values either x y . commutative difference. set operations, functions return unique values x y, returned order first appeared original input. Names x y retained result, names always taken x value appears inputs. functions work similarly intersect(), setdiff(), union(), strip attributes can used data frames.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — vec-set","text":"","code":"vec_set_intersect(   x,   y,   ...,   ptype = NULL,   x_arg = \"x\",   y_arg = \"y\",   error_call = current_env() )  vec_set_difference(   x,   y,   ...,   ptype = NULL,   x_arg = \"x\",   y_arg = \"y\",   error_call = current_env() )  vec_set_union(   x,   y,   ...,   ptype = NULL,   x_arg = \"x\",   y_arg = \"y\",   error_call = current_env() )  vec_set_symmetric_difference(   x,   y,   ...,   ptype = NULL,   x_arg = \"x\",   y_arg = \"y\",   error_call = current_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec-set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — vec-set","text":"x, y pair vectors. ... dots future extensions must empty. ptype NULL, default, output type determined computing common type x y. supplied, x y cast type. x_arg, y_arg Argument names x y. used error messages. error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — vec-set","text":"vector common type x y (ptype, supplied) containing result corresponding set function.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set operations — vec-set","text":"Missing values treated equal missing values. doubles complexes, NaN equal NaN, NA.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec-set.html","id":"vec-set-intersect-","dir":"Reference","previous_headings":"","what":"vec_set_intersect()","title":"Set operations — vec-set","text":"vec_proxy_equal() vec_slice() vec_ptype2() vec_cast()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-set.html","id":"vec-set-difference-","dir":"Reference","previous_headings":"","what":"vec_set_difference()","title":"Set operations — vec-set","text":"vec_proxy_equal() vec_slice() vec_ptype2() vec_cast()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-set.html","id":"vec-set-union-","dir":"Reference","previous_headings":"","what":"vec_set_union()","title":"Set operations — vec-set","text":"vec_proxy_equal() vec_slice() vec_ptype2() vec_cast() vec_c()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-set.html","id":"vec-set-symmetric-difference-","dir":"Reference","previous_headings":"","what":"vec_set_symmetric_difference()","title":"Set operations — vec-set","text":"vec_proxy_equal() vec_slice() vec_ptype2() vec_cast() vec_c()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec-set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — vec-set","text":"","code":"x <- c(1, 2, 1, 4, 3) y <- c(2, 5, 5, 1)  # All unique values in both `x` and `y`. # Duplicates in `x` and `y` are always removed. vec_set_intersect(x, y) #> [1] 1 2  # All unique values in `x` but not `y` vec_set_difference(x, y) #> [1] 4 3  # All unique values in either `x` or `y` vec_set_union(x, y) #> [1] 1 2 4 3 5  # All unique values in either `x` or `y` but not both vec_set_symmetric_difference(x, y) #> [1] 4 3 5  # These functions can also be used with data frames x <- data_frame(   a = c(2, 3, 2, 2),   b = c(\"j\", \"k\", \"j\", \"l\") ) y <- data_frame(   a = c(1, 2, 2, 2, 3),   b = c(\"j\", \"l\", \"j\", \"l\", \"j\") )  vec_set_intersect(x, y) #>   a b #> 1 2 j #> 2 2 l vec_set_difference(x, y) #>   a b #> 1 3 k vec_set_union(x, y) #>   a b #> 1 2 j #> 2 3 k #> 3 2 l #> 4 1 j #> 5 3 j vec_set_symmetric_difference(x, y) #>   a b #> 1 3 k #> 2 1 j #> 3 3 j  # Vector names don't affect set membership, but if you'd like to force # them to, you can transform the vector into a two column data frame x <- c(a = 1, b = 2, c = 2, d = 3) y <- c(c = 2, b = 1, a = 3, d = 3)  vec_set_intersect(x, y) #> a b d  #> 1 2 3   x <- data_frame(name = names(x), value = unname(x)) y <- data_frame(name = names(y), value = unname(y))  vec_set_intersect(x, y) #>   name value #> 1    c     2 #> 2    d     3"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_arith.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic operations — vec_arith","title":"Arithmetic operations — vec_arith","text":"generic provides common double dispatch mechanism infix operators (+, -, /, *, ^, %%, %/%, !, &, |). used power default arithmetic boolean operators vctrs objects, overcoming limitations base Ops generic.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_arith.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic operations — vec_arith","text":"","code":"vec_arith(op, x, y, ...)  # Default S3 method vec_arith(op, x, y, ...)  # S3 method for class 'logical' vec_arith(op, x, y, ...)  # S3 method for class 'numeric' vec_arith(op, x, y, ...)  vec_arith_base(op, x, y)  MISSING()"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_arith.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic operations — vec_arith","text":"op arithmetic operator string x, y pair vectors. !, unary + unary -, y sentinel object class MISSING, created MISSING(). ... dots future extensions must empty.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_arith.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arithmetic operations — vec_arith","text":"vec_arith_base() provided convenience writing methods. recycles x y common length calls base operator underlying vec_data(). vec_arith() also used diff.vctrs_vctr() method via -.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_arith.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic operations — vec_arith","text":"","code":"d <- as.Date(\"2018-01-01\") dt <- as.POSIXct(\"2018-01-02 12:00\") t <- as.difftime(12, unit = \"hours\")  vec_arith(\"-\", dt, 1) #> [1] \"2018-01-02 11:59:59 UTC\" vec_arith(\"-\", dt, t) #> [1] \"2018-01-02 UTC\" vec_arith(\"-\", dt, d) #> Time difference of 129600 secs  vec_arith(\"+\", dt, 86400) #> [1] \"2018-01-03 12:00:00 UTC\" vec_arith(\"+\", dt, t) #> [1] \"2018-01-03 UTC\" vec_arith(\"+\", t, t) #> Time difference of 24 hours  vec_arith(\"/\", t, t) #> [1] 1 vec_arith(\"/\", t, 2) #> Time difference of 6 hours  vec_arith(\"*\", t, 2) #> Time difference of 24 hours"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to an index vector — vec_as_index","title":"Convert to an index vector — vec_as_index","text":"vec_as_index() renamed vec_as_location() deprecated vctrs 0.2.2.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to an index vector — vec_as_index","text":"","code":"vec_as_index(i, n, names = NULL)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to an index vector — vec_as_index","text":"index vector convert. n single integer representing total size object meant index . names character vector, names character vector matched construct index. Otherwise, used. default value NULL result error character vector.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_location.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a vector of locations — vec_as_location","title":"Create a vector of locations — vec_as_location","text":"helpers provide means standardizing common indexing methods integer, character logical indexing. vec_as_location() accepts integer, character, logical vectors size. output always integer vector suitable subsetting [ vec_slice(). might different size input negative selections transformed positive ones logical vectors transformed vector indices TRUE locations. vec_as_location2() accepts single number string. returns single location integer vector size 1. suitable extracting [[. num_as_location() num_as_location2() specialized variants extra options numeric indices.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_location.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a vector of locations — vec_as_location","text":"","code":"vec_as_location(   i,   n,   names = NULL,   ...,   missing = c(\"propagate\", \"remove\", \"error\"),   arg = caller_arg(i),   call = caller_env() )  num_as_location(   i,   n,   ...,   missing = c(\"propagate\", \"remove\", \"error\"),   negative = c(\"invert\", \"error\", \"ignore\"),   oob = c(\"error\", \"remove\", \"extend\"),   zero = c(\"remove\", \"error\", \"ignore\"),   arg = caller_arg(i),   call = caller_env() )  vec_as_location2(   i,   n,   names = NULL,   ...,   missing = c(\"error\", \"propagate\"),   arg = caller_arg(i),   call = caller_env() )  num_as_location2(   i,   n,   ...,   negative = c(\"error\", \"ignore\"),   missing = c(\"error\", \"propagate\"),   arg = caller_arg(i),   call = caller_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_location.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a vector of locations — vec_as_location","text":"index vector convert. n single integer representing total size object meant index . names character vector, names character vector matched construct index. Otherwise, used. default value NULL result error character vector. ... dots future extensions must empty. missing missing values handled? \"error\" throws error. \"propagate\" returns . \"remove\" removes . default, vector subscripts propagate missing values scalar subscripts error . Propagated missing values combined negative indices negative = \"invert\", meaningfully inverted. arg argument name displayed error messages. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. negative negative values handled? \"error\" throws error. \"ignore\" returns . \"invert\" returns positive location generated inverting negative location. inverting, positive negative locations mixed. option applicable num_as_location(). oob --bounds values handled? \"error\" throws error. \"remove\" removes positive negative --bounds locations. \"extend\" allows positive --bounds locations directly follow end vector. can used implement extendable vectors, like letters[1:30]. zero zero values handled? \"error\" throws error. \"remove\" removes . \"ignore\" returns .","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_location.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a vector of locations — vec_as_location","text":"vec_as_location() num_as_location() return integer vector can used index subsetting operation. vec_as_location2() num_as_location2() return integer size 1 can used scalar index extracting element.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_location.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a vector of locations — vec_as_location","text":"","code":"x <- array(1:6, c(2, 3)) dimnames(x) <- list(c(\"r1\", \"r2\"), c(\"c1\", \"c2\", \"c3\"))  # The most common use case validates row indices vec_as_location(1, vec_size(x)) #> [1] 1  # Negative indices can be used to index from the back vec_as_location(-1, vec_size(x)) #> [1] 2  # Character vectors can be used if `names` are provided vec_as_location(\"r2\", vec_size(x), rownames(x)) #> [1] 2  # You can also construct an index for dimensions other than the first vec_as_location(c(\"c2\", \"c1\"), ncol(x), colnames(x)) #> [1] 2 1"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve and repair names — vec_as_names","title":"Retrieve and repair names — vec_as_names","text":"vec_as_names() takes character vector names repairs according repair argument. r-lib tidyverse equivalent base::make.names(). vctrs deals levels name repair: minimal names exist. names attribute NULL. name unnamed element \"\" never NA. instance, vec_as_names() always returns minimal names data frames created tibble package names , least, minimal. unique names minimal, duplicates, can used variable name expected. Empty names, ..., .. followed sequence digits banned. columns can accessed name via df[[\"name\"]] df$`name`  (df, `name`). universal names unique syntactic (see Details ). Names work everywhere, without quoting: df$name (df, name) lm(name1 ~ name2, data = df) dplyr::select(df, name) work. universal implies unique, unique implies minimal. levels nested.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve and repair names — vec_as_names","text":"","code":"vec_as_names(   names,   ...,   repair = c(\"minimal\", \"unique\", \"universal\", \"check_unique\", \"unique_quiet\",     \"universal_quiet\"),   repair_arg = NULL,   quiet = FALSE,   call = caller_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve and repair names — vec_as_names","text":"names character vector. ... dots future extensions must empty. repair Either string function. string, must one \"check_unique\", \"minimal\", \"unique\", \"universal\", \"unique_quiet\", \"universal_quiet\". function, invoked vector minimal names must return minimal names, otherwise error thrown. Minimal names never NULL NA. element name, minimal name empty string. Unique names unique. suffix appended duplicate names make unique. Universal names unique syntactic, meaning can safely use names variables without causing syntax error. \"check_unique\" option perform name repair. Instead, error raised names suit \"unique\" criteria. options \"unique_quiet\" \"universal_quiet\" help user calls function indirectly, via another function exposes repair quiet. Specifying repair = \"unique_quiet\" like specifying repair = \"unique\", quiet = TRUE. \"*_quiet\" options used, setting quiet silently overridden. repair_arg specified repair = \"check_unique\", errors include hint set repair_arg. quiet default, user informed renaming caused repairing names. concerns unique universal repairing. Set quiet TRUE silence messages. Users can silence name repair messages setting \"rlib_name_repair_verbosity\" global option \"quiet\". call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_names.html","id":"minimal-names","dir":"Reference","previous_headings":"","what":"minimal names","title":"Retrieve and repair names — vec_as_names","text":"minimal names exist. names attribute NULL. name unnamed element \"\" never NA. Examples:","code":"Original names of a vector with length 3: NULL                            minimal names: \"\" \"\" \"\"                            Original names: \"x\" NA                            minimal names: \"x\" \"\""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_names.html","id":"unique-names","dir":"Reference","previous_headings":"","what":"unique names","title":"Retrieve and repair names — vec_as_names","text":"unique names minimal, duplicates, can used (possibly backticks) contexts variable expected. Empty names, ..., .. followed sequence digits banned. data frame unique names, can index name, also access columns name. particular, df[[\"name\"]] df$`name` also (df, `name`) always work. many ways make names unique. append suffix form ...j name \"\" duplicate, j position. also change ..# ... ...#. Example:   Pre-existing suffixes form ...j always stripped, prior making names unique, .e. reconstructing suffixes. interacts poorly names, take control name repair.","code":"Original names:     \"\"     \"x\"     \"\" \"y\"     \"x\"  \"..2\"  \"...\"   unique names: \"...1\" \"x...2\" \"...3\" \"y\" \"x...5\" \"...6\" \"...7\""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_names.html","id":"universal-names","dir":"Reference","previous_headings":"","what":"universal names","title":"Retrieve and repair names — vec_as_names","text":"universal names unique syntactic, meaning : never empty (inherited unique). duplicates (inherited unique). .... form .., number (inherited unique). Consist letters, numbers, dot . underscore _ characters. Start letter start dot . followed number. reserved word, e.g., function TRUE. vector universal names, variable names can used \"\" code. work well nonstandard evaluation, e.g., df$name works. vctrs different method making names syntactic base::make.names(). general, vctrs prepends one dots . name syntactic. Examples:","code":"Original names:     \"\"     \"x\"    NA      \"x\" universal names: \"...1\" \"x...2\" \"...3\" \"x...4\"    Original names: \"(y)\"  \"_z\"  \".2fa\"  \"FALSE\"  universal names: \".y.\" \"._z\" \"..2fa\" \".FALSE\""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve and repair names — vec_as_names","text":"","code":"# By default, `vec_as_names()` returns minimal names: vec_as_names(c(NA, NA, \"foo\")) #> [1] \"\"    \"\"    \"foo\"  # You can make them unique: vec_as_names(c(NA, NA, \"foo\"), repair = \"unique\") #> New names: #> • `` -> `...1` #> • `` -> `...2` #> [1] \"...1\" \"...2\" \"foo\"   # Universal repairing fixes any non-syntactic name: vec_as_names(c(\"_foo\", \"+\"), repair = \"universal\") #> New names: #> • `_foo` -> `._foo` #> • `+` -> `.` #> [1] \"._foo\" \".\""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_names_legacy.html","id":null,"dir":"Reference","previous_headings":"","what":"Repair names with legacy method — vec_as_names_legacy","title":"Repair names with legacy method — vec_as_names_legacy","text":"standardises names legacy approach used tidyverse packages (tibble, tidyr, readxl) vec_as_names() implemented. tool meant help transitioning new name repairing standard deprecated removed package time future.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_names_legacy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Repair names with legacy method — vec_as_names_legacy","text":"","code":"vec_as_names_legacy(names, prefix = \"V\", sep = \"\")"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_names_legacy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Repair names with legacy method — vec_as_names_legacy","text":"names character vector. prefix, sep Prefix separator repaired names.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_names_legacy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Repair names with legacy method — vec_as_names_legacy","text":"","code":"if (rlang::is_installed(\"tibble\")) {  library(tibble)  # Names repair is turned off by default in tibble: try(tibble(a = 1, a = 2))  # You can turn it on by supplying a repair method: tibble(a = 1, a = 2, .name_repair = \"universal\")  # If you prefer the legacy method, use `vec_as_names_legacy()`: tibble(a = 1, a = 2, .name_repair = vec_as_names_legacy)  } #>  #> Attaching package: ‘tibble’ #> The following object is masked from ‘package:vctrs’: #>  #>     data_frame #> Error in tibble(a = 1, a = 2) :  #>   Column name `a` must not be duplicated. #> Use `.name_repair` to specify repair. #> Caused by error in `repaired_names()`: #> ! Names must be unique. #> ✖ These names are duplicated: #>   * \"a\" at locations 1 and 2. #> New names: #> • `a` -> `a...1` #> • `a` -> `a...2` #> # A tibble: 1 × 2 #>       a    a1 #>   <dbl> <dbl> #> 1     1     2"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_subscript.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to a base subscript type — vec_as_subscript","title":"Convert to a base subscript type — vec_as_subscript","text":"Convert base type expected vec_as_location() vec_as_location2(). values subscript type checked way (length, missingness, negative elements).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_subscript.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to a base subscript type — vec_as_subscript","text":"","code":"vec_as_subscript(   i,   ...,   logical = c(\"cast\", \"error\"),   numeric = c(\"cast\", \"error\"),   character = c(\"cast\", \"error\"),   arg = NULL,   call = caller_env() )  vec_as_subscript2(   i,   ...,   numeric = c(\"cast\", \"error\"),   character = c(\"cast\", \"error\"),   arg = NULL,   call = caller_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_as_subscript.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to a base subscript type — vec_as_subscript","text":"index vector convert. ... dots future extensions must empty. logical, numeric, character handle logical, numeric, character subscripts. \"cast\" subscript one three base types (logical, integer character), subscript cast relevant base type, e.g. factors coerced character. NULL treated empty integer vector, thus coercible depending setting numeric. Symbols treated character vectors thus coercible depending setting character. \"error\", subscript type disallowed triggers informative error. arg argument name displayed error messages. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_assert.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert an argument has known prototype and/or size — vec_assert","title":"Assert an argument has known prototype and/or size — vec_assert","text":"vec_is() predicate checks input vector conforms prototype /size. vec_assert() throws error input vector conform.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_assert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert an argument has known prototype and/or size — vec_assert","text":"","code":"vec_assert(   x,   ptype = NULL,   size = NULL,   arg = caller_arg(x),   call = caller_env() )  vec_is(x, ptype = NULL, size = NULL)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_assert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert an argument has known prototype and/or size — vec_assert","text":"x vector argument check. ptype Prototype compare . prototype class, vec_ptype() compared x identical(). Otherwise, typeof() compared x ==. size single integer size compare. arg Name argument checked. used error messages. label expression passed x taken default. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_assert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert an argument has known prototype and/or size — vec_assert","text":"vec_is() returns TRUE FALSE. vec_assert() either throws typed error (see section error types) returns x, invisibly.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_assert.html","id":"error-types","dir":"Reference","previous_headings":"","what":"Error types","title":"Assert an argument has known prototype and/or size — vec_assert","text":"vec_is() never throws. vec_assert() throws following errors: input vector, error class \"vctrs_error_scalar_type\" raised. prototype match, error class \"vctrs_error_assert_ptype\" raised. size match, error class \"vctrs_error_assert_size\" raised. errors inherit \"vctrs_error_assert\".","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_assert.html","id":"lifecycle","dir":"Reference","previous_headings":"","what":"Lifecycle","title":"Assert an argument has known prototype and/or size — vec_assert","text":"vec_is() vec_assert() questioning ptype arguments semantics challenging define clearly rarely useful. Use obj_is_vector() obj_check_vector() vector checks Use vec_check_size() size checks Use vec_cast(), inherits(), simple type predicates like rlang::is_logical() specific type checks","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_assert.html","id":"vectors-and-scalars","dir":"Reference","previous_headings":"","what":"Vectors and scalars","title":"Assert an argument has known prototype and/or size — vec_assert","text":"Informally, vector collection makes sense use column data frame. following rules define whether x considered vector. vec_proxy() method registered, x vector : base type object atomic: \"logical\", \"integer\", \"double\", \"complex\", \"character\", \"raw\". x list, defined obj_is_list(). x data.frame. vec_proxy() method registered, x vector : proxy satisfies one conditions. base type proxy \"list\", regardless class. S3 lists thus treated scalars unless implement vec_proxy() method. Otherwise object treated scalar used vector. particular: NULL vector. S3 lists like lm objects treated scalars default. Objects type expression treated vectors.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_bind.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine many data frames into one data frame — vec_bind","title":"Combine many data frames into one data frame — vec_bind","text":"pair functions binds together data frames (vectors), either row-wise column-wise. Row-binding creates data frame common type across arguments. Column-binding creates data frame common length across arguments.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_bind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine many data frames into one data frame — vec_bind","text":"","code":"vec_rbind(   ...,   .ptype = NULL,   .names_to = rlang::zap(),   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"unique_quiet\",     \"universal_quiet\"),   .name_spec = NULL,   .error_call = current_env() )  vec_cbind(   ...,   .ptype = NULL,   .size = NULL,   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\", \"unique_quiet\",     \"universal_quiet\"),   .error_call = current_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_bind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine many data frames into one data frame — vec_bind","text":"... Data frames vectors. inputs named: vec_rbind() assigns names row names unless .names_to supplied. case names assigned column defined .names_to. vec_cbind() creates packed data frame columns named inputs. NULL inputs silently ignored. Empty (e.g. zero row) inputs appear output, affect derived .ptype. .ptype NULL, default, output type determined computing common type across elements .... Alternatively, can supply .ptype give output known type. getOption(\"vctrs.no_guessing\") TRUE must supply value: convenient way make production code demand fixed types. .names_to controls input names supplied .... default, input names zapped. string, specifies column input names copied. names often useful identify rows original input. column name supplied ... named, integer column used instead. NULL, input names used row names. .name_repair One \"unique\", \"universal\", \"check_unique\", \"unique_quiet\",  \"universal_quiet\". See vec_as_names() meaning options. vec_rbind(), repair function applied inputs separately. vec_rbind() needs align columns binding rows, thus needs inputs unique names. hand, vec_cbind() applies repair function inputs concatenated together final data frame. Hence vec_cbind() allows permissive minimal names repair. .name_spec name specification (documented vec_c()) combining outer inputs names ... inner row names inputs. effect .names_to set NULL, causes input names assigned row names. .error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. .size , NULL, default, determine number rows vec_cbind() output using tidyverse recycling rules. Alternatively, specify desired number rows, inputs length 1 recycled appropriately.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_bind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine many data frames into one data frame — vec_bind","text":"data frame, subclass data frame. ... mix different data frame subclasses, vec_ptype2() used determine output type. vec_rbind(), determine type container type column; vec_cbind() determines type output container. non-NULL inputs, result data.frame().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_bind.html","id":"invariants","dir":"Reference","previous_headings":"","what":"Invariants","title":"Combine many data frames into one data frame — vec_bind","text":"inputs first converted data frame. conversion 1d vectors depends direction binding: vec_rbind(), element vector becomes column single row. vec_cbind(), element vector becomes row single column. inputs become data frames, following invariants observed row-binding: vec_size(vec_rbind(x, y)) == vec_size(x) + vec_size(y) vec_ptype(vec_rbind(x, y)) = vec_ptype_common(x, y) Note input empty vector, first converted 1-row data frame 0 columns. Despite empty, effective size total number rows 1. column-binding, following invariants apply: vec_size(vec_cbind(x, y)) == vec_size_common(x, y) vec_ptype(vec_cbind(x, y)) == vec_cbind(vec_ptype(x), vec_ptype(x))","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_bind.html","id":"vctrs-dependencies","dir":"Reference","previous_headings":"","what":"vctrs dependencies","title":"Combine many data frames into one data frame — vec_bind","text":"vec_cast_common() vec_proxy() vec_init() vec_assign() vec_restore()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_bind.html","id":"base-dependencies-of-vec-rbind-","dir":"Reference","previous_headings":"","what":"base dependencies of vec_rbind()","title":"Combine many data frames into one data frame — vec_bind","text":"base::c() columns combine inherit common class, vec_rbind() falls back base::c() exists c() method implemented class hierarchy.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_bind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine many data frames into one data frame — vec_bind","text":"","code":"# row binding -----------------------------------------  # common columns are coerced to common class vec_rbind(   data.frame(x = 1),   data.frame(x = FALSE) ) #>   x #> 1 1 #> 2 0  # unique columns are filled with NAs vec_rbind(   data.frame(x = 1),   data.frame(y = \"x\") ) #>    x    y #> 1  1 <NA> #> 2 NA    x  # null inputs are ignored vec_rbind(   data.frame(x = 1),   NULL,   data.frame(x = 2) ) #>   x #> 1 1 #> 2 2  # bare vectors are treated as rows vec_rbind(   c(x = 1, y = 2),   c(x = 3) ) #>   x  y #> 1 1  2 #> 2 3 NA  # default names will be supplied if arguments are not named vec_rbind(   1:2,   1:3,   1:4 ) #> New names: #> • `` -> `...1` #> • `` -> `...2` #> New names: #> • `` -> `...1` #> • `` -> `...2` #> • `` -> `...3` #> New names: #> • `` -> `...1` #> • `` -> `...2` #> • `` -> `...3` #> • `` -> `...4` #>   ...1 ...2 ...3 ...4 #> 1    1    2   NA   NA #> 2    1    2    3   NA #> 3    1    2    3    4  # column binding --------------------------------------  # each input is recycled to have common length vec_cbind(   data.frame(x = 1),   data.frame(y = 1:3) ) #>   x y #> 1 1 1 #> 2 1 2 #> 3 1 3  # bare vectors are treated as columns vec_cbind(   data.frame(x = 1),   y = letters[1:3] ) #>   x y #> 1 1 a #> 2 1 b #> 3 1 c  # if you supply a named data frame, it is packed in a single column data <- vec_cbind(   x = data.frame(a = 1, b = 2),   y = 1 ) data #>   x.a x.b y #> 1   1   2 1  # Packed data frames are nested in a single column. This makes it # possible to access it through a single name: data$x #>   a b #> 1 1 2  # since the base print method is suboptimal with packed data # frames, it is recommended to use tibble to work with these: if (rlang::is_installed(\"tibble\")) {   vec_cbind(x = tibble::tibble(a = 1, b = 2), y = 1) } #> # A tibble: 1 × 2 #>     x$a    $b     y #>   <dbl> <dbl> <dbl> #> 1     1     2     1  # duplicate names are flagged vec_cbind(x = 1, x = 2) #> New names: #> • `x` -> `x...1` #> • `x` -> `x...2` #>   x...1 x...2 #> 1     1     2"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_c.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine many vectors into one vector — vec_c","title":"Combine many vectors into one vector — vec_c","text":"Combine arguments new vector common type.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine many vectors into one vector — vec_c","text":"","code":"vec_c(   ...,   .ptype = NULL,   .name_spec = NULL,   .name_repair = c(\"minimal\", \"unique\", \"check_unique\", \"universal\", \"unique_quiet\",     \"universal_quiet\"),   .error_arg = \"\",   .error_call = current_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine many vectors into one vector — vec_c","text":"... Vectors coerce. .ptype NULL, default, output type determined computing common type across elements .... Alternatively, can supply .ptype give output known type. getOption(\"vctrs.no_guessing\") TRUE must supply value: convenient way make production code demand fixed types. .name_spec name specification combining inner outer names. relevant inputs passed name, inputs named, like outer = c(inner = 1), length greater 1: outer = 1:2. default, cases trigger error. can resolve error providing specification describes combine names indices inner vector name input. specification can : function two arguments. outer name passed string first argument, inner names positions passed second argument. anonymous function purrr-style formula. glue specification form \"{outer}_{inner}\". rlang::zap() object, case outer inner names ignored result unnamed. See name specification topic. .name_repair repair names, see repair options vec_as_names(). .error_arg argument name string. argument mentioned error messages input origin problem. .error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_c.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine many vectors into one vector — vec_c","text":"vector class given .ptype, length equal sum vec_size() contents .... vector names individual components names (inner names) arguments named (outer names). inner outer names present, error thrown unless .name_spec provided.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_c.html","id":"invariants","dir":"Reference","previous_headings":"","what":"Invariants","title":"Combine many vectors into one vector — vec_c","text":"vec_size(vec_c(x, y)) == vec_size(x) + vec_size(y) vec_ptype(vec_c(x, y)) == vec_ptype_common(x, y).","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_c.html","id":"vctrs-dependencies","dir":"Reference","previous_headings":"","what":"vctrs dependencies","title":"Combine many vectors into one vector — vec_c","text":"vec_cast_common() fallback vec_proxy() vec_restore()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_c.html","id":"base-dependencies","dir":"Reference","previous_headings":"","what":"base dependencies","title":"Combine many vectors into one vector — vec_c","text":"base::c() inputs inherit common class hierarchy, vec_c() falls back base::c() exists c() method implemented class hierarchy.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_c.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine many vectors into one vector — vec_c","text":"","code":"vec_c(FALSE, 1L, 1.5) #> [1] 0.0 1.0 1.5  # Date/times -------------------------- c(Sys.Date(), Sys.time()) #> [1] \"2025-08-27\" \"2025-08-27\" c(Sys.time(), Sys.Date()) #> [1] \"2025-08-27 16:38:34 UTC\" \"2025-08-27 00:00:00 UTC\"  vec_c(Sys.Date(), Sys.time()) #> [1] \"2025-08-27 00:00:00 UTC\" \"2025-08-27 16:38:34 UTC\" vec_c(Sys.time(), Sys.Date()) #> [1] \"2025-08-27 16:38:34 UTC\" \"2025-08-27 00:00:00 UTC\"  # Factors ----------------------------- c(factor(\"a\"), factor(\"b\")) #> [1] a b #> Levels: a b vec_c(factor(\"a\"), factor(\"b\")) #> [1] a b #> Levels: a b   # By default, named inputs must be length 1: vec_c(name = 1) #> name  #>    1  try(vec_c(name = 1:3)) #> Error in vec_c(name = 1:3) :  #>   Can't merge the outer name `name` with a vector of length > 1. #> Please supply a `.name_spec` specification.  # Pass a name specification to work around this: vec_c(name = 1:3, .name_spec = \"{outer}_{inner}\") #> name_1 name_2 name_3  #>      1      2      3   # See `?name_spec` for more examples of name specifications."},{"path":"https://vctrs.r-lib.org/dev/reference/vec_cast.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast a vector to a specified type — vec_cast","title":"Cast a vector to a specified type — vec_cast","text":"vec_cast() provides directional conversions one type vector another. Along vec_ptype2(), generic forms foundation type coercions vctrs.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_cast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast a vector to a specified type — vec_cast","text":"","code":"vec_cast(x, to, ..., x_arg = caller_arg(x), to_arg = \"\", call = caller_env())  vec_cast_common(..., .to = NULL, .arg = \"\", .call = caller_env())  # S3 method for class 'logical' vec_cast(x, to, ...)  # S3 method for class 'integer' vec_cast(x, to, ...)  # S3 method for class 'double' vec_cast(x, to, ...)  # S3 method for class 'complex' vec_cast(x, to, ...)  # S3 method for class 'raw' vec_cast(x, to, ...)  # S3 method for class 'character' vec_cast(x, to, ...)  # S3 method for class 'list' vec_cast(x, to, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_cast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cast a vector to a specified type — vec_cast","text":"x Vectors cast. , .Type cast . NULL, x returned . ... vec_cast_common(), vectors cast. vec_cast(), vec_cast_default(), vec_restore(), dots future extensions empty. x_arg Argument name x, used error messages inform user locations incompatible types (see stop_incompatible_type()). to_arg Argument name used error messages inform user locations incompatible types (see stop_incompatible_type()). call, .call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. .arg argument name string. argument mentioned error messages input origin problem.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_cast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cast a vector to a specified type — vec_cast","text":"vector length x type , error cast possible. error generated information lost casting compatible types (.e. 1--1 mapping specific value).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_cast.html","id":"implementing-coercion-methods","dir":"Reference","previous_headings":"","what":"Implementing coercion methods","title":"Cast a vector to a specified type — vec_cast","text":"overview generics work roles vctrs, see ?theory-faq-coercion. example implementing coercion methods simple vectors, see ?howto-faq-coercion. example implementing coercion methods data frame subclasses, see ?howto-faq-coercion-data-frame. tutorial implementing vctrs classes scratch, see vignette(\"s3-vector\").","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_cast.html","id":"vctrs-dependencies","dir":"Reference","previous_headings":"","what":"vctrs dependencies","title":"Cast a vector to a specified type — vec_cast","text":"vec_ptype2() vec_cast()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_cast.html","id":"base-dependencies","dir":"Reference","previous_headings":"","what":"base dependencies","title":"Cast a vector to a specified type — vec_cast","text":"functions enable base-class fallback vec_cast_common(). case inputs deemed compatible base type inherit base class.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_cast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cast a vector to a specified type — vec_cast","text":"","code":"# x is a double, but no information is lost vec_cast(1, integer()) #> [1] 1  # When information is lost the cast fails try(vec_cast(c(1, 1.5), integer())) #> Error in eval(expr, envir) :  #>   Can't convert from `c(1, 1.5)` <double> to <integer> due to loss of precision. #> • Locations: 2 try(vec_cast(c(1, 2), logical())) #> Error in eval(expr, envir) :  #>   Can't convert from `c(1, 2)` <double> to <logical> due to loss of precision. #> • Locations: 2  # You can suppress this error and get the partial results allow_lossy_cast(vec_cast(c(1, 1.5), integer())) #> [1] 1 1 allow_lossy_cast(vec_cast(c(1, 2), logical())) #> [1] TRUE TRUE  # By default this suppress all lossy cast errors without # distinction, but you can be specific about what cast is allowed # by supplying prototypes allow_lossy_cast(vec_cast(c(1, 1.5), integer()), to_ptype = integer()) #> [1] 1 1 try(allow_lossy_cast(vec_cast(c(1, 2), logical()), to_ptype = integer())) #> Error in eval(expr, envir) :  #>   Can't convert from `c(1, 2)` <double> to <logical> due to loss of precision. #> • Locations: 2  # No sensible coercion is possible so an error is generated try(vec_cast(1.5, factor(\"a\"))) #> Error in eval(expr, envir) :  #>   Can't convert `1.5` <double> to <factor<4d52a>>.  # Cast to common type vec_cast_common(factor(\"a\"), factor(c(\"a\", \"b\"))) #> [[1]] #> [1] a #> Levels: a b #>  #> [[2]] #> [1] a b #> Levels: a b #>"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_cbind_frame_ptype.html","id":null,"dir":"Reference","previous_headings":"","what":"Frame prototype — vec_cbind_frame_ptype","title":"Frame prototype — vec_cbind_frame_ptype","text":"experimental generic returns zero-columns variants data frame. needed vec_cbind(), work around lack colwise primitives vctrs. Expect changes.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_cbind_frame_ptype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Frame prototype — vec_cbind_frame_ptype","text":"","code":"vec_cbind_frame_ptype(x, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_cbind_frame_ptype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Frame prototype — vec_cbind_frame_ptype","text":"x data frame. ... dots future extensions must empty.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_chop.html","id":null,"dir":"Reference","previous_headings":"","what":"Chopping — vec_chop","title":"Chopping — vec_chop","text":"vec_chop() provides efficient method repeatedly slice vector. captures pattern map(indices, vec_slice, x = x). indices supplied, generally equivalent .list(). list_unchop() combines list vectors single vector, placing elements output according locations specified indices. similar vec_c(), gives greater control elements combined. indices supplied, identical vec_c(), typically little faster. indices selects every value x exactly , order, list_unchop() inverse vec_chop() following invariant holds:","code":"list_unchop(vec_chop(x, indices = indices), indices = indices) == x"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_chop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chopping — vec_chop","text":"","code":"vec_chop(x, ..., indices = NULL, sizes = NULL)  list_unchop(   x,   ...,   indices = NULL,   ptype = NULL,   name_spec = NULL,   name_repair = c(\"minimal\", \"unique\", \"check_unique\", \"universal\", \"unique_quiet\",     \"universal_quiet\"),   error_arg = \"x\",   error_call = current_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_chop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chopping — vec_chop","text":"x vector ... dots future extensions must empty. indices vec_chop(), list positive integer vectors slice x , NULL. used sizes already specified. indices sizes NULL, x split individual elements, equivalent using indices .list(vec_seq_along(x)). list_unchop(), list positive integer vectors specifying locations place elements x . element x recycled size corresponding index vector. size indices must match size x. NULL, x combined order provided , equivalent using vec_c(). sizes integer vector non-negative sizes representing sequential indices slice x , NULL. used indices already specified. example, sizes = c(2, 4) equivalent indices = list(1:2, 3:6), typically faster. sum(sizes) must equal vec_size(x), .e. sizes must completely partition x, individual size allowed 0. ptype NULL, default, output type determined computing common type across elements x. Alternatively, can supply ptype give output known type. name_spec name specification combining inner outer names. relevant inputs passed name, inputs named, like outer = c(inner = 1), length greater 1: outer = 1:2. default, cases trigger error. can resolve error providing specification describes combine names indices inner vector name input. specification can : function two arguments. outer name passed string first argument, inner names positions passed second argument. anonymous function purrr-style formula. glue specification form \"{outer}_{inner}\". rlang::zap() object, case outer inner names ignored result unnamed. See name specification topic. name_repair repair names, see repair options vec_as_names(). error_arg argument name string. argument mentioned error messages input origin problem. error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_chop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chopping — vec_chop","text":"vec_chop(): list element type x. size list equal vec_size(indices), vec_size(sizes), vec_size(x) depending whether indices sizes provided. list_unchop(): vector type vec_ptype_common(!!!x), ptype, specified. size computed vec_size_common(!!!indices) unless indices NULL, case size vec_size_common(!!!x).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_chop.html","id":"dependencies-of-vec-chop-","dir":"Reference","previous_headings":"","what":"Dependencies of vec_chop()","title":"Chopping — vec_chop","text":"vec_slice()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_chop.html","id":"dependencies-of-list-unchop-","dir":"Reference","previous_headings":"","what":"Dependencies of list_unchop()","title":"Chopping — vec_chop","text":"vec_c()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_chop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chopping — vec_chop","text":"","code":"vec_chop(1:5) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>   # These two are equivalent vec_chop(1:5, indices = list(1:2, 3:5)) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 3 4 5 #>  vec_chop(1:5, sizes = c(2, 3)) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 3 4 5 #>   # Can also be used on data frames vec_chop(mtcars, indices = list(1:3, 4:6)) #> [[1]] #>                mpg cyl disp  hp drat    wt  qsec vs am gear carb #> Mazda RX4     21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 #> Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 #> Datsun 710    22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 #>  #> [[2]] #>                    mpg cyl disp  hp drat    wt  qsec vs am gear carb #> Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 #> Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 #> Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 #>   # If `indices` selects every value in `x` exactly once, # in any order, then `list_unchop()` inverts `vec_chop()` x <- c(\"a\", \"b\", \"c\", \"d\") indices <- list(2, c(3, 1), 4) vec_chop(x, indices = indices) #> [[1]] #> [1] \"b\" #>  #> [[2]] #> [1] \"c\" \"a\" #>  #> [[3]] #> [1] \"d\" #>  list_unchop(vec_chop(x, indices = indices), indices = indices) #> [1] \"a\" \"b\" \"c\" \"d\"  # When unchopping, size 1 elements of `x` are recycled # to the size of the corresponding index list_unchop(list(1, 2:3), indices = list(c(1, 3, 5), c(2, 4))) #> [1] 1 2 1 3 1  # Names are retained, and outer names can be combined with inner # names through the use of a `name_spec` lst <- list(x = c(a = 1, b = 2), y = 1) list_unchop(lst, indices = list(c(3, 2), c(1, 4)), name_spec = \"{outer}_{inner}\") #> y_1 x_b x_a y_2  #>   1   2   1   1   # An alternative implementation of `ave()` can be constructed using # `vec_chop()` and `list_unchop()` in combination with `vec_group_loc()` ave2 <- function(.x, .by, .f, ...) {   indices <- vec_group_loc(.by)$loc   chopped <- vec_chop(.x, indices = indices)   out <- lapply(chopped, .f, ...)   list_unchop(out, indices = indices) }  breaks <- warpbreaks$breaks wool <- warpbreaks$wool  ave2(breaks, wool, mean) #>  [1] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 #>  [8] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 #> [15] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 #> [22] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 25.25926 #> [29] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 #> [36] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 #> [43] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 #> [50] 25.25926 25.25926 25.25926 25.25926 25.25926  identical(   ave2(breaks, wool, mean),   ave(breaks, wool, FUN = mean) ) #> [1] TRUE  # If you know your input is sorted and you'd like to split on the groups, # `vec_run_sizes()` can be efficiently combined with `sizes` df <- data_frame(   g = c(2, 5, 5, 6, 6, 6, 6, 8, 9, 9),   x = 1:10 ) #> Warning: `data_frame()` was deprecated in tibble 1.1.0. #> ℹ Please use `tibble()` instead. vec_chop(df, sizes = vec_run_sizes(df$g)) #> [[1]] #> # A tibble: 1 × 2 #>       g     x #>   <dbl> <int> #> 1     2     1 #>  #> [[2]] #> # A tibble: 2 × 2 #>       g     x #>   <dbl> <int> #> 1     5     2 #> 2     5     3 #>  #> [[3]] #> # A tibble: 4 × 2 #>       g     x #>   <dbl> <int> #> 1     6     4 #> 2     6     5 #> 3     6     6 #> 4     6     7 #>  #> [[4]] #> # A tibble: 1 × 2 #>       g     x #>   <dbl> <int> #> 1     8     8 #>  #> [[5]] #> # A tibble: 2 × 2 #>       g     x #>   <dbl> <int> #> 1     9     9 #> 2     9    10 #>   # If you have a list of homogeneous vectors, sometimes it can be useful to # unchop, apply a function to the flattened vector, and then rechop according # to the original indices. This can be done efficiently with `list_sizes()`. x <- list(c(1, 2, 1), c(3, 1), 5, double()) x_flat <- list_unchop(x) x_flat <- x_flat + max(x_flat) vec_chop(x_flat, sizes = list_sizes(x)) #> [[1]] #> [1] 6 7 6 #>  #> [[2]] #> [1] 8 6 #>  #> [[3]] #> [1] 10 #>  #> [[4]] #> numeric(0) #>"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_compare.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare two vectors — vec_compare","title":"Compare two vectors — vec_compare","text":"Compare two vectors","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_compare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare two vectors — vec_compare","text":"","code":"vec_compare(x, y, na_equal = FALSE, .ptype = NULL)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_compare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare two vectors — vec_compare","text":"x, y Vectors compatible types lengths. na_equal NA values considered equal? .ptype Override optionally specify common type","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_compare.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare two vectors — vec_compare","text":"integer vector values -1 x < y, 0 x == y, 1 x > y. na_equal FALSE, result NA either x y NA.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_compare.html","id":"s-dispatch","dir":"Reference","previous_headings":"","what":"S3 dispatch","title":"Compare two vectors — vec_compare","text":"vec_compare() generic performance; instead uses vec_proxy_compare() create proxy used comparison.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_compare.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Compare two vectors — vec_compare","text":"vec_cast_common() fallback vec_recycle_common() vec_proxy_compare()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_compare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare two vectors — vec_compare","text":"","code":"vec_compare(c(TRUE, FALSE, NA), FALSE) #> [1]  1  0 NA vec_compare(c(TRUE, FALSE, NA), FALSE, na_equal = TRUE) #> [1]  1  0 -1  vec_compare(1:10, 5) #>  [1] -1 -1 -1 -1  0  1  1  1  1  1 vec_compare(runif(10), 0.5) #>  [1] -1  1 -1  1 -1  1  1  1 -1 -1 vec_compare(letters[1:10], \"d\") #>  [1] -1 -1 -1  0  1  1  1  1  1  1  df <- data.frame(x = c(1, 1, 1, 2), y = c(0, 1, 2, 1)) vec_compare(df, data.frame(x = 1, y = 1)) #> [1] -1  0  1  1"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Count unique values in a vector — vec_count","title":"Count unique values in a vector — vec_count","text":"Count number unique values vector. vec_count() two important differences table(): returns data frame, given multiple inputs (data frame), counts combinations appear input.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count unique values in a vector — vec_count","text":"","code":"vec_count(x, sort = c(\"count\", \"key\", \"location\", \"none\"))"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count unique values in a vector — vec_count","text":"x vector (including data frame). sort One \"count\", \"key\", \"location\", \"none\". \"count\", default, puts frequent values top \"key\", orders output key column (.e. unique values x) \"location\", orders location key first seen. useful want match counts unique/duplicated functions. \"none\", leaves unordered. guaranteed produce ordering across R sessions, fastest method.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count unique values in a vector — vec_count","text":"data frame columns key (type x) count (integer vector).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_count.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Count unique values in a vector — vec_count","text":"vec_proxy_equal() vec_slice() vec_order()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count unique values in a vector — vec_count","text":"","code":"vec_count(mtcars$vs) #>   key count #> 1   0    18 #> 2   1    14 vec_count(iris$Species) #>          key count #> 1     setosa    50 #> 2 versicolor    50 #> 3  virginica    50  # If you count a data frame you'll get a data frame # column in the output str(vec_count(mtcars[c(\"vs\", \"am\")])) #> 'data.frame':\t4 obs. of  2 variables: #>  $ key  :'data.frame':\t4 obs. of  2 variables: #>   ..$ vs: num  0 1 1 0 #>   ..$ am: num  0 1 0 1 #>  $ count: int  12 7 7 6  # Sorting ---------------------------------------  x <- letters[rpois(100, 6)] # default is to sort by frequency vec_count(x) #>    key count #> 1    f    20 #> 2    d    16 #> 3    g    13 #> 4    e    11 #> 5    i    11 #> 6    h    10 #> 7    b     5 #> 8    j     4 #> 9    c     3 #> 10   n     2 #> 11   a     2 #> 12   m     2 #> 13   k     1  # by can sort by key vec_count(x, sort = \"key\") #>    key count #> 1    a     2 #> 2    b     5 #> 3    c     3 #> 4    d    16 #> 5    e    11 #> 6    f    20 #> 7    g    13 #> 8    h    10 #> 9    i    11 #> 10   j     4 #> 11   k     1 #> 12   m     2 #> 13   n     2  # or location of first value vec_count(x, sort = \"location\") #>    key count #> 1    f    20 #> 2    e    11 #> 3    b     5 #> 4    i    11 #> 5    d    16 #> 6    j     4 #> 7    g    13 #> 8    n     2 #> 9    c     3 #> 10   h    10 #> 11   a     2 #> 12   m     2 #> 13   k     1 head(x) #> [1] \"f\" \"e\" \"b\" \"e\" \"f\" \"i\"  # or not at all vec_count(x, sort = \"none\") #>    key count #> 1    c     3 #> 2    a     2 #> 3    e    11 #> 4    m     2 #> 5    n     2 #> 6    j     4 #> 7    i    11 #> 8    d    16 #> 9    k     1 #> 10   g    13 #> 11   f    20 #> 12   h    10 #> 13   b     5"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract underlying data — vec_data","title":"Extract underlying data — vec_data","text":"Extract data underlying S3 vector object, .e. underlying (named) atomic vector, data frame, list.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract underlying data — vec_data","text":"","code":"vec_data(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract underlying data — vec_data","text":"x vector object implementing vec_proxy().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract underlying data — vec_data","text":"data underlying x, free attributes except names.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_data.html","id":"difference-with-vec-proxy-","dir":"Reference","previous_headings":"","what":"Difference with vec_proxy()","title":"Extract underlying data — vec_data","text":"vec_data() returns unstructured data. attributes preserved names, dims, dimnames. Currently, due underlying memory architecture R, creates full copy data atomic vectors. vec_proxy() may return structured data. generic main customisation point accessing memory values vctrs, along vec_restore(). Methods must return vector type. Records data frames processed rowwise.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_default_ptype2.html","id":null,"dir":"Reference","previous_headings":"","what":"Default cast and ptype2 methods — vec_default_cast","title":"Default cast and ptype2 methods — vec_default_cast","text":"functions automatically called vec_ptype2() vec_cast() method implemented pair types. apply special handling one inputs type AsIs sfc. attempt number fallbacks cases inconvenient strict: class attributes considered compatible. vec_default_cast() returns x case. case incompatible data frame classes, fall back data.frame. incompatible subclass tibble involved, fall back tbl_df. Otherwise, error thrown stop_incompatible_type() stop_incompatible_cast().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_default_ptype2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default cast and ptype2 methods — vec_default_cast","text":"","code":"vec_default_cast(x, to, ..., x_arg = \"\", to_arg = \"\", call = caller_env())  vec_default_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\", call = caller_env())"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_default_ptype2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default cast and ptype2 methods — vec_default_cast","text":"x Vectors cast. Type cast . NULL, x returned . ... vec_cast_common(), vectors cast. vec_cast(), vec_cast_default(), vec_restore(), dots future extensions empty. x_arg Argument name x, used error messages inform user locations incompatible types (see stop_incompatible_type()). to_arg Argument name used error messages inform user locations incompatible types (see stop_incompatible_type()). call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_detect_complete.html","id":null,"dir":"Reference","previous_headings":"","what":"Complete — vec_detect_complete","title":"Complete — vec_detect_complete","text":"vec_detect_complete() detects \"complete\" observations. observation considered complete non-missing. vectors, implies vec_detect_complete(x) == !vec_detect_missing(x). data frames matrices, row considered complete elements row non-missing. compare, !vec_detect_missing(x) detects rows partially complete (least one non-missing value).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_detect_complete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Complete — vec_detect_complete","text":"","code":"vec_detect_complete(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_detect_complete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Complete — vec_detect_complete","text":"x vector","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_detect_complete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Complete — vec_detect_complete","text":"logical vector size x.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_detect_complete.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Complete — vec_detect_complete","text":"record type vector similar data frame, considered complete fields non-missing.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_detect_complete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Complete — vec_detect_complete","text":"","code":"x <- c(1, 2, NA, 4, NA)  # For most vectors, this is identical to `!vec_detect_missing(x)` vec_detect_complete(x) #> [1]  TRUE  TRUE FALSE  TRUE FALSE !vec_detect_missing(x) #> [1]  TRUE  TRUE FALSE  TRUE FALSE  df <- data_frame(   x = x,   y = c(\"a\", \"b\", NA, \"d\", \"e\") )  # This returns `TRUE` where all elements of the row are non-missing. # Compare that with `!vec_detect_missing()`, which detects rows that have at # least one non-missing value. df2 <- df df2$all_non_missing <- vec_detect_complete(df) df2$any_non_missing <- !vec_detect_missing(df) df2 #> # A tibble: 5 × 4 #>       x y     all_non_missing any_non_missing #>   <dbl> <chr> <lgl>           <lgl>           #> 1     1 a     TRUE            TRUE            #> 2     2 b     TRUE            TRUE            #> 3    NA NA    FALSE           FALSE           #> 4     4 d     TRUE            TRUE            #> 5    NA e     FALSE           TRUE"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_duplicate.html","id":null,"dir":"Reference","previous_headings":"","what":"Find duplicated values — vec_duplicate","title":"Find duplicated values — vec_duplicate","text":"vec_duplicate_any(): detects presence duplicated values, similar anyDuplicated(). vec_duplicate_detect(): returns logical vector describing element vector duplicated elsewhere. Unlike duplicated(), reports duplicated values, just second subsequent repetitions. vec_duplicate_id(): returns integer vector giving location first occurrence value.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_duplicate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find duplicated values — vec_duplicate","text":"","code":"vec_duplicate_any(x)  vec_duplicate_detect(x)  vec_duplicate_id(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_duplicate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find duplicated values — vec_duplicate","text":"x vector (including data frame).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_duplicate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find duplicated values — vec_duplicate","text":"vec_duplicate_any(): logical vector length 1. vec_duplicate_detect(): logical vector length x. vec_duplicate_id(): integer vector length x.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_duplicate.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing values","title":"Find duplicated values — vec_duplicate","text":"cases, missing values considered equal, .e. NA == NA TRUE. behaviour unappealing , functions consider NAs equal. (Similarly, NaN also considered equal.)","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_duplicate.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Find duplicated values — vec_duplicate","text":"vec_proxy_equal()","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_duplicate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find duplicated values — vec_duplicate","text":"","code":"vec_duplicate_any(1:10) #> [1] FALSE vec_duplicate_any(c(1, 1:10)) #> [1] TRUE  x <- c(10, 10, 20, 30, 30, 40) vec_duplicate_detect(x) #> [1]  TRUE  TRUE FALSE  TRUE  TRUE FALSE # Note that `duplicated()` doesn't consider the first instance to # be a duplicate duplicated(x) #> [1] FALSE  TRUE FALSE FALSE  TRUE FALSE  # Identify elements of a vector by the location of the first element that # they're equal to: vec_duplicate_id(x) #> [1] 1 1 3 4 4 6 # Location of the unique values: vec_unique_loc(x) #> [1] 1 3 4 6 # Equivalent to `duplicated()`: vec_duplicate_id(x) == seq_along(x) #> [1]  TRUE FALSE  TRUE  TRUE FALSE  TRUE"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_empty.html","id":null,"dir":"Reference","previous_headings":"","what":"Is a vector empty — vec_empty","title":"Is a vector empty — vec_empty","text":"function defunct, please use vec_is_empty().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_empty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is a vector empty — vec_empty","text":"","code":"vec_empty(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is a vector empty — vec_empty","text":"x object.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"Equality — vec_equal","title":"Equality — vec_equal","text":"vec_equal() tests two vectors equal.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Equality — vec_equal","text":"","code":"vec_equal(x, y, na_equal = FALSE, .ptype = NULL)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Equality — vec_equal","text":"x, y Vectors compatible types lengths. na_equal NA values considered equal? .ptype Override optionally specify common type","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Equality — vec_equal","text":"logical vector size common size x y. contain NAs na_equal FALSE.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_equal.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Equality — vec_equal","text":"vec_cast_common() fallback vec_recycle_common() vec_proxy_equal()","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_equal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Equality — vec_equal","text":"","code":"vec_equal(c(TRUE, FALSE, NA), FALSE) #> [1] FALSE  TRUE    NA vec_equal(c(TRUE, FALSE, NA), FALSE, na_equal = TRUE) #> [1] FALSE  TRUE FALSE  vec_equal(5, 1:10) #>  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE vec_equal(\"d\", letters[1:10]) #>  [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  df <- data.frame(x = c(1, 1, 2, 1), y = c(1, 2, 1, NA)) vec_equal(df, data.frame(x = 1, y = 2)) #> [1] FALSE  TRUE FALSE    NA"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_equal_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Missing values — vec_equal_na","title":"Missing values — vec_equal_na","text":"vec_equal_na() renamed vec_detect_missing() deprecated vctrs 0.5.0.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_equal_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Missing values — vec_equal_na","text":"","code":"vec_equal_na(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_equal_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Missing values — vec_equal_na","text":"x vector","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_equal_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Missing values — vec_equal_na","text":"logical vector size x.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_expand_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a data frame from all combinations of the inputs — vec_expand_grid","title":"Create a data frame from all combinations of the inputs — vec_expand_grid","text":"vec_expand_grid() creates new data frame creating grid possible combinations input vectors. inspired expand.grid(). Compared expand.grid(), : Produces sorted output default varying first column slowest, rather fastest. Control .vary. Never converts strings factors. add additional attributes. Drops NULL inputs. Can expand vector type, including data frames records.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_expand_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a data frame from all combinations of the inputs — vec_expand_grid","text":"","code":"vec_expand_grid(   ...,   .vary = \"slowest\",   .name_repair = \"check_unique\",   .error_call = current_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_expand_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a data frame from all combinations of the inputs — vec_expand_grid","text":"... Name-value pairs. name become column name resulting data frame. .vary One : \"slowest\" vary first column slowest. produces sorted output generally useful. \"fastest\" vary first column fastest. matches behavior expand.grid(). .name_repair One \"check_unique\", \"unique\", \"universal\", \"minimal\", \"unique_quiet\", \"universal_quiet\". See vec_as_names() meaning options. .error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_expand_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a data frame from all combinations of the inputs — vec_expand_grid","text":"data frame many columns inputs ... many rows prod() sizes inputs.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_expand_grid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a data frame from all combinations of the inputs — vec_expand_grid","text":"input empty (.e. size 0), result 0 rows. inputs provided, result 1 row data frame 0 columns. consistent fact prod() inputs returns 1.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_expand_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a data frame from all combinations of the inputs — vec_expand_grid","text":"","code":"vec_expand_grid(x = 1:2, y = 1:3) #>   x y #> 1 1 1 #> 2 1 2 #> 3 1 3 #> 4 2 1 #> 5 2 2 #> 6 2 3  # Use `.vary` to match `expand.grid()`: vec_expand_grid(x = 1:2, y = 1:3, .vary = \"fastest\") #>   x y #> 1 1 1 #> 2 2 1 #> 3 1 2 #> 4 2 2 #> 5 1 3 #> 6 2 3  # Can also expand data frames vec_expand_grid(   x = data_frame(a = 1:2, b = 3:4),   y = 1:4 ) #> Warning: corrupt data frame: columns will be truncated or padded with NAs #>                                                                                         x #> 1                                                 \\033[38;5;246m# A tibble: 8 × 2\\033[39m #> 2                                                                                 a     b #> 3   \\033[3m\\033[38;5;246m<int>\\033[39m\\033[23m \\033[3m\\033[38;5;246m<int>\\033[39m\\033[23m #> 4                                                     \\033[38;5;250m1\\033[39m     1     3 #> 5                                                     \\033[38;5;250m2\\033[39m     1     3 #> 6                                                     \\033[38;5;250m3\\033[39m     1     3 #> 7                                                     \\033[38;5;250m4\\033[39m     1     3 #> 8                                                     \\033[38;5;250m5\\033[39m     2     4 #>   y #> 1 1 #> 2 2 #> 3 3 #> 4 4 #> 5 1 #> 6 2 #> 7 3 #> 8 4"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_fill_missing.html","id":null,"dir":"Reference","previous_headings":"","what":"Fill in missing values with the previous or following value — vec_fill_missing","title":"Fill in missing values with the previous or following value — vec_fill_missing","text":"vec_fill_missing() fills gaps missing values previous following non-missing value.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_fill_missing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fill in missing values with the previous or following value — vec_fill_missing","text":"","code":"vec_fill_missing(   x,   direction = c(\"down\", \"up\", \"downup\", \"updown\"),   max_fill = NULL )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_fill_missing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fill in missing values with the previous or following value — vec_fill_missing","text":"x vector direction Direction fill missing values. Must either \"\", \"\", \"downup\", \"updown\". max_fill single positive integer specifying maximum number sequential missing values filled. NULL, limit.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_fill_missing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fill in missing values with the previous or following value — vec_fill_missing","text":"","code":"x <- c(NA, NA, 1, NA, NA, NA, 3, NA, NA)  # Filling down replaces missing values with the previous non-missing value vec_fill_missing(x, direction = \"down\") #> [1] NA NA  1  1  1  1  3  3  3  # To also fill leading missing values, use `\"downup\"` vec_fill_missing(x, direction = \"downup\") #> [1] 1 1 1 1 1 1 3 3 3  # Limit the number of sequential missing values to fill with `max_fill` vec_fill_missing(x, max_fill = 1) #> [1] NA NA  1  1 NA NA  3  3 NA  # Data frames are filled rowwise. Rows are only considered missing # if all elements of that row are missing. y <- c(1, NA, 2, NA, NA, 3, 4, NA, 5) df <- data_frame(x = x, y = y) df #> # A tibble: 9 × 2 #>       x     y #>   <dbl> <dbl> #> 1    NA     1 #> 2    NA    NA #> 3     1     2 #> 4    NA    NA #> 5    NA    NA #> 6    NA     3 #> 7     3     4 #> 8    NA    NA #> 9    NA     5  vec_fill_missing(df) #> # A tibble: 9 × 2 #>       x     y #>   <dbl> <dbl> #> 1    NA     1 #> 2    NA     1 #> 3     1     2 #> 4     1     2 #> 5     1     2 #> 6    NA     3 #> 7     3     4 #> 8     3     4 #> 9    NA     5"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_group.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify groups — vec_group","title":"Identify groups — vec_group","text":"vec_group_id() returns identifier group element x falls , constructed order appear. number groups also returned attribute, n. vec_group_loc() returns data frame containing key column unique groups, loc column locations group x. vec_group_rle() locates groups x returns run length encoded order appear. return value rcrd object fields group identifiers run length corresponding group. number groups also returned attribute, n.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify groups — vec_group","text":"","code":"vec_group_id(x)  vec_group_loc(x)  vec_group_rle(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify groups — vec_group","text":"x vector","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify groups — vec_group","text":"vec_group_id(): integer vector size x. vec_group_loc(): two column data frame size equal vec_size(vec_unique(x)). key column type vec_ptype(x) loc column type list, elements type integer. vec_group_rle(): vctrs_group_rle rcrd object two integer vector fields: group length. Note using vec_group_loc() complex types, default data.frame print method suboptimal, want coerce tibble better understand output.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_group.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Identify groups — vec_group","text":"vec_proxy_equal()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_group.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify groups — vec_group","text":"","code":"purrr <- c(\"p\", \"u\", \"r\", \"r\", \"r\") vec_group_id(purrr) #> [1] 1 2 3 3 3 #> attr(,\"n\") #> [1] 3 vec_group_rle(purrr) #> <vctrs_group_rle[3][n = 3]> #> [1] 1x1 2x1 3x3  groups <- mtcars[c(\"vs\", \"am\")] vec_group_id(groups) #>  [1] 1 1 2 3 4 3 4 3 3 3 3 4 4 4 4 4 4 2 2 2 3 4 4 4 4 2 1 2 1 1 1 2 #> attr(,\"n\") #> [1] 4  group_rle <- vec_group_rle(groups) group_rle #> <vctrs_group_rle[16][n = 4]> #>  [1] 1x2 2x1 3x1 4x1 3x1 4x1 3x4 4x6 2x3 3x1 4x4 2x1 1x1 2x1 1x3 2x1  # Access fields with `field()` field(group_rle, \"group\") #>  [1] 1 2 3 4 3 4 3 4 2 3 4 2 1 2 1 2 field(group_rle, \"length\") #>  [1] 2 1 1 1 1 1 4 6 3 1 4 1 1 1 3 1  # `vec_group_id()` is equivalent to vec_match(groups, vec_unique(groups)) #>  [1] 1 1 2 3 4 3 4 3 3 3 3 4 4 4 4 4 4 2 2 2 3 4 4 4 4 2 1 2 1 1 1 2  vec_group_loc(mtcars$vs) #>   key #> 1   0 #> 2   1 #>                                                                  loc #> 1 1, 2, 5, 7, 12, 13, 14, 15, 16, 17, 22, 23, 24, 25, 27, 29, 30, 31 #> 2                  3, 4, 6, 8, 9, 10, 11, 18, 19, 20, 21, 26, 28, 32 vec_group_loc(mtcars[c(\"vs\", \"am\")]) #>   key.vs key.am                                          loc #> 1      0      1                         1, 2, 27, 29, 30, 31 #> 2      1      1                    3, 18, 19, 20, 26, 28, 32 #> 3      1      0                       4, 6, 8, 9, 10, 11, 21 #> 4      0      0 5, 7, 12, 13, 14, 15, 16, 17, 22, 23, 24, 25  if (require(\"tibble\")) {   as_tibble(vec_group_loc(mtcars[c(\"vs\", \"am\")])) } #> # A tibble: 4 × 2 #>   key$vs   $am loc        #>    <dbl> <dbl> <list>     #> 1      0     1 <int [6]>  #> 2      1     1 <int [7]>  #> 3      1     0 <int [7]>  #> 4      0     0 <int [12]>"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_init.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize a vector — vec_init","title":"Initialize a vector — vec_init","text":"Initialize vector","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize a vector — vec_init","text":"","code":"vec_init(x, n = 1L)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialize a vector — vec_init","text":"x Template vector initialize. n Desired size result.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_init.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Initialize a vector — vec_init","text":"vec_slice()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_init.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initialize a vector — vec_init","text":"","code":"vec_init(1:10, 3) #> [1] NA NA NA vec_init(Sys.Date(), 5) #> [1] NA NA NA NA NA  # The \"missing\" value for a data frame is a row that is entirely missing vec_init(mtcars, 2) #>      mpg cyl disp hp drat wt qsec vs am gear carb #> ...1  NA  NA   NA NA   NA NA   NA NA NA   NA   NA #> ...2  NA  NA   NA NA   NA NA   NA NA NA   NA   NA  # The \"missing\" value for a list is `NULL` vec_init(list(), 3) #> [[1]] #> NULL #>  #> [[2]] #> NULL #>  #> [[3]] #> NULL #>"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_interleave.html","id":null,"dir":"Reference","previous_headings":"","what":"Interleave many vectors into one vector — vec_interleave","title":"Interleave many vectors into one vector — vec_interleave","text":"vec_interleave() combines multiple vectors together, much like vec_c(), way elements vector interleaved together. efficient equivalent following usage vec_c():","code":"vec_interleave(x, y) == vec_c(x[1], y[1], x[2], y[2], ..., x[n], y[n])"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_interleave.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interleave many vectors into one vector — vec_interleave","text":"","code":"vec_interleave(   ...,   .ptype = NULL,   .name_spec = NULL,   .name_repair = c(\"minimal\", \"unique\", \"check_unique\", \"universal\", \"unique_quiet\",     \"universal_quiet\") )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_interleave.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interleave many vectors into one vector — vec_interleave","text":"... Vectors interleave. recycled common size. .ptype NULL, default, output type determined computing common type across elements .... Alternatively, can supply .ptype give output known type. getOption(\"vctrs.no_guessing\") TRUE must supply value: convenient way make production code demand fixed types. .name_spec name specification combining inner outer names. relevant inputs passed name, inputs named, like outer = c(inner = 1), length greater 1: outer = 1:2. default, cases trigger error. can resolve error providing specification describes combine names indices inner vector name input. specification can : function two arguments. outer name passed string first argument, inner names positions passed second argument. anonymous function purrr-style formula. glue specification form \"{outer}_{inner}\". rlang::zap() object, case outer inner names ignored result unnamed. See name specification topic. .name_repair repair names, see repair options vec_as_names().","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_interleave.html","id":"vctrs-dependencies","dir":"Reference","previous_headings":"","what":"vctrs dependencies","title":"Interleave many vectors into one vector — vec_interleave","text":"list_unchop()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_interleave.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interleave many vectors into one vector — vec_interleave","text":"","code":"# The most common case is to interleave two vectors vec_interleave(1:3, 4:6) #> [1] 1 4 2 5 3 6  # But you aren't restricted to just two vec_interleave(1:3, 4:6, 7:9, 10:12) #>  [1]  1  4  7 10  2  5  8 11  3  6  9 12  # You can also interleave data frames x <- data_frame(x = 1:2, y = c(\"a\", \"b\")) y <- data_frame(x = 3:4, y = c(\"c\", \"d\"))  vec_interleave(x, y) #> # A tibble: 4 × 2 #>       x y     #>   <int> <chr> #> 1     1 a     #> 2     3 c     #> 3     2 b     #> 4     4 d"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_is_list.html","id":null,"dir":"Reference","previous_headings":"","what":"List checks — vec_is_list","title":"List checks — vec_is_list","text":"functions deprecated vctrs 0.6.0. vec_is_list() renamed obj_is_list(). vec_check_list() renamed obj_check_list().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_is_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List checks — vec_is_list","text":"","code":"vec_is_list(x)  vec_check_list(x, ..., arg = caller_arg(x), call = caller_env())"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_is_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List checks — vec_is_list","text":"x vec_*() functions, object. list_*() functions, list. ... dots future extensions must empty. arg argument name string. argument mentioned error messages input origin problem. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_matches.html","id":null,"dir":"Reference","previous_headings":"","what":"Locate observations matching specified conditions — vec_locate_matches","title":"Locate observations matching specified conditions — vec_locate_matches","text":"vec_locate_matches() flexible version vec_match() used identify locations value needles matches one multiple values haystack. Unlike vec_match(), vec_locate_matches() returns matches default, can match binary conditions equality, >, >=, <, <=.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_matches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Locate observations matching specified conditions — vec_locate_matches","text":"","code":"vec_locate_matches(   needles,   haystack,   ...,   condition = \"==\",   filter = \"none\",   incomplete = \"compare\",   no_match = NA_integer_,   remaining = \"drop\",   multiple = \"all\",   relationship = \"none\",   nan_distinct = FALSE,   chr_proxy_collate = NULL,   needles_arg = \"needles\",   haystack_arg = \"haystack\",   error_call = current_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_matches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Locate observations matching specified conditions — vec_locate_matches","text":"needles, haystack Vectors used matching. needles represents vector search . haystack represents vector search . Prior comparison, needles haystack coerced type. ... dots future extensions must empty. condition Condition controlling needles compared haystack identify successful match. One : \"==\", \">\", \">=\", \"<\", \"<=\". data frames, length 1 ncol(needles) character vector containing options, specifying matching determined column. filter Filter applied matched results. \"none\" apply filter. \"min\" returns minimum haystack value matching current needle. \"max\" returns maximum haystack value matching current needle. data frames, length 1 ncol(needles) character vector containing options, specifying filter apply column. Filters effect \"==\" conditions, useful computing \"rolling\" matches conditions. filter can return multiple haystack matches particular needle maximum minimum haystack value duplicated haystack. can controlled multiple. incomplete Handling missing incomplete values needles. \"compare\" uses condition determine whether missing value needles matches missing value haystack. condition ==, >=, <=, missing values match. \"match\" always allows missing values needles match missing values haystack, regardless condition. \"drop\" drops incomplete values needles result. \"error\" throws error needles incomplete. single integer provided, represents value returned haystack column values needles incomplete. no_match = NA, setting incomplete = NA forces incomplete values needles treated like unmatched values. nan_distinct determines whether NA allowed match NaN. no_match Handling needles without match. \"drop\" drops needles zero matches result. \"error\" throws error needles zero matches. single integer provided, represents value returned haystack column values needles zero matches. default represents unmatched needle NA. remaining Handling haystack values needles never matched. \"drop\" drops remaining haystack values result. Typically, desired behavior care needles match. \"error\" throws error remaining haystack values. single integer provided (often NA), represents value returned needles column remaining haystack values needles never matched. Remaining haystack values always returned end result. multiple Handling needles multiple matches. needle: \"\" returns matches detected haystack. \"\" returns match detected haystack guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected haystack. \"last\" returns last match detected haystack. relationship Handling expected relationship needles haystack. expectations chosen list invalidated, error thrown. \"none\" perform relationship checks. \"one--one\" expects: value needles matches 1 value haystack. value haystack matches 1 value needles. \"one--many\" expects: value needles matches number values haystack. value haystack matches 1 value needles. \"many--one\" expects: value needles matches 1 value haystack. value haystack matches number values needles. \"many--many\" expects: value needles matches number values haystack. value haystack matches number values needles. performs checks, identical \"none\", provided allow explicit relationship know exists. \"warn-many--many\" assume known relationship, warn needles haystack many--many relationship (typically unexpected), encouraging either take closer look inputs make relationship explicit specifying \"many--many\". relationship applied filter multiple allow potential multiple matches filtered first. relationship handle cases zero matches. , see no_match remaining. nan_distinct single logical specifying whether NaN considered distinct NA double complex vectors. TRUE, NaN always ordered NA non-missing numbers. chr_proxy_collate function generating alternate representation character vectors use collation, often used locale-aware ordering. NULL, transformation done. Otherwise, must function one argument. input contains character vector, passed function translated UTF-8. function return character vector length input. result sort expected C-locale, regardless encoding. data frames, chr_proxy_collate applied character columns. Common transformation functions include: tolower() case-insensitive ordering stringi::stri_sort_key() locale-aware ordering. needles_arg, haystack_arg Argument tags needles haystack used error messages. error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_matches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Locate observations matching specified conditions — vec_locate_matches","text":"two column data frame containing locations matches. needles integer vector containing location needle currently matched. haystack integer vector containing location corresponding match haystack current needle.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_matches.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Locate observations matching specified conditions — vec_locate_matches","text":"vec_match() identical (often slightly faster ):   vec_locate_matches() extremely similar SQL join needles haystack, default similar left join. careful specifying match conditions. condition misspecified, easy accidentally generate exponentially large number matches.","code":"vec_locate_matches(   needles,   haystack,   condition = \"==\",   multiple = \"first\",   nan_distinct = TRUE )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_matches.html","id":"dependencies-of-vec-locate-matches-","dir":"Reference","previous_headings":"","what":"Dependencies of vec_locate_matches()","title":"Locate observations matching specified conditions — vec_locate_matches","text":"vec_order_radix() vec_detect_complete()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_matches.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Locate observations matching specified conditions — vec_locate_matches","text":"","code":"x <- c(1, 2, NA, 3, NaN) y <- c(2, 1, 4, NA, 1, 2, NaN)  # By default, for each value of `x`, all matching locations in `y` are # returned matches <- vec_locate_matches(x, y) matches #>   needles haystack #> 1       1        2 #> 2       1        5 #> 3       2        1 #> 4       2        6 #> 5       3        4 #> 6       3        7 #> 7       4       NA #> 8       5        4 #> 9       5        7  # The result can be used to slice the inputs to align them data_frame(   x = vec_slice(x, matches$needles),   y = vec_slice(y, matches$haystack) ) #> # A tibble: 9 × 2 #>       x     y #>   <dbl> <dbl> #> 1     1     1 #> 2     1     1 #> 3     2     2 #> 4     2     2 #> 5    NA    NA #> 6    NA   NaN #> 7     3    NA #> 8   NaN    NA #> 9   NaN   NaN  # If multiple matches are present, control which is returned with `multiple` vec_locate_matches(x, y, multiple = \"first\") #>   needles haystack #> 1       1        2 #> 2       2        1 #> 3       3        4 #> 4       4       NA #> 5       5        4 vec_locate_matches(x, y, multiple = \"last\") #>   needles haystack #> 1       1        5 #> 2       2        6 #> 3       3        7 #> 4       4       NA #> 5       5        7 vec_locate_matches(x, y, multiple = \"any\") #>   needles haystack #> 1       1        2 #> 2       2        1 #> 3       3        4 #> 4       4       NA #> 5       5        4  # Use `relationship` to add constraints and error on multiple matches if # they aren't expected try(vec_locate_matches(x, y, relationship = \"one-to-one\")) #> Error in vec_locate_matches(x, y, relationship = \"one-to-one\") :  #>   Each value of `needles` can match at most 1 value from `haystack`. #> ✖ Location 1 of `needles` matches multiple values.  # In this case, the `NA` in `y` matches two rows in `x` try(vec_locate_matches(x, y, relationship = \"one-to-many\")) #> Error in vec_locate_matches(x, y, relationship = \"one-to-many\") :  #>   Each value of `haystack` can match at most 1 value from `needles`. #> ✖ Location 4 of `haystack` matches multiple values.  # By default, `NA` is treated as being identical to `NaN`. # Using `nan_distinct = TRUE` treats `NA` and `NaN` as different values, so # `NA` can only match `NA`, and `NaN` can only match `NaN`. vec_locate_matches(x, y, nan_distinct = TRUE) #>   needles haystack #> 1       1        2 #> 2       1        5 #> 3       2        1 #> 4       2        6 #> 5       3        4 #> 6       4       NA #> 7       5        7  # If you never want missing values to match, set `incomplete = NA` to return # `NA` in the `haystack` column anytime there was an incomplete value # in `needles`. vec_locate_matches(x, y, incomplete = NA) #>   needles haystack #> 1       1        2 #> 2       1        5 #> 3       2        1 #> 4       2        6 #> 5       3       NA #> 6       4       NA #> 7       5       NA  # Using `incomplete = NA` allows us to enforce the one-to-many relationship # that we couldn't before vec_locate_matches(x, y, relationship = \"one-to-many\", incomplete = NA) #>   needles haystack #> 1       1        2 #> 2       1        5 #> 3       2        1 #> 4       2        6 #> 5       3       NA #> 6       4       NA #> 7       5       NA  # `no_match` allows you to specify the returned value for a needle with # zero matches. Note that this is different from an incomplete value, # so specifying `no_match` allows you to differentiate between incomplete # values and unmatched values. vec_locate_matches(x, y, incomplete = NA, no_match = 0L) #>   needles haystack #> 1       1        2 #> 2       1        5 #> 3       2        1 #> 4       2        6 #> 5       3       NA #> 6       4        0 #> 7       5       NA  # If you want to require that every `needle` has at least 1 match, set # `no_match` to `\"error\"`: try(vec_locate_matches(x, y, incomplete = NA, no_match = \"error\")) #> Error in vec_locate_matches(x, y, incomplete = NA, no_match = \"error\") :  #>   Each value of `needles` must have a match in `haystack`. #> ✖ Location 4 of `needles` does not have a match.  # By default, `vec_locate_matches()` detects equality between `needles` and # `haystack`. Using `condition`, you can detect where an inequality holds # true instead. For example, to find every location where `x[[i]] >= y`: matches <- vec_locate_matches(x, y, condition = \">=\")  data_frame(   x = vec_slice(x, matches$needles),   y = vec_slice(y, matches$haystack) ) #> # A tibble: 14 × 2 #>        x     y #>    <dbl> <dbl> #>  1     1     1 #>  2     1     1 #>  3     2     2 #>  4     2     1 #>  5     2     1 #>  6     2     2 #>  7    NA    NA #>  8    NA   NaN #>  9     3     2 #> 10     3     1 #> 11     3     1 #> 12     3     2 #> 13   NaN    NA #> 14   NaN   NaN  # You can limit which matches are returned with a `filter`. For example, # with the above example you can filter the matches returned by `x[[i]] >= y` # down to only the ones containing the maximum `y` value of those matches. matches <- vec_locate_matches(x, y, condition = \">=\", filter = \"max\")  # Here, the matches for the `3` needle value have been filtered down to # only include the maximum haystack value of those matches, `2`. This is # often referred to as a rolling join. data_frame(   x = vec_slice(x, matches$needles),   y = vec_slice(y, matches$haystack) ) #> # A tibble: 10 × 2 #>        x     y #>    <dbl> <dbl> #>  1     1     1 #>  2     1     1 #>  3     2     2 #>  4     2     2 #>  5    NA    NA #>  6    NA   NaN #>  7     3     2 #>  8     3     2 #>  9   NaN    NA #> 10   NaN   NaN  # In the very rare case that you need to generate locations for a # cross match, where every value of `x` is forced to match every # value of `y` regardless of what the actual values are, you can # replace `x` and `y` with integer vectors of the same size that contain # a single value and match on those instead. x_proxy <- vec_rep(1L, vec_size(x)) y_proxy <- vec_rep(1L, vec_size(y)) nrow(vec_locate_matches(x_proxy, y_proxy)) #> [1] 35 vec_size(x) * vec_size(y) #> [1] 35  # By default, missing values will match other missing values when using # `==`, `>=`, or `<=` conditions, but not when using `>` or `<` conditions. # This is similar to how `vec_compare(x, y, na_equal = TRUE)` works. x <- c(1, NA) y <- c(NA, 2)  vec_locate_matches(x, y, condition = \"<=\") #>   needles haystack #> 1       1        2 #> 2       2        1 vec_locate_matches(x, y, condition = \"<\") #>   needles haystack #> 1       1        2 #> 2       2       NA  # You can force missing values to match regardless of the `condition` # by using `incomplete = \"match\"` vec_locate_matches(x, y, condition = \"<\", incomplete = \"match\") #>   needles haystack #> 1       1        2 #> 2       2        1  # You can also use data frames for `needles` and `haystack`. The # `condition` will be recycled to the number of columns in `needles`, or # you can specify varying conditions per column. In this example, we take # a vector of date `values` and find all locations where each value is # between lower and upper bounds specified by the `haystack`. values <- as.Date(\"2019-01-01\") + 0:9 needles <- data_frame(lower = values, upper = values)  set.seed(123) lower <- as.Date(\"2019-01-01\") + sample(10, 10, replace = TRUE) upper <- lower + sample(3, 10, replace = TRUE) haystack <- data_frame(lower = lower, upper = upper)  # (values >= lower) & (values <= upper) matches <- vec_locate_matches(needles, haystack, condition = c(\">=\", \"<=\"))  data_frame(   lower = vec_slice(lower, matches$haystack),   value = vec_slice(values, matches$needle),   upper = vec_slice(upper, matches$haystack) ) #> # A tibble: 22 × 3 #>    lower      value      upper      #>    <date>     <date>     <date>     #>  1 NA         2019-01-01 NA         #>  2 NA         2019-01-02 NA         #>  3 2019-01-03 2019-01-03 2019-01-06 #>  4 2019-01-04 2019-01-04 2019-01-07 #>  5 2019-01-04 2019-01-04 2019-01-05 #>  6 2019-01-03 2019-01-04 2019-01-06 #>  7 2019-01-04 2019-01-05 2019-01-07 #>  8 2019-01-04 2019-01-05 2019-01-05 #>  9 2019-01-03 2019-01-05 2019-01-06 #> 10 2019-01-05 2019-01-05 2019-01-06 #> # ℹ 12 more rows"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_sorted_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Locate sorted groups — vec_locate_sorted_groups","title":"Locate sorted groups — vec_locate_sorted_groups","text":"vec_locate_sorted_groups() returns data frame containing key column sorted unique groups, loc column locations group x. similar vec_group_loc(), except groups returned sorted rather first appearance.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_sorted_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Locate sorted groups — vec_locate_sorted_groups","text":"","code":"vec_locate_sorted_groups(   x,   ...,   direction = \"asc\",   na_value = \"largest\",   nan_distinct = FALSE,   chr_proxy_collate = NULL )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_sorted_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Locate sorted groups — vec_locate_sorted_groups","text":"x vector ... dots future extensions must empty. direction Direction sort . single \"asc\" \"desc\" ascending descending order respectively. data frames, length 1 ncol(x) character vector containing \"asc\" \"desc\", specifying direction column. na_value Ordering missing values. single \"largest\" \"smallest\" ordering missing values largest smallest values respectively. data frames, length 1 ncol(x) character vector containing \"largest\" \"smallest\", specifying missing values ordered within column. nan_distinct single logical specifying whether NaN considered distinct NA double complex vectors. TRUE, NaN always ordered NA non-missing numbers. chr_proxy_collate function generating alternate representation character vectors use collation, often used locale-aware ordering. NULL, transformation done. Otherwise, must function one argument. input contains character vector, passed function translated UTF-8. function return character vector length input. result sort expected C-locale, regardless encoding. data frames, chr_proxy_collate applied character columns. Common transformation functions include: tolower() case-insensitive ordering stringi::stri_sort_key() locale-aware ordering.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_sorted_groups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Locate sorted groups — vec_locate_sorted_groups","text":"two column data frame size equal vec_size(vec_unique(x)). key column type vec_ptype(x). loc column type list, elements type integer.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_sorted_groups.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Locate sorted groups — vec_locate_sorted_groups","text":"vec_locate_sorted_groups(x) equivalent , faster :","code":"info <- vec_group_loc(x) vec_slice(info, vec_order(info$key))"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_sorted_groups.html","id":"dependencies-of-vec-locate-sorted-groups-","dir":"Reference","previous_headings":"","what":"Dependencies of vec_locate_sorted_groups()","title":"Locate sorted groups — vec_locate_sorted_groups","text":"vec_proxy_order()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_locate_sorted_groups.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Locate sorted groups — vec_locate_sorted_groups","text":"","code":"df <- data.frame(   g = sample(2, 10, replace = TRUE),   x = c(NA, sample(5, 9, replace = TRUE)) )  # `vec_locate_sorted_groups()` is similar to `vec_group_loc()`, except keys # are returned ordered rather than by first appearance. vec_locate_sorted_groups(df) #>   key.g key.x  loc #> 1     1     2    6 #> 2     1     3    7 #> 3     1     4    8 #> 4     1     5 3, 9 #> 5     1    NA    1 #> 6     2     1 4, 5 #> 7     2     2    2 #> 8     2     5   10  vec_group_loc(df) #>   key.g key.x  loc #> 1     1    NA    1 #> 2     2     2    2 #> 3     1     5 3, 9 #> 4     2     1 4, 5 #> 5     1     2    6 #> 6     1     3    7 #> 7     1     4    8 #> 8     2     5   10"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Find matching observations across vectors — vec_match","title":"Find matching observations across vectors — vec_match","text":"vec_in() returns logical vector based whether needle found haystack. vec_match() returns integer vector giving location needle haystack, NA found.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find matching observations across vectors — vec_match","text":"","code":"vec_match(   needles,   haystack,   ...,   na_equal = TRUE,   needles_arg = \"\",   haystack_arg = \"\" )  vec_in(   needles,   haystack,   ...,   na_equal = TRUE,   needles_arg = \"\",   haystack_arg = \"\" )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find matching observations across vectors — vec_match","text":"needles, haystack Vector needles search vector haystack. haystack usually unique; vec_match() return location first match. needles haystack coerced type prior comparison. ... dots future extensions must empty. na_equal TRUE, missing values needles can matched missing values haystack. FALSE, propagate, missing values needles represented NA return value. needles_arg, haystack_arg Argument tags needles haystack used error messages.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find matching observations across vectors — vec_match","text":"vector length needles. vec_in() returns logical vector; vec_match() returns integer vector.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_match.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find matching observations across vectors — vec_match","text":"vec_in() equivalent %%; vec_match() equivalent match().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_match.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing values","title":"Find matching observations across vectors — vec_match","text":"cases places R, missing values considered equal, .e. NA == NA TRUE. exception matching functions like match() merge(), NA match another NA. vec_match() vec_in() match NAs; can control behaviour na_equal argument.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_match.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Find matching observations across vectors — vec_match","text":"vec_cast_common() fallback vec_proxy_equal()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find matching observations across vectors — vec_match","text":"","code":"hadley <- strsplit(\"hadley\", \"\")[[1]] vec_match(hadley, letters) #> [1]  8  1  4 12  5 25  vowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\") vec_match(hadley, vowels) #> [1] NA  1 NA NA  2 NA vec_in(hadley, vowels) #> [1] FALSE  TRUE FALSE FALSE  TRUE FALSE  # Only the first index of duplicates is returned vec_match(c(\"a\", \"b\"), c(\"a\", \"b\", \"a\", \"b\")) #> [1] 1 2"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_math.html","id":null,"dir":"Reference","previous_headings":"","what":"Mathematical operations — vec_math","title":"Mathematical operations — vec_math","text":"generic provides common dispatch mechanism regular unary mathematical functions. used common wrapper around many Summary group generics, Math group generics, handful mathematical functions like mean() (var() sd()).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_math.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mathematical operations — vec_math","text":"","code":"vec_math(.fn, .x, ...)  vec_math_base(.fn, .x, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_math.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mathematical operations — vec_math","text":".fn mathematical function base package, string. .x vector. ... Additional arguments passed .fn.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_math.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Mathematical operations — vec_math","text":"vec_math_base() provided convenience writing methods. calls base .fn underlying vec_data().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_math.html","id":"included-functions","dir":"Reference","previous_headings":"","what":"Included functions","title":"Mathematical operations — vec_math","text":"Summary group generic: prod(), sum(), (), (). Math group generic: abs(), sign(), sqrt(), ceiling(), floor(), trunc(), cummax(), cummin(), cumprod(), cumsum(), log(), log10(), log2(), log1p(), acos(), acosh(), asin(), asinh(), atan(), atanh(), exp(), expm1(), cos(), cosh(), cospi(), sin(), sinh(), sinpi(), tan(), tanh(), tanpi(), gamma(), lgamma(), digamma(), trigamma(). Additional generics: mean(), .nan(), .finite(), .infinite(). Note median() currently implemented, sd() var() currently generic support custom classes.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_math.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mathematical operations — vec_math","text":"","code":"x <- new_vctr(c(1, 2.5, 10)) x #> <vctrs_vctr[3]> #> [1]  1.0  2.5 10.0  abs(x) #> <vctrs_vctr[3]> #> [1]  1.0  2.5 10.0 sum(x) #> <vctrs_vctr[1]> #> [1] 13.5 cumsum(x) #> <vctrs_vctr[3]> #> [1]  1.0  3.5 13.5"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set the names of a vector — vec_names","title":"Get or set the names of a vector — vec_names","text":"functions work like rlang::names2(), names() names<-(), except return modify rowwise names vector. : usual names() atomic vectors lists row names data frames matrices names first dimension arrays Rowwise names size consistent: length names always equals vec_size(). vec_names2() returns repaired names vector, even unnamed. See vec_as_names() details name repair. vec_names() bare-bones version returns NULL vector unnamed. vec_set_names() sets names removes .","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set the names of a vector — vec_names","text":"","code":"vec_names2(   x,   ...,   repair = c(\"minimal\", \"unique\", \"universal\", \"check_unique\", \"unique_quiet\",     \"universal_quiet\"),   quiet = FALSE )  vec_names(x)  vec_set_names(x, names)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set the names of a vector — vec_names","text":"x vector names ... dots future extensions must empty. repair Either string function. string, must one \"check_unique\", \"minimal\", \"unique\", \"universal\", \"unique_quiet\", \"universal_quiet\". function, invoked vector minimal names must return minimal names, otherwise error thrown. Minimal names never NULL NA. element name, minimal name empty string. Unique names unique. suffix appended duplicate names make unique. Universal names unique syntactic, meaning can safely use names variables without causing syntax error. \"check_unique\" option perform name repair. Instead, error raised names suit \"unique\" criteria. options \"unique_quiet\" \"universal_quiet\" help user calls function indirectly, via another function exposes repair quiet. Specifying repair = \"unique_quiet\" like specifying repair = \"unique\", quiet = TRUE. \"*_quiet\" options used, setting quiet silently overridden. quiet default, user informed renaming caused repairing names. concerns unique universal repairing. Set quiet TRUE silence messages. Users can silence name repair messages setting \"rlib_name_repair_verbosity\" global option \"quiet\". names character vector, NULL.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set the names of a vector — vec_names","text":"vec_names2() returns names x, repaired. vec_names() returns names x NULL unnamed. vec_set_names() returns x names updated.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or set the names of a vector — vec_names","text":"","code":"vec_names2(1:3) #> [1] \"\" \"\" \"\" vec_names2(1:3, repair = \"unique\") #> New names: #> • `` -> `...1` #> • `` -> `...2` #> • `` -> `...3` #> [1] \"...1\" \"...2\" \"...3\" vec_names2(c(a = 1, b = 2)) #> [1] \"a\" \"b\"  # `vec_names()` consistently returns the rowwise names of data frames and arrays: vec_names(data.frame(a = 1, b = 2)) #> NULL names(data.frame(a = 1, b = 2)) #> [1] \"a\" \"b\" vec_names(mtcars) #>  [1] \"Mazda RX4\"           \"Mazda RX4 Wag\"       \"Datsun 710\"          #>  [4] \"Hornet 4 Drive\"      \"Hornet Sportabout\"   \"Valiant\"             #>  [7] \"Duster 360\"          \"Merc 240D\"           \"Merc 230\"            #> [10] \"Merc 280\"            \"Merc 280C\"           \"Merc 450SE\"          #> [13] \"Merc 450SL\"          \"Merc 450SLC\"         \"Cadillac Fleetwood\"  #> [16] \"Lincoln Continental\" \"Chrysler Imperial\"   \"Fiat 128\"            #> [19] \"Honda Civic\"         \"Toyota Corolla\"      \"Toyota Corona\"       #> [22] \"Dodge Challenger\"    \"AMC Javelin\"         \"Camaro Z28\"          #> [25] \"Pontiac Firebird\"    \"Fiat X1-9\"           \"Porsche 914-2\"       #> [28] \"Lotus Europa\"        \"Ford Pantera L\"      \"Ferrari Dino\"        #> [31] \"Maserati Bora\"       \"Volvo 142E\"          names(mtcars) #>  [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   #> [10] \"gear\" \"carb\" vec_names(Titanic) #> [1] \"1st\"  \"2nd\"  \"3rd\"  \"Crew\" names(Titanic) #> NULL  vec_set_names(1:3, letters[1:3]) #> a b c  #> 1 2 3  vec_set_names(data.frame(a = 1:3), letters[1:3]) #>   a #> a 1 #> b 2 #> c 3"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_order.html","id":null,"dir":"Reference","previous_headings":"","what":"Order and sort vectors — vec_order","title":"Order and sort vectors — vec_order","text":"Order sort vectors","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Order and sort vectors — vec_order","text":"","code":"vec_order(   x,   ...,   direction = c(\"asc\", \"desc\"),   na_value = c(\"largest\", \"smallest\") )  vec_sort(   x,   ...,   direction = c(\"asc\", \"desc\"),   na_value = c(\"largest\", \"smallest\") )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Order and sort vectors — vec_order","text":"x vector ... dots future extensions must empty. direction Direction sort . Defaults ascending. na_value NAs treated largest smallest values?","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Order and sort vectors — vec_order","text":"vec_order() integer vector size x. vec_sort() vector size type x.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_order.html","id":"differences-with-order-","dir":"Reference","previous_headings":"","what":"Differences with order()","title":"Order and sort vectors — vec_order","text":"Unlike na.last argument order() decides positions missing values irrespective decreasing argument, na_value argument vec_order() interacts direction. missing values considered largest value, appear last ascending order, first descending order.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_order.html","id":"dependencies-of-vec-order-","dir":"Reference","previous_headings":"","what":"Dependencies of vec_order()","title":"Order and sort vectors — vec_order","text":"vec_proxy_order()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_order.html","id":"dependencies-of-vec-sort-","dir":"Reference","previous_headings":"","what":"Dependencies of vec_sort()","title":"Order and sort vectors — vec_order","text":"vec_proxy_order() vec_order() vec_slice()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_order.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Order and sort vectors — vec_order","text":"","code":"x <- round(c(runif(9), NA), 3) vec_order(x) #>  [1]  2  1  8  4  9  7  5  6  3 10 vec_sort(x) #>  [1] 0.274 0.384 0.440 0.449 0.754 0.794 0.810 0.812 0.815    NA vec_sort(x, direction = \"desc\") #>  [1]    NA 0.815 0.812 0.810 0.794 0.754 0.449 0.440 0.384 0.274  # Can also handle data frames df <- data.frame(g = sample(2, 10, replace = TRUE), x = x) vec_order(df) #>  [1]  2  1  4  7  3  8  9  5  6 10 vec_sort(df) #>    g     x #> 1  1 0.274 #> 2  1 0.384 #> 3  1 0.449 #> 4  1 0.794 #> 5  1 0.815 #> 6  2 0.440 #> 7  2 0.754 #> 8  2 0.810 #> 9  2 0.812 #> 10 2    NA vec_sort(df, direction = \"desc\") #>    g     x #> 1  2    NA #> 2  2 0.812 #> 3  2 0.810 #> 4  2 0.754 #> 5  2 0.440 #> 6  1 0.815 #> 7  1 0.794 #> 8  1 0.449 #> 9  1 0.384 #> 10 1 0.274  # Missing values interpreted as largest values are last when # in increasing order: vec_order(c(1, NA), na_value = \"largest\", direction = \"asc\") #> [1] 1 2 vec_order(c(1, NA), na_value = \"largest\", direction = \"desc\") #> [1] 2 1"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy.html","id":null,"dir":"Reference","previous_headings":"","what":"Proxy and restore — vec_proxy","title":"Proxy and restore — vec_proxy","text":"vec_proxy() returns data structure containing values vector. data structure usually vector . case proxy identity function, default vec_proxy() method. experts implement special vec_proxy() methods, cases: vector vectorised attributes, .e. metadata element vector. record types implemented vctrs returning data frame proxy method. starting class scratch, consider deriving rcrd class. implements appropriate data frame proxy generally preferred way create record class. implementing vector top non-vector type, like environment S4 object. currently partially supported. S3 lists considered scalars default. safe choice list objects returned stats::lm(). declare S3 list class vector, normally add \"list\" right class vector. Explicit inheritance list generally preferred way declare S3 list R, instance makes possible dispatch generic.list S3 methods. modify class vector, can implement identity proxy (.e. proxy method just returns input) let vctrs know vector list scalar. vec_restore() inverse operation vec_proxy(). called vector proxies. undoes transformations vec_proxy(). restores attributes classes. may lost memory values manipulated. example slicing subset vector's proxy causes new proxy allocated. default vctrs restores attributes classes automatically. need implement vec_restore() method class attributes depend data.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proxy and restore — vec_proxy","text":"","code":"vec_proxy(x, ...)  vec_restore(x, to, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Proxy and restore — vec_proxy","text":"x vector. ... dots future extensions must empty. original vector restore .","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy.html","id":"proxying","dir":"Reference","previous_headings":"","what":"Proxying","title":"Proxy and restore — vec_proxy","text":"implement vec_proxy() type designed around non-vector class. .e. anything either: atomic vector bare list data frame case, implement vec_proxy() return vector class. vctrs operations vec_slice() applied proxy vec_restore() called restore original representation type. common case need implement vec_proxy() S3 lists. vctrs, S3 lists treated scalars default. way treat objects like model fits vectors. prevent vctrs treating S3 list scalar, unclass vec_proxy() method. instance, definition list_of:   Another case need implement proxy record types. Record types return data frame, POSIXlt method:   Note need implement vec_proxy() class inherits vctrs_vctr vctrs_rcrd.","code":"vec_proxy.vctrs_list_of <- function(x) {   unclass(x) } vec_proxy.POSIXlt <- function(x) {   new_data_frame(unclass(x)) }"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy.html","id":"restoring","dir":"Reference","previous_headings":"","what":"Restoring","title":"Proxy and restore — vec_proxy","text":"restore specialised type cast, primarily used conjunction NextMethod() C-level function works underlying data structure. vec_restore() method can make following assumptions x: correct type. correct names. correct dim dimnames attributes. unclassed. way can call vctrs generics x without triggering infinite loop restoration. length may different (example vec_slice() called), attributes may lost. method restore attributes restoration, vec_restore(vec_data(x), x) yields x. understand difference vec_cast() vec_restore() think factors: make sense cast integer factor, NextMethod() another low-level function stripped attributes, still need able restore . default method copies across attributes need provide method attributes require special care (.e. dependent data way). implementing method, bear mind many R users add attributes track additional metadata important , preserve attributes require special handling class.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Proxy and restore — vec_proxy","text":"x must vector vctrs sense (see vec_is()) default underlying data returned (identity proxy) vector classes proxy, even implement vctrs methods. exception S3 lists inherit \"list\" explicitly. might implement identity proxy compatibility vctrs (see discussion ).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_compare.html","id":null,"dir":"Reference","previous_headings":"","what":"Comparison and order proxy — vec_proxy_compare","title":"Comparison and order proxy — vec_proxy_compare","text":"vec_proxy_compare() vec_proxy_order() return proxy objects, .e. atomic vector data frame atomic vectors. vctrs_vctr objects: vec_proxy_compare() determines behavior <, >, >= <= (via vec_compare()); min(), max(), median(), quantile(). vec_proxy_order() determines behavior order() sort() (via xtfrm()).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_compare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Comparison and order proxy — vec_proxy_compare","text":"","code":"vec_proxy_compare(x, ...)  vec_proxy_order(x, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_compare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Comparison and order proxy — vec_proxy_compare","text":"x vector x. ... dots future extensions must empty.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_compare.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Comparison and order proxy — vec_proxy_compare","text":"1d atomic vector data frame.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_compare.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Comparison and order proxy — vec_proxy_compare","text":"default method vec_proxy_compare() assumes classes built top atomic vectors records comparable. Internally default calls vec_proxy_equal(). class comparable, need provide vec_proxy_compare() method throws error. behavior vec_proxy_order() identical vec_proxy_compare(), exception lists. Lists comparable, comparing elements different types undefined. However, allow ordering data frames containing list-columns, ordering proxy list generated integer vector can used order list elements first appearance. class implements vec_proxy_compare() method, usually need provide vec_proxy_order() method, latter implemented forwarding vec_proxy_compare() default. Classes inheriting list exception: due default vec_proxy_order() implementation, vec_proxy_compare() vec_proxy_order() provided classes (identical implementations) avoid mismatches comparison sorting.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_compare.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Comparison and order proxy — vec_proxy_compare","text":"vec_proxy_equal() called default vec_proxy_compare() vec_proxy_compare() called default vec_proxy_order()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_compare.html","id":"data-frames","dir":"Reference","previous_headings":"","what":"Data frames","title":"Comparison and order proxy — vec_proxy_compare","text":"proxy x data frame, proxy function automatically recursively applied columns well. applying proxy recursively, data frame columns present proxy, unpacked. Finally, resulting data frame single column, unwrapped vector returned proxy.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_compare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Comparison and order proxy — vec_proxy_compare","text":"","code":"# Lists are not comparable x <- list(1:2, 1, 1:2, 3) try(vec_compare(x, x)) #> Error in vec_proxy_compare(x = x) :  #>   `vec_proxy_compare.list()` not supported.  # But lists are orderable by first appearance to allow for # ordering data frames with list-cols df <- new_data_frame(list(x = x)) vec_sort(df) #>      x #> 1 1, 2 #> 2 1, 2 #> 3    1 #> 4    3"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"Equality proxy — vec_proxy_equal","title":"Equality proxy — vec_proxy_equal","text":"Returns proxy object (.e. atomic vector data frame atomic vectors). vctrs, determines behaviour == != (via vec_equal()); unique(), duplicated() (via vec_unique() vec_duplicate_detect()); .na() anyNA() (via vec_detect_missing()).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Equality proxy — vec_proxy_equal","text":"","code":"vec_proxy_equal(x, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Equality proxy — vec_proxy_equal","text":"x vector x. ... dots future extensions must empty.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Equality proxy — vec_proxy_equal","text":"1d atomic vector data frame.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_equal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Equality proxy — vec_proxy_equal","text":"default method calls vec_proxy(), default underlying vector data equal-able cases. class equal-able, provide vec_proxy_equal() method throws error.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_equal.html","id":"data-frames","dir":"Reference","previous_headings":"","what":"Data frames","title":"Equality proxy — vec_proxy_equal","text":"proxy x data frame, proxy function automatically recursively applied columns well. applying proxy recursively, data frame columns present proxy, unpacked. Finally, resulting data frame single column, unwrapped vector returned proxy.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_proxy_equal.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Equality proxy — vec_proxy_equal","text":"vec_proxy() called default","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the prototype of a set of vectors — vec_ptype","title":"Find the prototype of a set of vectors — vec_ptype","text":"vec_ptype() returns unfinalised prototype single vector. vec_ptype_common() finds common type multiple vectors. vec_ptype_show() nicely prints common type number inputs, designed interactive exploration.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the prototype of a set of vectors — vec_ptype","text":"","code":"vec_ptype(x, ..., x_arg = \"\", call = caller_env())  vec_ptype_common(..., .ptype = NULL, .arg = \"\", .call = caller_env())  vec_ptype_show(...)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the prototype of a set of vectors — vec_ptype","text":"x vector ... vec_ptype(), dots future extensions must empty. vec_ptype_common() vec_ptype_show(), vector inputs. x_arg Argument name x. used error messages inform user locations incompatible types. call, .call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. .ptype NULL, default, output type determined computing common type across elements .... Alternatively, can supply .ptype give output known type. getOption(\"vctrs.no_guessing\") TRUE must supply value: convenient way make production code demand fixed types. .arg argument name string. argument mentioned error messages input origin problem.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the prototype of a set of vectors — vec_ptype","text":"vec_ptype() vec_ptype_common() return prototype (size-0 vector)","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype.html","id":"vec-ptype-","dir":"Reference","previous_headings":"","what":"vec_ptype()","title":"Find the prototype of a set of vectors — vec_ptype","text":"vec_ptype() returns size 0 vectors potentially containing attributes data. Generally, just vec_slice(x, 0L), inputs require special handling. slice NULL, prototype NULL . treat NULL identity value vec_ptype2() monoid. prototype logical vectors contain missing values special unspecified type, can coerced 1d type. allows bare NAs represent missing values 1d vector type. See internal-faq-ptype2-identity information identity values. vec_ptype() performance generic. necessary implement default method work vctrs type. However default method builds around vctrs primitives like vec_slice() incurs performance costs. class static prototype, might consider implementing custom vec_ptype() method returns constant. improve performance class many cases (common type imputation particular). may contain unspecified vectors, prototype returned vec_ptype() said unfinalised. Call vec_ptype_finalise() finalise . Commonly need finalised prototype returned vec_slice(x, 0L).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype.html","id":"vec-ptype-common-","dir":"Reference","previous_headings":"","what":"vec_ptype_common()","title":"Find the prototype of a set of vectors — vec_ptype","text":"vec_ptype_common() first finds prototype input, successively calls vec_ptype2() find common type. returns finalised prototype.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype.html","id":"dependencies-of-vec-ptype-","dir":"Reference","previous_headings":"","what":"Dependencies of vec_ptype()","title":"Find the prototype of a set of vectors — vec_ptype","text":"vec_slice() returning empty slice","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype.html","id":"dependencies-of-vec-ptype-common-","dir":"Reference","previous_headings":"","what":"Dependencies of vec_ptype_common()","title":"Find the prototype of a set of vectors — vec_ptype","text":"vec_ptype2() vec_ptype_finalise()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the prototype of a set of vectors — vec_ptype","text":"","code":"# Unknown types ------------------------------------------ vec_ptype_show() #> Prototype: NULL vec_ptype_show(NA) #> Prototype: logical vec_ptype_show(NULL) #> Prototype: NULL  # Vectors ------------------------------------------------ vec_ptype_show(1:10) #> Prototype: integer vec_ptype_show(letters) #> Prototype: character vec_ptype_show(TRUE) #> Prototype: logical  vec_ptype_show(Sys.Date()) #> Prototype: date vec_ptype_show(Sys.time()) #> Prototype: datetime<local> vec_ptype_show(factor(\"a\")) #> Prototype: factor<4d52a> vec_ptype_show(ordered(\"a\")) #> Prototype: ordered<4d52a>  # Matrices ----------------------------------------------- # The prototype of a matrix includes the number of columns vec_ptype_show(array(1, dim = c(1, 2))) #> Prototype: double[,2] vec_ptype_show(array(\"x\", dim = c(1, 2))) #> Prototype: character[,2]  # Data frames -------------------------------------------- # The prototype of a data frame includes the prototype of # every column vec_ptype_show(iris) #> Prototype: data.frame< #>   Sepal.Length: double #>   Sepal.Width : double #>   Petal.Length: double #>   Petal.Width : double #>   Species     : factor<fb977> #> >  # The prototype of multiple data frames includes the prototype # of every column that in any data frame vec_ptype_show(   data.frame(x = TRUE),   data.frame(y = 2),   data.frame(z = \"a\") ) #> Prototype: <data.frame< #>   x: logical #>   y: double #>   z: character #> >> #> 0. (                         , <data.frame<x:logical>>   ) = <data.frame<x:logical>> #> 1. ┌ <data.frame<x:logical>> , <data.frame<y:double>>    ┐ = <data.frame<            #>    │                                                     │     x: logical            #>    │                                                     │     y: double             #>    └                                                     ┘   >>                      #> 2. ┌ <data.frame<            , <data.frame<z:character>> ┐ = <data.frame<            #>    │   x: logical                                        │     x: logical            #>    │   y: double                                         │     y: double             #>    │ >>                                                  │     z: character          #>    └                                                     ┘   >>"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype2.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the common type for a pair of vectors — vec_ptype2.logical","title":"Find the common type for a pair of vectors — vec_ptype2.logical","text":"vec_ptype2() defines coercion hierarchy set related vector types. Along vec_cast(), generic forms foundation type coercions vctrs. vec_ptype2() relevant implementing vctrs methods class, usually called directly. need find common type set inputs, call vec_ptype_common() instead. function supports multiple inputs finalises common type.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the common type for a pair of vectors — vec_ptype2.logical","text":"","code":"# S3 method for class 'logical' vec_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\")  # S3 method for class 'integer' vec_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\")  # S3 method for class 'double' vec_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\")  # S3 method for class 'complex' vec_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\")  # S3 method for class 'character' vec_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\")  # S3 method for class 'raw' vec_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\")  # S3 method for class 'list' vec_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\")  vec_ptype2(   x,   y,   ...,   x_arg = caller_arg(x),   y_arg = caller_arg(y),   call = caller_env() )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the common type for a pair of vectors — vec_ptype2.logical","text":"x, y Vector types. ... dots future extensions must empty. x_arg, y_arg Argument names x y. used error messages inform user locations incompatible types (see stop_incompatible_type()). call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype2.html","id":"implementing-coercion-methods","dir":"Reference","previous_headings":"","what":"Implementing coercion methods","title":"Find the common type for a pair of vectors — vec_ptype2.logical","text":"overview generics work roles vctrs, see ?theory-faq-coercion. example implementing coercion methods simple vectors, see ?howto-faq-coercion. example implementing coercion methods data frame subclasses, see ?howto-faq-coercion-data-frame. tutorial implementing vctrs classes scratch, see vignette(\"s3-vector\").","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype2.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Find the common type for a pair of vectors — vec_ptype2.logical","text":"vec_ptype() applied x y","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype_full.html","id":null,"dir":"Reference","previous_headings":"","what":"Vector type as a string — vec_ptype_full","title":"Vector type as a string — vec_ptype_full","text":"vec_ptype_full() displays full type vector. vec_ptype_abbr() provides abbreviated summary suitable use column heading.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype_full.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vector type as a string — vec_ptype_full","text":"","code":"vec_ptype_full(x, ...)  vec_ptype_abbr(x, ..., prefix_named = FALSE, suffix_shape = TRUE)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype_full.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vector type as a string — vec_ptype_full","text":"x vector. ... dots future extensions must empty. prefix_named TRUE, add prefix named vectors. suffix_shape TRUE (default), append shape vector.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype_full.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vector type as a string — vec_ptype_full","text":"string.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype_full.html","id":"s-dispatch","dir":"Reference","previous_headings":"","what":"S3 dispatch","title":"Vector type as a string — vec_ptype_full","text":"default method vec_ptype_full() uses first element class vector. Override method class parameters prominently displayed. default method vec_ptype_abbr() abbreviate()s vec_ptype_full() 8 characters. almost always override, aiming 4-6 characters possible. arguments handled generic passed methods: prefix_named suffix_shape","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_ptype_full.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vector type as a string — vec_ptype_full","text":"","code":"cat(vec_ptype_full(1:10)) #> integer cat(vec_ptype_full(iris)) #> data.frame< #>   Sepal.Length: double #>   Sepal.Width : double #>   Petal.Length: double #>   Petal.Width : double #>   Species     : factor<fb977> #> >  cat(vec_ptype_abbr(1:10)) #> int"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_rank.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute ranks — vec_rank","title":"Compute ranks — vec_rank","text":"vec_rank() computes sample ranks vector. data frames, ranks computed along rows, using columns first break ties.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_rank.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute ranks — vec_rank","text":"","code":"vec_rank(   x,   ...,   ties = c(\"min\", \"max\", \"sequential\", \"dense\"),   incomplete = c(\"rank\", \"na\"),   direction = \"asc\",   na_value = \"largest\",   nan_distinct = FALSE,   chr_proxy_collate = NULL )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_rank.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute ranks — vec_rank","text":"x vector ... dots future extensions must empty. ties Ranking duplicate values. \"min\": Use current rank duplicates. next non-duplicate value rank incremented number duplicates present. \"max\": Use current rank + n_duplicates - 1 duplicates. next non-duplicate value rank incremented number duplicates present. \"sequential\": Use increasing sequence ranks starting current rank, applied duplicates order appearance. \"dense\": Use current rank duplicates. next non-duplicate value rank incremented 1, effectively removing gaps ranking. incomplete Ranking missing incomplete observations. \"rank\": Rank incomplete observations normally. Missing values within incomplete observations affected na_value nan_distinct. \"na\": rank incomplete observations . Instead, given rank NA. case, na_value nan_distinct effect. direction Direction sort . single \"asc\" \"desc\" ascending descending order respectively. data frames, length 1 ncol(x) character vector containing \"asc\" \"desc\", specifying direction column. na_value Ordering missing values. single \"largest\" \"smallest\" ordering missing values largest smallest values respectively. data frames, length 1 ncol(x) character vector containing \"largest\" \"smallest\", specifying missing values ordered within column. nan_distinct single logical specifying whether NaN considered distinct NA double complex vectors. TRUE, NaN always ordered NA non-missing numbers. chr_proxy_collate function generating alternate representation character vectors use collation, often used locale-aware ordering. NULL, transformation done. Otherwise, must function one argument. input contains character vector, passed function translated UTF-8. function return character vector length input. result sort expected C-locale, regardless encoding. data frames, chr_proxy_collate applied character columns. Common transformation functions include: tolower() case-insensitive ordering stringi::stri_sort_key() locale-aware ordering.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_rank.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute ranks — vec_rank","text":"Unlike base::rank(), incomplete = \"rank\" missing values given rank, rather increasing sequence ranks. nan_distinct = FALSE, NaN values given rank NA, otherwise given rank differentiates NA. Like vec_order_radix(), ordering done C-locale. can affect ranks character vectors, especially regarding uppercase lowercase letters ranked. See documentation vec_order_radix() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_rank.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Compute ranks — vec_rank","text":"vec_order_radix() vec_slice()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_rank.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute ranks — vec_rank","text":"","code":"x <- c(5L, 6L, 3L, 3L, 5L, 3L)  vec_rank(x, ties = \"min\") #> [1] 4 6 1 1 4 1 vec_rank(x, ties = \"max\") #> [1] 5 6 3 3 5 3  # Sequential ranks use an increasing sequence for duplicates vec_rank(x, ties = \"sequential\") #> [1] 4 6 1 2 5 3  # Dense ranks remove gaps between distinct values, # even if there are duplicates vec_rank(x, ties = \"dense\") #> [1] 2 3 1 1 2 1  y <- c(NA, x, NA, NaN)  # Incomplete values match other incomplete values by default, and their # overall position can be adjusted with `na_value` vec_rank(y, na_value = \"largest\") #> [1] 7 4 6 1 1 4 1 7 7 vec_rank(y, na_value = \"smallest\") #> [1] 1 7 9 4 4 7 4 1 1  # NaN can be ranked separately from NA if required vec_rank(y, nan_distinct = TRUE) #> [1] 8 4 6 1 1 4 1 8 7  # Rank in descending order. Since missing values are the largest value, # they are given a rank of `1` when ranking in descending order. vec_rank(y, direction = \"desc\", na_value = \"largest\") #> [1] 1 5 4 7 7 5 7 1 1  # Give incomplete values a rank of `NA` by setting `incomplete = \"na\"` vec_rank(y, incomplete = \"na\") #> [1] NA  4  6  1  1  4  1 NA NA  # Can also rank data frames, using columns after the first to break ties z <- c(2L, 3L, 4L, 4L, 5L, 2L) df <- data_frame(x = x, z = z) df #> # A tibble: 6 × 2 #>       x     z #>   <int> <int> #> 1     5     2 #> 2     6     3 #> 3     3     4 #> 4     3     4 #> 5     5     5 #> 6     3     2  vec_rank(df) #> [1] 4 6 2 2 5 1"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_recycle.html","id":null,"dir":"Reference","previous_headings":"","what":"Vector recycling — vec_recycle","title":"Vector recycling — vec_recycle","text":"vec_recycle(x, size) recycles single vector given size. vec_recycle_common(...) recycles multiple vectors common size. functions obey vctrs recycling rules, throw error recycling possible. See vec_size() precise definition size.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_recycle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vector recycling — vec_recycle","text":"","code":"vec_recycle(x, size, ..., x_arg = \"\", call = caller_env())  vec_recycle_common(..., .size = NULL, .arg = \"\", .call = caller_env())"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_recycle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vector recycling — vec_recycle","text":"x vector recycle. size Desired output size. ... Depending function used: vec_recycle_common(), vectors recycle. vec_recycle(), dots empty. x_arg Argument name x. used error messages inform user argument incompatible size. call, .call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. .size Desired output size. omitted, use common size vec_size_common(). .arg argument name string. argument mentioned error messages input origin problem.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_recycle.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Vector recycling — vec_recycle","text":"vec_slice()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_recycle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vector recycling — vec_recycle","text":"","code":"# Inputs with 1 observation are recycled vec_recycle_common(1:5, 5) #> [[1]] #> [1] 1 2 3 4 5 #>  #> [[2]] #> [1] 5 5 5 5 5 #>  vec_recycle_common(integer(), 5) #> [[1]] #> integer(0) #>  #> [[2]] #> numeric(0) #>  if (FALSE) { # \\dontrun{ vec_recycle_common(1:5, 1:2) } # }  # Data frames and matrices are recycled along their rows vec_recycle_common(data.frame(x = 1), 1:5) #> [[1]] #>   x #> 1 1 #> 2 1 #> 3 1 #> 4 1 #> 5 1 #>  #> [[2]] #> [1] 1 2 3 4 5 #>  vec_recycle_common(array(1:2, c(1, 2)), 1:5) #> [[1]] #>      [,1] [,2] #> [1,]    1    2 #> [2,]    1    2 #> [3,]    1    2 #> [4,]    1    2 #> [5,]    1    2 #>  #> [[2]] #> [1] 1 2 3 4 5 #>  vec_recycle_common(array(1:3, c(1, 3, 1)), 1:5) #> [[1]] #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]    1    2    3 #> [2,]    1    2    3 #> [3,]    1    2    3 #> [4,]    1    2    3 #> [5,]    1    2    3 #>  #>  #> [[2]] #> [1] 1 2 3 4 5 #>"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_repeat.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand the length of a vector — vec_repeat","title":"Expand the length of a vector — vec_repeat","text":"vec_repeat() replaced vec_rep() vec_rep_each() deprecated vctrs 0.3.0.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_repeat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand the length of a vector — vec_repeat","text":"","code":"vec_repeat(x, each = 1L, times = 1L)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_repeat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand the length of a vector — vec_repeat","text":"x vector. Number times repeat element x. times Number times repeat whole vector x.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_repeat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand the length of a vector — vec_repeat","text":"vector type x size vec_size(x) * times * .","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_seq_along.html","id":null,"dir":"Reference","previous_headings":"","what":"Useful sequences — vec_seq_along","title":"Useful sequences — vec_seq_along","text":"vec_seq_along() equivalent seq_along() uses size, length. vec_init_along() creates vector missing values size matching existing object.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_seq_along.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Useful sequences — vec_seq_along","text":"","code":"vec_seq_along(x)  vec_init_along(x, y = x)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_seq_along.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Useful sequences — vec_seq_along","text":"x, y Vectors","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_seq_along.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Useful sequences — vec_seq_along","text":"vec_seq_along() integer vector size x. vec_init_along() vector type x size y.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_seq_along.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Useful sequences — vec_seq_along","text":"","code":"vec_seq_along(mtcars) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 #> [23] 23 24 25 26 27 28 29 30 31 32 vec_init_along(head(mtcars)) #>      mpg cyl disp hp drat wt qsec vs am gear carb #> ...1  NA  NA   NA NA   NA NA   NA NA NA   NA   NA #> ...2  NA  NA   NA NA   NA NA   NA NA NA   NA   NA #> ...3  NA  NA   NA NA   NA NA   NA NA NA   NA   NA #> ...4  NA  NA   NA NA   NA NA   NA NA NA   NA   NA #> ...5  NA  NA   NA NA   NA NA   NA NA NA   NA   NA #> ...6  NA  NA   NA NA   NA NA   NA NA NA   NA   NA"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of observations — vec_size","title":"Number of observations — vec_size","text":"vec_size(x) returns size vector. vec_is_empty() returns TRUE size zero, FALSE otherwise. size distinct length() vector generalises \"number observations\" 2d structures, .e. number rows matrix data frame.  definition important property every column data frame (even data frame matrix columns) size. vec_size_common(...) returns common size multiple vectors. list_sizes() returns integer vector containing size element list. nearly equivalent , faster , map_int(x, vec_size), exception list_sizes() error non-list inputs, defined obj_is_list(). list_sizes() vec_size() lengths() length().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of observations — vec_size","text":"","code":"vec_size(x)  vec_size_common(   ...,   .size = NULL,   .absent = 0L,   .arg = \"\",   .call = caller_env() )  list_sizes(x)  vec_is_empty(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of observations — vec_size","text":"x, ... Vector inputs NULL. .size NULL, default, output size determined recycling lengths elements .... Alternatively, can supply .size force known size; case, x ... ignored. .absent size used input provided, input NULL. left NULL input supplied, error thrown. .arg argument name string. argument mentioned error messages input origin problem. .call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of observations — vec_size","text":"integer (double long vectors). vec_size_common() returns .absent inputs NULL absent, 0L default.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_size.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of observations — vec_size","text":"vctrs helper retrieves number columns: property type. vec_size() equivalent NROW() name easier pronounce, throws error passed non-vector inputs.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_size.html","id":"invariants","dir":"Reference","previous_headings":"","what":"Invariants","title":"Number of observations — vec_size","text":"vec_size(dataframe) == vec_size(dataframe[[]]) vec_size(matrix) == vec_size(matrix[, , drop = FALSE]) vec_size(vec_c(x, y)) == vec_size(x) + vec_size(y)","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_size.html","id":"the-size-of-null","dir":"Reference","previous_headings":"","what":"The size of NULL","title":"Number of observations — vec_size","text":"size NULL hard-coded 0L vec_size(). vec_size_common() returns .absent inputs NULL (inputs NULL, simply ignored). default size 0 makes sense sizes often queried order compute total size assembling collection vectors. Since treat NULL absent input principle, return identity sizes addition reflect absent input take size. Note defaults might make sense different circumstances. instance, default size 1 makes sense finding common size 1 identity recycling rules.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_size.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Number of observations — vec_size","text":"vec_proxy()","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_size.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of observations — vec_size","text":"","code":"vec_size(1:100) #> [1] 100 vec_size(mtcars) #> [1] 32 vec_size(array(dim = c(3, 5, 10))) #> [1] 3  vec_size_common(1:10, 1:10) #> [1] 10 vec_size_common(1:10, 1) #> [1] 10 vec_size_common(integer(), 1) #> [1] 0  list_sizes(list(\"a\", 1:5, letters)) #> [1]  1  5 26"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set observations in a vector — vec_slice","title":"Get or set observations in a vector — vec_slice","text":"provides common interface extracting modifying observations vector types, regardless dimensionality. analogs [ [<- match vec_size() instead length().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set observations in a vector — vec_slice","text":"","code":"vec_slice(x, i, ..., error_call = current_env())  vec_slice(x, i) <- value  vec_assign(x, i, value, ..., slice_value = FALSE, x_arg = \"\", value_arg = \"\")"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set observations in a vector — vec_slice","text":"x vector integer, character logical vector specifying locations names observations get/set. Specify TRUE index elements (x[]), NULL, FALSE integer() index none (x[NULL]). ... dots future extensions must empty. error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. value vector replacement values value cast type x. slice_value = FALSE, value must size 1 size converted positive integer location vector vec_as_location() (may size originally). slice_value = TRUE, value must size 1 size x. slice_value boolean. TRUE, assignment proceeds provided vec_slice(x, ) <- vec_slice(value, ), optimized avoid materializing slice value. x_arg, value_arg Argument names x value. used error messages inform user locations incompatible types sizes (see stop_incompatible_type() stop_incompatible_size()).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set observations in a vector — vec_slice","text":"vector type x.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_slice.html","id":"genericity","dir":"Reference","previous_headings":"","what":"Genericity","title":"Get or set observations in a vector — vec_slice","text":"Support S3 objects depends whether object implements vec_proxy() method. vec_proxy() method exists, proxy sliced assigned vec_restore() called result. Otherwise, vec_slice() falls back base generic [ vec_slice<-() falls back base generic [<-. vec_slice<-() falls back [<-, expected subclass's [<- method can handle following subset cases base R's [<- can also handle: vector positive integer positions (notably excluding NA). value vector length 1 length length(). length 1, recycled [<- method length . [<- method eventually calls base R's native [<- code, cases handled . Note S3 lists treated scalars default, cause error implement vec_proxy() method.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_slice.html","id":"differences-with-base-r-subsetting","dir":"Reference","previous_headings":"","what":"Differences with base R subsetting","title":"Get or set observations in a vector — vec_slice","text":"vec_slice() slices along one dimension. two-dimensional types, first dimension subsetted. vec_slice() preserves attributes default. vec_slice<-() type-stable always returns type LHS.","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_slice.html","id":"vctrs-dependencies","dir":"Reference","previous_headings":"","what":"vctrs dependencies","title":"Get or set observations in a vector — vec_slice","text":"vec_proxy() vec_restore()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_slice.html","id":"base-dependencies","dir":"Reference","previous_headings":"","what":"base dependencies","title":"Get or set observations in a vector — vec_slice","text":"base::`[` base::`[<-`","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or set observations in a vector — vec_slice","text":"","code":"x <- sample(10) x #>  [1]  6  3  1  4 10  8  7  2  5  9 vec_slice(x, 1:3) #> [1] 6 3 1  # You can assign with the infix variant: vec_slice(x, 2) <- 100 x #>  [1]   6 100   1   4  10   8   7   2   5   9  # Or with the regular variant that doesn't modify the original input: y <- vec_assign(x, 3, 500) y #>  [1]   6 100 500   4  10   8   7   2   5   9 x #>  [1]   6 100   1   4  10   8   7   2   5   9   # Slicing objects of higher dimension: vec_slice(mtcars, 1:3) #>                mpg cyl disp  hp drat    wt  qsec vs am gear carb #> Mazda RX4     21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 #> Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 #> Datsun 710    22.8   4  108  93 3.85 2.320 18.61  1  1    4    1  # Type stability --------------------------------------------------  # The assign variant is type stable. It always returns the same # type as the input. x <- 1:5 vec_slice(x, 2) <- 20.0  # `x` is still an integer vector because the RHS was cast to the # type of the LHS: vec_ptype(x) #> integer(0)  # Compare to `[<-`: x[2] <- 20.0 vec_ptype(x) #> numeric(0)   # Note that the types must be coercible for the cast to happen. # For instance, you can cast a double vector of whole numbers to an # integer vector: vec_cast(1, integer()) #> [1] 1  # But not fractional doubles: try(vec_cast(1.5, integer())) #> Error in eval(expr, envir) :  #>   Can't convert from `1.5` <double> to <integer> due to loss of precision. #> • Locations: 1  # For this reason you can't assign fractional values in an integer # vector: x <- 1:3 try(vec_slice(x, 2) <- 1.5) #> Error in `vec_slice<-`(`*tmp*`, 2, value = 1.5) :  #>   Can't convert from `1.5` <double> to <integer> due to loss of precision. #> • Locations: 1  # Slicing `value` -------------------------------------------------  # Sometimes both `x` and `value` start from objects that are the same length, # and you need to slice `value` by `i` before assigning it to `x`. This comes # up when thinking about how `base::ifelse()` and `dplyr::case_when()` work. condition <- c(TRUE, FALSE, TRUE, FALSE) yes <- 1:4 no <- 5:8  # Create an output container and fill it out <- vec_init(integer(), 4) out <- vec_assign(out, condition, vec_slice(yes, condition)) out <- vec_assign(out, !condition, vec_slice(no, !condition)) out #> [1] 1 6 3 8  # This is wasteful because you have to materialize the slices of `yes` and # `no` before they can be assigned, and you also have to validate `condition` # multiple times. Using `slice_value` internally performs # `vec_slice(yes, condition)` and `vec_slice(no, !condition)` for you, # but does so in a way that avoids the materialization. out <- vec_init(integer(), 4) out <- vec_assign(out, condition, yes, slice_value = TRUE) out <- vec_assign(out, !condition, no, slice_value = TRUE) out #> [1] 1 6 3 8"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_split.html","id":null,"dir":"Reference","previous_headings":"","what":"Split a vector into groups — vec_split","title":"Split a vector into groups — vec_split","text":"generalisation split() can split type vector, just factors. Instead returning keys character names, returned separate parallel vector.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_split.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split a vector into groups — vec_split","text":"","code":"vec_split(x, by)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_split.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split a vector into groups — vec_split","text":"x Vector divide groups. Vector whose unique values defines groups.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_split.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split a vector into groups — vec_split","text":"data frame two columns size equal vec_size(vec_unique()). key column type , val column list containing elements type vec_ptype(x). Note complex types, default data.frame print method suboptimal, want coerce tibble better understand output.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_split.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Split a vector into groups — vec_split","text":"vec_group_loc() vec_chop()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_split.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split a vector into groups — vec_split","text":"","code":"vec_split(mtcars$cyl, mtcars$vs) #>   key                                                  val #> 1   0 6, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 8, 6, 8 #> 2   1             4, 6, 6, 4, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4 vec_split(mtcars$cyl, mtcars[c(\"vs\", \"am\")]) #>   key.vs key.am                                val #> 1      0      1                   6, 6, 4, 8, 6, 8 #> 2      1      1                4, 4, 4, 4, 4, 4, 4 #> 3      1      0                6, 6, 4, 4, 6, 6, 4 #> 4      0      0 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8  if (require(\"tibble\")) {   as_tibble(vec_split(mtcars$cyl, mtcars[c(\"vs\", \"am\")]))   as_tibble(vec_split(mtcars, mtcars[c(\"vs\", \"am\")])) } #> # A tibble: 4 × 2 #>   key$vs   $am val            #>    <dbl> <dbl> <list>         #> 1      0     1 <df [6 × 11]>  #> 2      1     1 <df [7 × 11]>  #> 3      1     0 <df [7 × 11]>  #> 4      0     0 <df [12 × 11]>"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated type functions — vec_type","title":"Deprecated type functions — vec_type","text":"functions renamed: vec_type() => vec_ptype() vec_type2() => vec_ptype2() vec_type_common() => vec_ptype_common()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated type functions — vec_type","text":"","code":"vec_type(x)  vec_type_common(..., .ptype = NULL)  vec_type2(x, y, ...)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated type functions — vec_type","text":"x, y, ..., .ptype Arguments deprecated functions.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_unchop.html","id":null,"dir":"Reference","previous_headings":"","what":"Chopping — vec_unchop","title":"Chopping — vec_unchop","text":"vec_unchop() renamed list_unchop() deprecated vctrs 0.5.0.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_unchop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chopping — vec_unchop","text":"","code":"vec_unchop(   x,   indices = NULL,   ptype = NULL,   name_spec = NULL,   name_repair = c(\"minimal\", \"unique\", \"check_unique\", \"universal\") )"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_unchop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chopping — vec_unchop","text":"x vector indices vec_chop(), list positive integer vectors slice x , NULL. used sizes already specified. indices sizes NULL, x split individual elements, equivalent using indices .list(vec_seq_along(x)). list_unchop(), list positive integer vectors specifying locations place elements x . element x recycled size corresponding index vector. size indices must match size x. NULL, x combined order provided , equivalent using vec_c(). ptype NULL, default, output type determined computing common type across elements x. Alternatively, can supply ptype give output known type. name_spec name specification combining inner outer names. relevant inputs passed name, inputs named, like outer = c(inner = 1), length greater 1: outer = 1:2. default, cases trigger error. can resolve error providing specification describes combine names indices inner vector name input. specification can : function two arguments. outer name passed string first argument, inner names positions passed second argument. anonymous function purrr-style formula. glue specification form \"{outer}_{inner}\". rlang::zap() object, case outer inner names ignored result unnamed. See name specification topic. name_repair repair names, see repair options vec_as_names().","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_unchop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chopping — vec_unchop","text":"vec_chop(): list element type x. size list equal vec_size(indices), vec_size(sizes), vec_size(x) depending whether indices sizes provided. list_unchop(): vector type vec_ptype_common(!!!x), ptype, specified. size computed vec_size_common(!!!indices) unless indices NULL, case size vec_size_common(!!!x).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_unique.html","id":null,"dir":"Reference","previous_headings":"","what":"Find and count unique values — vec_unique","title":"Find and count unique values — vec_unique","text":"vec_unique(): unique values. Equivalent unique(). vec_unique_loc(): locations unique values. vec_unique_count(): number unique values.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_unique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find and count unique values — vec_unique","text":"","code":"vec_unique(x)  vec_unique_loc(x)  vec_unique_count(x)"},{"path":"https://vctrs.r-lib.org/dev/reference/vec_unique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find and count unique values — vec_unique","text":"x vector (including data frame).","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_unique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find and count unique values — vec_unique","text":"vec_unique(): vector type x containing unique values. vec_unique_loc(): integer vector, giving locations unique values. vec_unique_count(): integer vector length 1, giving number unique values.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_unique.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Find and count unique values — vec_unique","text":"vec_proxy_equal()","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vec_unique.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing values","title":"Find and count unique values — vec_unique","text":"cases, missing values considered equal, .e. NA == NA TRUE. behaviour unappealing , functions consider NAs equal. (Similarly, NaN also considered equal.)","code":""},{"path":[]},{"path":"https://vctrs.r-lib.org/dev/reference/vec_unique.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find and count unique values — vec_unique","text":"","code":"x <- rpois(100, 8) vec_unique(x) #>  [1]  4 13 10  5  8  7  9  6 15 12 11 14  2 vec_unique_loc(x) #>  [1]  1  2  3  4  5  8  9 11 14 20 25 27 31 vec_unique_count(x) #> [1] 13  # `vec_unique()` returns values in the order that encounters them # use sort = \"location\" to match to the result of `vec_count()` head(vec_unique(x)) #> [1]  4 13 10  5  8  7 head(vec_count(x, sort = \"location\")) #>   key count #> 1   4     3 #> 2  13     4 #> 3  10     6 #> 4   5     9 #> 5   8    15 #> 6   7    17  # Normally missing values are not considered to be equal NA == NA #> [1] NA  # But they are for the purposes of considering uniqueness vec_unique(c(NA, NA, NA, NA, 1, 2, 1)) #> [1] NA  1  2"},{"path":"https://vctrs.r-lib.org/dev/reference/vector-checks.html","id":null,"dir":"Reference","previous_headings":"","what":"Vector checks — vector-checks","title":"Vector checks — vector-checks","text":"obj_is_vector() tests x considered vector vctrs sense. See Vectors scalars exact details. obj_check_vector() uses obj_is_vector() throws standardized informative error returns FALSE. vec_check_size() tests x size size, throws informative error .","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vector-checks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vector checks — vector-checks","text":"","code":"obj_is_vector(x)  obj_check_vector(x, ..., arg = caller_arg(x), call = caller_env())  vec_check_size(x, size, ..., arg = caller_arg(x), call = caller_env())"},{"path":"https://vctrs.r-lib.org/dev/reference/vector-checks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vector checks — vector-checks","text":"x obj_*() functions, object. vec_*() functions, vector. ... dots future extensions must empty. arg argument name string. argument mentioned error messages input origin problem. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. size size check .","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vector-checks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vector checks — vector-checks","text":"obj_is_vector() returns single TRUE FALSE. obj_check_vector() returns NULL invisibly, errors. vec_check_size() returns NULL invisibly, errors.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vector-checks.html","id":"vectors-and-scalars","dir":"Reference","previous_headings":"","what":"Vectors and scalars","title":"Vector checks — vector-checks","text":"Informally, vector collection makes sense use column data frame. following rules define whether x considered vector. vec_proxy() method registered, x vector : base type object atomic: \"logical\", \"integer\", \"double\", \"complex\", \"character\", \"raw\". x list, defined obj_is_list(). x data.frame. vec_proxy() method registered, x vector : proxy satisfies one conditions. base type proxy \"list\", regardless class. S3 lists thus treated scalars unless implement vec_proxy() method. Otherwise object treated scalar used vector. particular: NULL vector. S3 lists like lm objects treated scalars default. Objects type expression treated vectors.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vector-checks.html","id":"technical-limitations","dir":"Reference","previous_headings":"","what":"Technical limitations","title":"Vector checks — vector-checks","text":"Support S4 vectors currently limited objects inherit atomic type. Subclasses data.frame append class back \"class\" attribute treated vectors. inherit S3 class, always prepend class front \"class\" attribute correct dispatch. matches general principle allowing subclasses mixins.","code":""},{"path":"https://vctrs.r-lib.org/dev/reference/vector-checks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vector checks — vector-checks","text":"","code":"obj_is_vector(1) #> [1] TRUE  # Data frames are vectors obj_is_vector(data_frame()) #> [1] TRUE  # Bare lists are vectors obj_is_vector(list()) #> [1] TRUE  # S3 lists are vectors if they explicitly inherit from `\"list\"` x <- structure(list(), class = c(\"my_list\", \"list\")) obj_is_list(x) #> [1] TRUE obj_is_vector(x) #> [1] TRUE  # But if they don't explicitly inherit from `\"list\"`, they aren't # automatically considered to be vectors. Instead, vctrs considers this # to be a scalar object, like a linear model returned from `lm()`. y <- structure(list(), class = \"my_list\") obj_is_list(y) #> [1] FALSE obj_is_vector(y) #> [1] FALSE  # `obj_check_vector()` throws an informative error if the input # isn't a vector try(obj_check_vector(y)) #> Error in eval(expr, envir) :  #>   `y` must be a vector, not a <my_list> object.  # `vec_check_size()` throws an informative error if the size of the # input doesn't match `size` vec_check_size(1:5, size = 5) try(vec_check_size(1:5, size = 4)) #> Error in eval(expr, envir) : `1:5` must have size 4, not size 5."},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-development-version","dir":"Changelog","previous_headings":"","what":"vctrs (development version)","title":"vctrs (development version)","text":"vec_assign() gained new slice_value argument optionally slice value performing assignment. optimized form vec_slice(x, ) <- vec_slice(value, ) avoids materializing vec_slice(value, ) (#2009). vec_assign() vec_slice<-() now efficient logical (#2009). vec_assign() vec_slice<-() now efficiently internally recycle value size 1 C level, resulting less memory usage. vec_assign() longer modifies POSIXlt vctrs_rcrd types place (#1951). data.table’s IDate class now vec_proxy() vec_restore() methods, fixing number issues class (#1549, #1961, #1972, #1781). vec_locate_sorted_groups() vec_order_radix() longer crash columns type complex (tidyverse/dplyr#7708). Functions backed dictionary based implementation often significantly faster, depending exact inputs used. includes: vec_match(), vec_in(), vec_group_loc(), vec_count(), vec_unique(), (#1976). following functions longer experimental: vec_fill_missing() vec_group_id() vec_group_loc() vec_group_rle() vec_locate_matches() Hashing now supported lists containing complex vectors, enabling functions like vec_unique_loc() work objects (#1992). vec_detect_complete(NULL) now returns logical(), consistent vec_detect_missing(NULL) (#1916).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-065","dir":"Changelog","previous_headings":"","what":"vctrs 0.6.5","title":"vctrs 0.6.5","text":"CRAN release: 2023-12-01 Internal changes requested CRAN around C level format strings (#1896). Fixed tests related changes dim<-() R-devel (#1889).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-064","dir":"Changelog","previous_headings":"","what":"vctrs 0.6.4","title":"vctrs 0.6.4","text":"CRAN release: 2023-10-12 Fixed performance issue vec_c() ALTREP vectors (particular, new ALTREP list vectors R-devel) (#1884). Fixed issue complex vector tests related changes R-devel (#1883). Added class vec_locate_matches() error thrown overflow otherwise occur (#1845). Fixed issue vec_rank() 0-column data frames (#1863).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-063","dir":"Changelog","previous_headings":"","what":"vctrs 0.6.3","title":"vctrs 0.6.3","text":"CRAN release: 2023-06-14 Fixed issue certain ALTREP row names materialized passed new_data_frame(). ’ve fixed removing safeguard new_data_frame() performed compatibility check n row.names provided. low level function designed performance, caller ensure inputs compatible (tidyverse/dplyr#6596). Fixed issue vec_set_*() used data frames accidentally return object type proxy rather type original inputs (#1837). Fixed rare vec_locate_matches() bug occur using max/min filter (tidyverse/dplyr#6835).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-062","dir":"Changelog","previous_headings":"","what":"vctrs 0.6.2","title":"vctrs 0.6.2","text":"CRAN release: 2023-04-19 Fixed conditional S3 registration avoid CRAN check NOTE appears R >=4.3.0 (#1832). Fixed tests maintain compatibility next version waldo (#1829).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-061","dir":"Changelog","previous_headings":"","what":"vctrs 0.6.1","title":"vctrs 0.6.1","text":"CRAN release: 2023-03-22 Fixed test related c.sfc() changes sf 1.0-10 (#1817).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-060","dir":"Changelog","previous_headings":"","what":"vctrs 0.6.0","title":"vctrs 0.6.0","text":"CRAN release: 2023-03-15 New vec_run_sizes() computing size run within vector. identical times column vec_unrep(), faster don’t need run key (#1210). New sizes argument vec_chop() allows partition vector using integer vector describing size expected slice. particularly useful combination vec_run_sizes() list_sizes() (#1210, #1598). New obj_is_vector(), obj_check_vector(), vec_check_size() validation helpers. believe better approach vector validation vec_assert() vec_is(), marked questioning semantics ptype arguments hard define can often replaced vec_cast() type predicate function like rlang::is_logical() (#1784). vec_is_list() vec_check_list() renamed obj_is_list() obj_check_list(), line new obj_is_vector() helper. old functions silently deprecated, official deprecation process start next vctrs release (#1803). vec_locate_matches() gains new relationship argument holistically handles multiple matches needles haystack. particular, relationship = \"many--one\" replaces multiple = \"error\" multiple = \"warning\", removed documentation silently soft-deprecated. Official deprecation options start future release (#1791). vec_locate_matches() changed default needles_arg haystack_arg values \"\" \"needles\" \"haystack\", respectively. generally generates informative error messages (#1792). vec_chop() gained empty ... x optional indices argument. backwards compatibility, supplying vec_chop(x, indices) without naming indices still silently works, deprecated future release (#1813). vec_slice() gained error_call argument (#1785). numeric_version type base R now better supported equality, comparison, order based operations (tidyverse/dplyr#6680). R >=3.5.0 now explicitly required. line tidyverse policy supporting 5 recent versions R.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-052","dir":"Changelog","previous_headings":"","what":"vctrs 0.5.2","title":"vctrs 0.5.2","text":"CRAN release: 2023-01-23 New vec_expand_grid(), lower level helper similar tidyr::expand_grid() (#1325). New vec_set_intersect(), vec_set_difference(), vec_set_union(), vec_set_symmetric_difference() compute set operations like intersect(), setdiff(), union(), vctrs variants don’t strip attributes work data frames (#1755, #1765). vec_identify_runs() now faster used data frames (#1684). maximum load factor internal dictionary reduced 77% 50%, improves performance functions like vec_match(), vec_set_intersect(), vec_unique() cases (#1760). Fixed bug internal vec_order_radix() function related matrix columns (#1753).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-051","dir":"Changelog","previous_headings":"","what":"vctrs 0.5.1","title":"vctrs 0.5.1","text":"CRAN release: 2022-11-16 Fix CRAN checks.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-050","dir":"Changelog","previous_headings":"","what":"vctrs 0.5.0","title":"vctrs 0.5.0","text":"CRAN release: 2022-10-21 vctrs now compliant -Wstrict-prototypes requested CRAN (#1729). vec_ptype2() now consistently falls back bare data frame case incompatible data frame subclasses. part general move towards relaxed coercion rules. Common type cast errors now inherit \"vctrs_error_ptype2\" \"vctrs_error_cast\" respectively. still subclasses \"vctrs_error_incompatible_type\" (used specific class now parent class). New list_all_size() list_check_all_size() quickly determine list contains elements particular size (#1582). list_unchop() gained empty ... force optional arguments named (#1715). vec_rep_each(times = 0) now works correctly logical vectors considered unspecified named vectors (#1673). list_of() relaxed make easier combine. now coercible list() (#1161). incompatible list_of() types combined, result now bare list(). Following change, role list_of() mainly carry type information potential optimisations, rather guarantee certain type throughout analysis. validate_list_of() removed. hasn’t proven practically useful, isn’t used packages CRAN (#1697). Directed calls vec_c(), like vec_c(.ptype = <type>), now mention position problematic argument cast errors (#1690). list_unchop() longer drops names cases indices supplied (#1689). \"unique_quiet\" \"universal_quiet\" newly accepted vec_as_names(repair =) vec_names2(repair =). options exist help users call functions indirectly, via another function exposes repair quiet. Specifying repair = \"unique_quiet\" like specifying repair = \"unique\", quiet = TRUE. \"*_quiet\" options used, setting quiet silently overridden (@jennybc, #1629). \"unique_quiet\" \"universal_quiet\" also newly accepted name repair argument several functions expose quiet argument: data_frame(), df_list(), vec_c(), list_unchop(), vec_interleave(), vec_rbind(), vec_cbind() (@jennybc, #1716). list_unchop() gained error_call error_arg arguments (#1641, #1692). vec_c() gained .error_call .error_arg arguments (#1641, #1692). Improved performance list-common type methods (#1686, #875). list-method as_list_of() now places optional .ptype argument ... (#1686). vec_rbind() now applies base::c() fallback recursively within packed df-cols (#1331, #1462, #1640). vec_c(), vec_unchop(), vec_rbind() now proxy restore recursively (#1107). prevents vec_restore() called partially filled vectors improves performance (#1217, #1496). New vec_any_missing() quickly determining vector missing values (#1672). vec_equal_na() renamed vec_detect_missing() align better vctrs naming conventions. vec_equal_na() stick around minor versions, formally soft-deprecated (#1672). vec_c(outer = c(inner = 1)) now produces correct error messages (#522). data frame returned proxy vec_proxy_equal(), vec_proxy_compare(), vec_proxy_order(), corresponding proxy function now automatically applied recursively along columns. Additionally, packed data frame columns unpacked, 1 column data frames unwrapped. ensures simplest possible types provided native C algorithms, improving correctness performance (#1664). used record vectors, vec_proxy_compare() vec_proxy_order() now call correct proxy function recursing fields (#1664). experimental function vec_list_cast() removed package (#1382). Native classes like dates datetimes now accept dimensions (#1290, #1329). vec_compare() now throws informative error attempting compare complex vectors (#1655). vec_rep() friends gain error_call, x_arg, times_arg arguments can embedded frontends (#1303). Record vectors now fail expected indexed along dimensions greater 1 (#1295). vec_order() vec_sort() now ... required optional arguments make easier extend (#1647). S3 vignette extended show make polynomial class atomic instead list (#1030). experimental n argument vec_restore() removed. used inform size data frames case bare list restored. now expected bare lists initialised data frame size carried row attributes. makes generic simpler fixes performance issues (#650). anyNA() method vctrs_vctr (thus vctrs_list_of) now supports recursive argument (#1278). vec_as_location() num_as_location() gained missing = \"remove\" option (#1595). vec_as_location() longer matches NA_character_ \"\" indices invalid names appear names (#1489). vec_unchop() renamed list_unchop() better indicate requires list input. vec_unchop() stick around minor versions, formally soft-deprecated (#1209). Lossy cast errors scalar subscript validation now correct message (#1606). Fixed confusing error message logical [[ subscripts (#1608). New vec_rank() compute various types sample ranks (#1600). num_as_location() now throws right error --bounds negative values oob = \"extend\" negative = \"ignore\" set (#1614, #1630). num_as_location() now works correctly combination zero = \"error\" negative = \"invert\" used (#1612). data_frame() df_list() gained .error_call arguments (#1610). vec_locate_matches() gained error_call argument (#1611). \"select\" \"relocate\" added valid subscript actions support tidyselect dplyr (#1596). num_as_location() new oob = \"remove\" argument remove --bounds locations (#1595). vec_rbind() vec_cbind() now .error_call arguments (#1597). df_list() gained new .unpack argument optionally disable data frame unpacking (#1616). vec_check_list(arg = \"\") now throws correct error (#1604). difftime difftime vec_cast() method now standardizes internal storage type double, catching potentially corrupt integer storage difftime vectors (#1602). vec_as_location2() vec_as_subscript2() correctly utilize call arguments (#1605). vec_count(sort = \"count\") now uses stable sorting method. ensures different keys count sorted order originally appeared (#1588). Lossy cast error conditions now show correct message conditionMessage() called (#1592). Fixed inconsistent reporting conflicting inputs vec_ptype_common() (#1570). vec_ptype_abbr() vec_ptype_full() now suffix 1d arrays [1d]. vec_ptype_abbr() vec_ptype_full() methods longer inherited (#1549). vec_cast() now throws correct error attempting cast subclassed data frame non-data frame type (#1568). vec_locate_matches() now uses conservative heuristic taking joint ordering proxy. allows work correctly sf’s sfc vectors classes bignum package (#1558). sfc method vec_proxy_order() added better support sf package. vectors generally treated like list-columns even though don’t explicitly \"list\" class, vec_proxy_order() method now forwards list method reflect (#1558). vec_proxy_compare() now works correctly raw vectors wrapped (). vec_proxy_order() now works correctly raw list vectors wrapped () (#1557).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-042","dir":"Changelog","previous_headings":"","what":"vctrs 0.4.2","title":"vctrs 0.4.2","text":"CRAN release: 2022-09-29 HTML documentation fixes CRAN checks.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-041","dir":"Changelog","previous_headings":"","what":"vctrs 0.4.1","title":"vctrs 0.4.1","text":"CRAN release: 2022-04-13 OOB errors character() indexes use “don’t exist” instead “past end” (#1543). Fixed memory protection issues related common type determination (#1551, tidyverse/tidyr#1348).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-040","dir":"Changelog","previous_headings":"","what":"vctrs 0.4.0","title":"vctrs 0.4.0","text":"CRAN release: 2022-03-30 New experimental vec_locate_sorted_groups() returning locations groups sorted order. equivalent , faster , calling vec_group_loc() sorting key column result. New experimental vec_locate_matches() locating observation one vector matches one observations another vector. similar vec_match(), returns matches default (rather just first), can match binary conditions equality. algorithm inspired data.table’s fast binary merge procedure. vec_proxy_equal(), vec_proxy_compare(), vec_proxy_order() methods vctrs_rcrd now applied recursively fields (#1503). Lossy cast errors now inherit incompatible type errors. vec_is_list() now returns TRUE AsIs lists (#1463). vec_assert(), vec_ptype2(), vec_cast(), vec_as_location() now use caller_arg() infer default arg value caller. may result unhelpful arguments mentioned error messages. general, consider snapshotting vctrs error messages thrown package supply arg call arguments error context adequately reported users. vec_ptype_common(), vec_cast_common(), vec_size_common(), vec_recycle_common() gain call arg arguments specifying error context. vec_compare() can now compare zero column data frames (#1500). new_data_frame() now errors negative missing n values (#1477). vec_order() now correctly orders zero column data frames (#1499). vctrs now depends cli help error message generation. New vec_check_list() list_check_all_vectors() input checkers, accompanying list_all_vectors() predicate. New vec_interleave() combining multiple vectors together, interleaving elements process (#1396). vec_equal_na(NULL) now returns logical(0) rather erroring (#1494). vec_as_location(missing = \"error\") now fails NA NA_character_ addition NA_integer_ (#1420, @krlmlr). Starting rlang 1.0.0, errors displayed contextual function call. Several vctrs operations gain call argument makes possible report correct context error messages. concerns: vec_cast() vec_ptype2() vec_default_cast() vec_default_ptype2() vec_assert() vec_as_names() stop_ constructors like stop_incompatible_type() Note default vec_cast() vec_ptype2() methods automatically support pass ... corresponding vec_default_ functions. throw non-internal error non-default method, add call = caller_env() argument method pass rlang::abort(). NA_character_ specified name vctrs_vctr objects, now automatically repaired \"\" (#780). \"\" now allowed name vctrs_vctr objects subclasses (vctrs_list_of particular) (#780). list_of() now much faster many values provided. vec_as_location() evaluates arg case error, performance (#1150, @krlmlr). levels.vctrs_vctr() now returns NULL instead failing (#1186, @krlmlr). vec_assert() produces informative error size invalid (#1470). vec_duplicate_detect() bit faster many unique values. vec_proxy_order() described vignette(\"s3-vectors\") (#1373, @krlmlr). vec_chop() now materializes ALTREP vectors chopping, efficient creating many small ALTREP pieces (#1450). New list_drop_empty() removing empty elements list (#1395). list_sizes() now propagates names list onto result. Name repair messages now signaled rlang::names_inform_repair(). means messages now sent stdout default rather stderr, resulting prettier messages. Additionally, name repair messages can now silenced global option rlib_name_repair_verbosity, useful testing purposes. See ?names_inform_repair information (#1429). vctrs_vctr methods na.omit(), na.exclude(), na.fail() added (#1413). vec_init() now slightly faster (#1423). vec_set_names() longer corrupts vctrs_rcrd types (#1419). vec_detect_complete() now computes completeness vctrs_rcrd types way data frames, means field missing, entire record considered incomplete (#1386). na_value argument vec_order() vec_sort() now correctly respect missing values lists (#1401). vec_rep() vec_rep_each() much faster times = 0 times = 1 (@mgirlich, #1392). vec_equal_na() vec_fill_missing() now work integer64 vectors (#1304). xtfrm() method vctrs_vctr objects longer accidentally breaks ties (#1354). min(), max() range() longer throw error na.rm = TRUE set values NA (@gorcha, #1357). case, empty input given, return Inf/-Inf, NA Inf can’t cast input type. vec_group_loc(), used grouping dplyr, now correctly handles vectors billions elements (.Machine$integer.max) (#1133).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-038","dir":"Changelog","previous_headings":"","what":"vctrs 0.3.8","title":"vctrs 0.3.8","text":"CRAN release: 2021-04-29 Compatibility next version rlang.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-037","dir":"Changelog","previous_headings":"","what":"vctrs 0.3.7","title":"vctrs 0.3.7","text":"CRAN release: 2021-03-29 vec_ptype_abbr() gains arguments control whether indicate named vectors prefix (prefix_named) indicate shaped vectors suffix (suffix_shape) (#781, @krlmlr). vec_ptype() now optional performance generic. necessary implement, class static prototype, might consider implementing custom vec_ptype() method returns constant improve performance cases (common type imputation). New vec_detect_complete(), inspired stats::complete.cases(). vectors, identical !vec_equal_na(). data frames matrices, detects rows contain non-missing values. vec_order() can now order complex vectors (#1330). Removed dependency digest favor rlang::hash(). Fixed issue vctrs_rcrd objects proxied correctly used data frame column (#1318). register_s3() now licensed “unlicense” makes clear ’s fine copy paste package (@maxheld83, #1254).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-036","dir":"Changelog","previous_headings":"","what":"vctrs 0.3.6","title":"vctrs 0.3.6","text":"CRAN release: 2020-12-17 Fixed issue tibble 3.0.0 removing column names names(x) <- NULL now deprecated (#1298). Fixed GCC 11 issue revealed CRAN checks.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-035","dir":"Changelog","previous_headings":"","what":"vctrs 0.3.5","title":"vctrs 0.3.5","text":"CRAN release: 2020-11-17 New experimental vec_fill_missing() filling missing values previous following value. similar tidyr::fill(), also works data frames additional max_fill argument limit number sequential missing values fill. New vec_unrep() compress vector repeated values. similar run length encoding, works nicely alongside vec_rep_each() way invert compression. vec_cbind() empty data frames now preserves common size inputs result (#1281). vec_c() now correctly returns named result named empty inputs (#1263). vctrs relicensed MIT (#1259). Functions make comparisons within single vector, vec_unique(), two vectors, vec_match(), now convert character input UTF-8 making comparisons (#1246). New vec_identify_runs() returns vector identifiers elements x indicate run repeated values fall (#1081). Fixed encoding translation bug lists containing data frames columns vec_size() different low level Rf_length() (#1233).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-034","dir":"Changelog","previous_headings":"","what":"vctrs 0.3.4","title":"vctrs 0.3.4","text":"CRAN release: 2020-08-29 Fixed GCC sanitiser error revealed CRAN checks.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-033","dir":"Changelog","previous_headings":"","what":"vctrs 0.3.3","title":"vctrs 0.3.3","text":"CRAN release: 2020-08-27 table class now implemented wrapper type delegates coercion methods. used restricted integer tables (#1190). Named one-dimensional arrays now behave consistently simple vectors vec_names() vec_rbind(). new_rcrd() now uses df_list() validate fields. makes flexible fields can now type supported vctrs, including data frames. Thanks previous change [[ method records now preserves list fields (#1205). vec_data() now preserves data frames. consistent notion data frames primitive vector type vctrs. shouldn’t affect code uses [[ length() manipulate data. hand, vctrs primitives like vec_slice() now operate rowwise vec_data() returns data frame. outer now passed unrecycled name specifications. Instead, return value recycled (#1099). Name specifications can now return NULL. names vector allocated spec function returns non-NULL concatenation. makes possible ignore outer names without create empty names vector inner names: Fixed several performance issues vec_c() vec_unchop() named vectors. restriction S3 lists must list-based proxy considered lists vec_is_list() removed (#1208). New performant data_frame() constructor creating data frames way follows tidyverse semantics. Among things, inputs recycled using tidyverse recycling rules, strings never converted factors, list-columns easier create, unnamed data frame input automatically spliced. New df_list() safely consistently constructing data structure underlying data frame, named list equal-length vectors. useful combination new_data_frame() creating user-friendly constructors data frame subclasses use tidyverse rules recycling determining types. Fixed performance issue vec_order() classed vectors affected dplyr::group_by() (tidyverse/dplyr#5423). vec_set_names() longer alters input -place (#1194). New vec_proxy_order() provides ordering proxy use vec_order() vec_sort(). default method falls vec_proxy_compare(). Lists special cased, return integer vector proxy orders first appearance. List columns data frames longer comparable vec_compare(). experimental relax argument removed vec_proxy_compare().","code":"zap_outer_spec <- function(outer, inner) if (is_character(inner)) inner  # `NULL` names rather than a vector of \"\" names(vec_c(a = 1:2, .name_spec = zap_outer_spec)) #> NULL  # Names are allocated when inner names exist names(vec_c(a = 1:2, c(b = 3L), .name_spec = zap_outer_spec)) #> [1] \"\"  \"\"  \"b\""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-032","dir":"Changelog","previous_headings":"","what":"vctrs 0.3.2","title":"vctrs 0.3.2","text":"CRAN release: 2020-07-15 Fixed performance issue bind_rows() S3 columns (#1122, #1124, #1151, tidyverse/dplyr#5327). vec_slice() now checks sizes data frame columns case data structure corrupt (#552). native routines vctrs now dispatch evaluate vctrs namespace. improves continuity evaluation backtraces. new_data_frame() now twice fast class supplied. New vec_names2(), vec_names() vec_set_names() (#1173).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-031","dir":"Changelog","previous_headings":"","what":"vctrs 0.3.1","title":"vctrs 0.3.1","text":"CRAN release: 2020-06-05 vec_slice() longer restores attributes foreign objects [ method exist. fixes issue ts objects previously incorrectly restored. .list() method vctrs_rcrd objects removed favor directly using method vctrs_vctr, calls vec_chop(). vec_c() vec_rbind() now fall back base::c() inputs common class hierarchy c() method implemented self--self vec_ptype2() method implemented. vec_rbind() now internally calls vec_proxy() vec_restore() data frame common type used create output (#1109). vec_as_location2(\"0\") now works correctly (#1131). ?reference-faq-compatibility new reference guide vctrs primitives. includes overview fallbacks base R generics implemented vctrs compatibility existing classes. documentation vctrs functions now includes Dependencies section reference vctrs operations called function. following dependencies links recursively, find vctrs primitives operation relies.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"cran-results-0-3-1","dir":"Changelog","previous_headings":"","what":"CRAN results","title":"vctrs 0.3.1","text":"Fixed type declaration mismatches revealed LTO build. Fixed r-devel issue new c.factor() method.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-030","dir":"Changelog","previous_headings":"","what":"vctrs 0.3.0","title":"vctrs 0.3.0","text":"CRAN release: 2020-05-11 version features overhaul coercion system make consistent easier implement. See Breaking changes Type system sections details. three new documentation topics ’d like learn implement coercion methods make class compatible tidyverse packages like dplyr: https://vctrs.r-lib.org/reference/theory-faq-coercion.html overview coercion mechanism vctrs. https://vctrs.r-lib.org/reference/howto-faq-coercion.html practical guide implementing methods vectors. https://vctrs.r-lib.org/reference/howto-faq-coercion-data-frame.html practical guide implementing methods data frames.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"reverse-dependencies-troubleshooting-0-3-0","dir":"Changelog","previous_headings":"","what":"Reverse dependencies troubleshooting","title":"vctrs 0.3.0","text":"following errors caused breaking changes. \"convert <character> <list>.\" vec_cast() longer converts list. Use vec_chop() .list() instead. \"convert <integer> <character>.\" vec_cast() longer converts character. Use .character()deparse objects. \"names target current\" Names list-columns now preserved vec_rbind(). Adjust tests accordingly.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"breaking-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"vctrs 0.3.0","text":"Double-dispatch methods vec_ptype2() vec_cast() longer inherited (#710). Class implementers must implement one set methods compatible class. example, tibble subclass longer inherits vec_ptype2() methods tbl_df data.frame. means explicitly need implement vec_ptype2() methods tbl_df data.frame. change requires bit work class maintainers safer coercion hierarchies generally different class hierarchies. See S3 dispatch section ?vec_ptype2 information. vec_cast() now restricted conversions vec_ptype2() methods (#606, #741). change motivated safety performance: generally sloppy generically convert arbitrary inputs one type. Restricted coercions predictable allow code fail earlier type issue. unrestricted conversions useful, generally towards known type. example, glue::glue() needs convert arbitrary inputs known character type. case, using double dispatch instead single dispatch generic like .character() wasteful. implement useful semantics coercible casts (already used vec_assign()), two double dispatch needed. Now can done one double dispatch calling vec_cast() directly. stop_incompatible_cast() now throws error class vctrs_error_incompatible_type rather vctrs_error_incompatible_cast. means vec_cast() also throws errors class, better aligns vec_ptype2() now restricted conversions. y argument stop_incompatible_cast() renamed better match to_arg.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"type-system-0-3-0","dir":"Changelog","previous_headings":"","what":"Type system","title":"vctrs 0.3.0","text":"Double-dispatch methods vec_ptype2() vec_cast() now easier implement. longer need boiler plate. Implementing method classes foo bar now simple : vctrs also takes care implementing default unspecified methods. implemented methods, longer called can now removed. One consequence new dispatch mechanism NextMethod() now completely unsupported. best never worked correctly double-dispatch setting. Parent methods must now called manually. vec_ptype2() methods now get zero-size prototypes inputs. guarantees methods peek data determine richer type. vec_is_list() longer allows S3 lists implement vec_proxy() method automatically considered lists. S3 list must explicitly inherit \"list\" base class considered list. vec_restore() longer restores row names target data frame. fixes issue POSIXlt objects carry row.names attribute proxy/restore roundtrip. vec_cast() data frames preserves row names inputs. internal function vec_names() now returns row names input data frame. Similarly, vec_set_names() sets row names data frames. part general effort making row names vector names data frames vctrs. necessary, row names repaired verbosely without error make unique. mostly harmless change users, break unit tests packages make assumptions row names.","code":"#' @export vec_ptype2.foo.bar <- function(x, y, ...) new_foo()"},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"compatibility-and-fallbacks-0-3-0","dir":"Changelog","previous_headings":"","what":"Compatibility and fallbacks","title":"vctrs 0.3.0","text":"double dispatch changes, coercion methods longer inherited parent classes. coercion hierarchy principle different S3 hierarchy. consequence change subclasses don’t implement coercion methods now principle incompatible. particularly problematic subclasses data frames throwing incompatible errors incovenient users. work around , implemented fallback relevant base data frame class (either data.frame tbl_df) coercion methods (#981). fallback silent unless set vctrs:::warn_on_fallback option TRUE. future may extend fallback principle base types explicitly included class vector (\"list\"). Improved support foreign classes combining operations vec_c(), vec_rbind(), vec_unchop(). foreign class class doesn’t implement vec_ptype2(). objects combine foreign class, one fallbacks invoked: class implements base::c() method, method used combination. (FIXME: vec_rbind() currently doesn’t use fallback.) Otherwise objects identical attributes base type, consider compatible. vectors concatenated attributes restored (#776). fallbacks make class completely compatible vctrs-powered packages, help many simple cases. vec_c() vec_unchop() now fall back base::c() S4 objects object doesn’t implement vec_ptype2() sets S4 c() method (#919).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vector-operations-0-3-0","dir":"Changelog","previous_headings":"","what":"Vector operations","title":"vctrs 0.3.0","text":"vec_rbind() vec_c() data frame inputs now consistently preserve names list-columns, df-columns, matrix-columns (#689). can cause false positives unit tests, sensitive internal names (#1007). vec_rbind() now repairs row names silently avoid confusing messages row names informative created purpose. vec_rbind() gains option treat input names row names. disabled default (#966). New vec_rep() vec_rep_each() repeating entire vector elements vector, respectively. two functions provide clearer interface functionality vec_repeat(), now deprecated. vec_cbind() now calls vec_restore() inputs emptied columns computing common type. consequences data frame classes special columns devolve simpler classes columns subsetted . classes now always simplified vec_cbind(). instance, column-binding grouped data frame data frame now produces tibble (simplified class grouped data frame). vec_match() vec_in() gain parameters argument tags (#944). internal version vec_assign() now support assigning names inner names. data frames, names assigned recursively. vec_assign() gains x_arg value_arg parameters (#918). vec_group_loc(), powers dplyr::group_by(), now efficient vector access (#911). vec_ptype() gained x_arg argument. New list_sizes() computing size every element list. list_sizes() vec_size() lengths() length(), except supports lists. Atomic vectors data frames result error. new_data_frame() infers size row names n = NULL (#894). vec_c() now accepts rlang::zap() .name_spec input. returned vector always unnamed, names cause errors can’t combined. still used create informative messages inputs incompatible types (#232).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"classes-0-3-0","dir":"Changelog","previous_headings":"","what":"Classes","title":"vctrs 0.3.0","text":"vctrs now supports data.table class. common type data frame data table data table. new_vctr() now always appends base \"list\" class list .data compatible changes vec_is_list(). affects new_list_of(), now returns object base class \"list\". dplyr methods now implemented vec_restore(), vec_ptype2(), vec_cast(). user-visible consequence (breaking change) row-binding grouped data frame data frame tibble now returns grouped data frame. previously return tibble. .na<-() method vctrs_vctr now supports numeric character subscripts indicate insert missing values (#947). Improved support vector-like S4 objects (#550, #551). base classes AsIs table vctrs methods (#904, #906). POSIXlt POSIXct vectors handled consistently (#901). Ordered factors identical levels now incompatible. now incompatible factors.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"indexing-and-names-0-3-0","dir":"Changelog","previous_headings":"","what":"Indexing and names","title":"vctrs 0.3.0","text":"vec_as_subscript() now fails subscript matrix array, consistently vec_as_location(). Improved error messages vec_as_location() subscript matrix array (#936). vec_as_location2() properly picks subscript_arg (tidyverse/tibble#735). vec_as_names() now informative error messages names unique (#882). vec_as_names() gains repair_arg argument set cause repair = \"check_unique\" generate informative hint (#692).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"conditions-0-3-0","dir":"Changelog","previous_headings":"","what":"Conditions","title":"vctrs 0.3.0","text":"stop_incompatible_type() now action argument customizing whether coercion error came vec_ptype2() vec_cast(). stop_incompatible_cast() now thin wrapper around stop_incompatible_type(action = \"convert\"). stop_ functions now take details dots. argument can longer passed position. Supplying details message stop_ functions now internal error. x_arg, y_arg, to_arg now compulsory arguments stop_ functions like stop_incompatible_type(). Lossy cast errors now considered internal. Please don’t test class explicitly handle . New argument loss_type experimental function maybe_lossy_cast(). can take values “precision” “generality” indicate error message kind loss error (double integer loses precision, character factor loses generality). Coercion recycling errors now consistent.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"cran-results-0-3-0","dir":"Changelog","previous_headings":"","what":"CRAN results","title":"vctrs 0.3.0","text":"Fixed clang-UBSAN error “nan outside range representable values type ‘int’” (#902). Fixed compilation stability vignette following date conversion changes R-devel.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-024","dir":"Changelog","previous_headings":"","what":"vctrs 0.2.4","title":"vctrs 0.2.4","text":"CRAN release: 2020-03-10 Factors dates methods now implemented C efficiency. new_data_frame() now correctly updates attributes supports merging \"names\" \"row.names\" arguments (#883). vec_match() gains na_equal argument (#718). vec_chop()’s indices argument restricted positive integer vectors. Character logical subscripts haven’t proven useful, aligns vec_chop() vec_unchop(), positive integer vectors make sense. New vec_unchop() combining list vectors single vector. similar vec_c(), gives greater control elements placed output use secondary indices argument. Breaking change: .id supplied, vec_rbind() now creates identifier column start data frame rather end. numeric_version package_version lists now treated vectors (#723). vec_slice() now properly handles symbols S3 subscripts. vec_as_location() vec_as_subscript() now fully implemented C efficiency. num_as_location() gains new argument, zero, controlling whether \"remove\", \"ignore\", \"error\" zero values (#852).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-023","dir":"Changelog","previous_headings":"","what":"vctrs 0.2.3","title":"vctrs 0.2.3","text":"CRAN release: 2020-02-20 main feature release considerable performance improvements factors dates. vec_c() now falls back base::c() vector doesn’t implement vec_ptype2() implements c(). improve compatibility vctrs-based functions foreign classes (#801). new_data_frame() now faster. New vec_is_list() detecting vector list vctrs sense. instance, objects class lm lists. general, classes need explicitly inherit \"list\" considered lists vctrs. Unspecified vectors NA can now assigned list (#819). vec_ptype() now errors scalar inputs (#807). vec_ptype_finalise() now recursive data frame types, ensuring unspecified columns correctly finalised logical (#800). vec_ptype() now correctly handles unspecified columns data frames, always return unspecified column type (#800). vec_slice() vec_chop() now work correctly bit64::integer64() objects NA subscript supplied. extension, means vec_init() now works objects well (#813). vec_rbind() now binds row names. named inputs supplied names_to NULL, names define row names. names_to supplied, assigned column name . vec_cbind() now uses row names first named input. c() method vctrs_vctr now throws error recursive use.names supplied (#791).","code":"x <- list(1, 2) vec_slice(x, 1) <- NA x #> [[1]] #> NULL #> #> [[2]] #> 2"},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-022","dir":"Changelog","previous_headings":"","what":"vctrs 0.2.2","title":"vctrs 0.2.2","text":"CRAN release: 2020-01-24 New vec_as_subscript() function cast inputs base type subscript (logical, numeric, character). vec_as_index() renamed vec_as_location(). Use num_as_location() need options control numeric subscripts converted vector locations. New vec_as_subscript2(), vec_as_location2(), num_as_location2() variants validating scalar subscripts locations (e.g. indexing [[). vec_as_location() now preserves names inputs possible. vec_ptype2() methods base classes now prevent inheritance. makes sense subtyping graph created vec_ptype2() methods generally inheritance relationships defined S3 classes. instance, subclasses often richer type superclasses, often declared supertypes (e.g. vec_ptype2() return subclass). introduced breaking change patch release new_vctr() now adds base type class vector default, caused vec_ptype2() dispatch erroneously methods base types. ’ll finish switching approach vctrs 0.3.0 rest base S3 classes (dates, data frames, …). vec_equal_na() now works complex vectors. vctrs_vctr class gains .POSIXlt() method (#717). vec_is() now ignores names row names (#707). vec_slice() now support Altvec vectors (@jimhester, #696). vec_proxy_equal() now applied recursively across columns data frames (#641). vec_split() longer returns val column list_of. now returned bare list (#660). Complex numbers now coercible integer double (#564). zeallot moved Imports Suggests, meaning %<-% longer re-exported vctrs. vec_equal() longer propagates missing values comparing list elements. means vec_equal(list(NULL), list(NULL)) continue return NA NULL missing element list, now vec_equal(list(NA), list(NA)) returns TRUE NA values compared directly without checking missingness. Lists expressions now supported vec_equal() functions compare elements, vec_unique() vec_match(). ensures work result modeling functions like glm() mgcv::gam() store “family” objects containing expressions (#643). new_vctr() gains experimental inherit_base_type argument determines whether class underlying type included class. list_of() now inherits explicitly “list” (#593). vec_ptype() relaxed default behaviour base types; now two vectors inherit (e.g.) “character”, common type also “character” (#497). vec_equal() now correctly treats NULL missing value element lists (#653). vec_cast() now casts data frames lists rowwise, .e. list data frames size 1. preserves invariant vec_size(vec_cast(x, )) == vec_size(x) (#639). Positive negative 0 now considered equivalent functions check equality uniqueness (#637). New experimental functions vec_group_rle() returning run length encoded groups; vec_group_id() constructing group identifiers vector; vec_group_loc() computing locations unique groups vector (#514). New vec_chop() repeatedly slicing vector. efficiently captures pattern map(indices, vec_slice, x = x). Support multiple character encodings added functions compare elements within single vector, vec_unique(), across multiple vectors, vec_match(). multiple encodings encountered, translation UTF-8 performed comparisons made (#600, #553). Equality ordering methods now implemented raw complex vectors (@romainfrancois).","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-021","dir":"Changelog","previous_headings":"","what":"vctrs 0.2.1","title":"vctrs 0.2.1","text":"CRAN release: 2019-12-17 Maintenance release CRAN checks.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"vctrs-020","dir":"Changelog","previous_headings":"","what":"vctrs 0.2.0","title":"vctrs 0.2.0","text":"CRAN release: 2019-07-05 0.2.0 release, many vctrs functions rewritten native C code improve performance. Functions like vec_c() vec_rbind() now fast enough used packages. ongoing effort, instance handling factors dates rewritten yet. classes still slow vctrs primitives. API 0.2.0 updated, please see list breaking changes . vctrs now graduated experimental maturing package. Please note API changes still planned future releases, instance vec_ptype2() vec_cast() might need return sentinel instead failing error common type possible cast.","code":""},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"breaking-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"vctrs 0.2.0","text":"Lossy casts now throw errors type vctrs_error_cast_lossy. Previously warnings. can suppress errors selectively allow_lossy_cast() get partial cast results. implement lossy cast operation, call new exported function maybe_lossy_cast(). vec_c() now fails input supplied name internal names length > 1: can supply name specification describes combine external name input internal names positions: vec_empty() renamed vec_is_empty(). vec_dim() vec_dims() longer exported. vec_na() renamed vec_init(), primary use case initialize output container. vec_slice<- now type stable (#140). always returns type LHS. needed, RHS cast correct type, inputs coercible. See examples ?vec_slice. renamed type particle ptype: vec_type() => vec_ptype() vec_type2() => vec_ptype2() vec_type_common() => vec_ptype_common() Consequently, vec_ptype() renamed vec_ptype_show().","code":"vec_c(foo = c(a = 1)) #> Error: Can't merge the outer name `foo` with a named vector. #> Please supply a `.name_spec` specification.  vec_c(foo = 1:3) #> Error: Can't merge the outer name `foo` with a vector of length > 1. #> Please supply a `.name_spec` specification. # Name spec as glue string: vec_c(foo = c(a = 1), .name_spec = \"{outer}_{inner}\")  # Name spec as a function: vec_c(foo = c(a = 1), .name_spec = function(outer, inner) paste(outer, inner, sep = \"_\")) vec_c(foo = c(a = 1), .name_spec = ~ paste(.x, .y, sep = \"_\"))"},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"vctrs 0.2.0","text":"New vec_proxy() generic. main customisation point vctrs along vec_restore(). implement type designed around non-vector class (atomic vectors, bare lists, data frames). case, vec_proxy() return vector class. vctrs operations applied proxy vec_restore() called restore original representation type. common case need implement vec_proxy() S3 lists. vctrs, S3 lists treated scalars default. way don’t treat objects like model fits vectors. prevent vctrs treating S3 list scalar, unclass vec_proxy() method. instance definition list_of: inherit vctrs_vctr vctrs_rcrd don’t need implement vec_proxy(). vec_c(), vec_rbind(), vec_cbind() gain .name_repair argument (#227, #229). vec_c(), vec_rbind(), vec_cbind(), functions relying vec_ptype_common() now informative error messages inputs nested data frames convergent: vec_cbind() now turns named data frames packed columns. Packed data frames nested single column. makes possible access single name: planning use syntax widely tidyverse. New vec_is() function check whether vector conforms prototype /size. Unlike vec_assert(), doesn’t throw errors returns TRUE FALSE (#79). Called without specific type size, vec_assert() tests whether object data vector scalar. S3 lists treated scalars default. Implement vec_is_vector() class override property (derive vctrs_vctr). New vec_order() vec_sort() ordering sorting generalised vectors. New .names_to parameter vec_rbind(). supplied, name column names inputs copied. similar .id parameter dplyr::bind_rows(). New vec_seq_along() vec_init_along() create useful sequences (#189). vec_slice() now preserves character row names, present. New vec_split(x, ) generalisation split() can divide vector groups formed unique values another vector. Returns two-column data frame containing unique values aligned matching x values (#196).","code":"#' @export vec_proxy.vctrs_list_of <- function(x) {   unclass(x) } df1 <- tibble(foo = tibble(bar = tibble(x = 1:3, y = letters[1:3]))) df2 <- tibble(foo = tibble(bar = tibble(x = 1:3, y = 4:6)))  vec_rbind(df1, df2) #> Error: No common type for `..1$foo$bar$y` <character> and `..2$foo$bar$y` <integer>. data <- tibble::tibble(x = 1:3, y = letters[1:3]) data <- vec_cbind(data, packed = data) data # A tibble: 3 x 3       x y     packed$x $y   <int> <chr>    <int> <chr> 1     1 a            1 a 2     2 b            2 b 3     3 c            3 c data$packed # A tibble: 3 x 2       x y   <int> <chr> 1     1 a 2     2 b 3     3 c"},{"path":"https://vctrs.r-lib.org/dev/news/index.html","id":"other-features-and-bug-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Other features and bug fixes","title":"vctrs 0.2.0","text":"Using classed errors class \"vctrs_error_assert\" failed assertions, class \"vctrs_error_incompatible\" (subclasses _type, _cast _op) errors incompatible types (#184). Character indexing now supported named objects, error raised unnamed objects (#171). Predicate generics now consistently return logical vectors passed vctrs_vctr class. used restore output input type (#251). list_of() now .character() method. uses vec_ptype_abbr() collapse complex objects type representation (tidyverse/tidyr#654). New stop_incompatible_size() signal failure due mismatched sizes. New validate_list_of() (#193). vec_arith() consistent base R combining difftime date, warning casts lossy (#192). vec_c() vec_rbind() now handle data.frame columns properly (@yutannihilation, #182). vec_cast(x, data.frame()) preserves number rows x. vec_equal() now handles missing values symmetrically (#204). vec_equal_na() now returns TRUE data frames records every component missing, component missing (#201). vec_init() checks input vector. vec_proxy_compare() gains experimental relax argument, allows data frames orderable even columns (#210). vec_size() now works positive short row names. fixes issues data frames created jsonlite (#220). vec_slice<- now vec_assign() alias. Use vec_assign() don’t want modify original input. vec_slice() now calls vec_restore() automatically. Unlike default [ method base R, attributes preserved default. vec_slice() can correct slice 0-row data frames (#179). New vec_repeat() repeating element vector number times. vec_type2(x, data.frame()) ensures returned object names length-0 character vector.","code":""}]
