---
title: "Printing vectors nicely in tibbles"
author: "Kirill M체ller, Hadley Wickham"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Printing vectors nicely in tibbles}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = pillar::style_subtle("#>"))
```

To ensure that a vector prints nicely in a tibble, you need to understand how printing works.
The presentation of a column in a tibble is powered by four S3 generics:

* `vctrs::vec_ptype_abbr()` determines what goes into the column header.
* `pillar::pillar_shaft()` determines what goes into the body of the column.

If you have created a vector class that can be used as a column, you can override these generics to make sure your data prints well in a tibble.
This short vignette assumes a package that implements a `"latlon"` vector and uses roxygen2 to create documentation and the `NAMESPACE` file.
To make the required methods available in this vignette, we attach pillar and vctrs.
You don't need to do this in your package.

```{r attach}
library(vctrs)
library(pillar)
```

In a package, you must import the pillar package that powers the printing of tibbles.
Add `pillar` to the `Imports:` section of your `DESCRIPTION`.
The following helper does this for you:

```{r, eval = FALSE}
usethis::use_package("pillar")
```



## Prerequisites

We define a class `"latlon"` that encodes geographic coordinates in a record.
For simplicity, the values are printed as degrees and minutes only.

```{r}
library(vctrs)

#' @export
latlon <- function(lat, lon) {
  new_rcrd(list(lat = lat, lon = lon), class = "latlon")
}

format_latlon <- function(x, formatter = deg_min) {
  x_valid <- which(!is.na(x))

  lat <- field(x, "lat")[x_valid]
  lon <- field(x, "lon")[x_valid]

  ret <- rep(NA_character_, vec_size(x))
  ret[x_valid] <- paste(
    formatter(lat, "lat"),
    formatter(lon, "lon")
  )
  # It's important to keep NA in the vector!
  format(ret, justify = "right", na.encode = FALSE)
}

#' @export
print.latlon <- function(x, ...) {
  cat(format_latlon(x), sep = "\n")
}

deg_min <- function(x, direction) {
  pm <- if (direction == "lat") c("N", "S") else c("E", "W")

  sign <- sign(x)
  x <- abs(x)
  deg <- trunc(x)
  x <- x - deg
  min <- round(x * 60)

  ret <- sprintf("%d째%.2d'%s", deg, min, pm[ifelse(sign >= 0, 1, 2)])
  format(ret, justify = "right")
}

latlon(32.7102978, -117.1704058)
```

By using `vctrs_rcrd()`, we already get the infrastructure to make this class fully compatible with data frames for free.


## Using in a tibble

Columns on this class can be used in a tibble right away, because `vctrs::vec_is()` is `TRUE` for latlon objects:

```{r}
library(tibble)

loc <- latlon(
  c(28.3411783, 32.7102978, 30.2622356, 37.7859102, 28.5, NA),
  c(-81.5480348, -117.1704058, -97.7403327, -122.4131357, -81.4, NA)
)
vctrs::vec_is(loc)

data <- tibble(venue = "rstudio::conf", year = 2017:2022, loc = loc)

data$loc
```

The tibble can't be printed yet because we haven't implemented a `format()` method for our class:

```{r error = TRUE}
data
```

The easiest solution is to implement a `format()` method.
This method should return a character vector with one element per item, with `NA` in locations where the input vector is `NA`.
See `vignette("s3-vector", package = "vctrs")` for details.
(This also allows us to take advantage of the `print()` method implemented for the rcrd class.)

```{r}
#' @importFrom pillar pillar_shaft
#' @export
format.latlon <- function(x, ...) {
  format_latlon(x)
}

rm(print.latlon)
data$loc
```

The new `format()` method is used to render the column:

```{r}
data
```

The output has two main problems:

1. The column type of the `loc` column is displayed as `<latlon>`.  This default formatting works reasonably well for any kind of object, but may be too wide or too technical.
1. Likewise, the values in the `loc` column consume a lot of precious horizontal space, which might take away space from other columns.

In the remainder I'll show how to fix these problems.


## Fixing the data type

To display `<geo>` as data type, we need to override the `vec_ptype_abbr()` method.
This method should return a string that can be used in a column header.
For your own classes, strive for an evocative abbreviation that's under 6 characters.

```{r}
#' @importFrom vctrs vec_ptype_abbr
#' @export
vec_ptype_abbr.latlon <- function(x) {
  "geo"
}
```

The `x` argument is used only for method dispatch, the return value is a constant that doesn't depend on the data.

```{r}
data
```


## Custom rendering

The `format()` method us used by default for rendering.
For custom formatting we implement the `pillar_shaft()` method for our class.[^pillar-shaft]
Our custom implementation uses left alignment and indents only the `NA` values so that they align with the latitude values:

[^pillar-shaft]: A [*pillar*](https://en.wikipedia.org/wiki/Column#Nomenclature) is mainly a *shaft* (decorated with an *ornament*), with a *capital* above and a *base* below.
Multiple pillars form a *colonnade*, which can be stacked in multiple *tiers*.
This is the motivation behind the names in our API.

```{r}
#' @importFrom pillar pillar_shaft
#' @export
pillar_shaft.latlon <- function(x, ...) {
  out <- format_latlon(x)
  pillar::new_pillar_shaft_simple(out, align = "left", na_indent = 5)
}

data
```



## Adding color

`new_pillar_shaft_simple()` accepts ANSI escape codes for coloring, emphasis, or other ways of highlighting text on terminals that support it.
Some formattings are predefined, e.g. `style_subtle()` displays text in a light gray.
For default data types, this style is used for insignificant digits.
We'll be formatting the degree and minute signs in a subtle style, because they serve only as separators.
You can also use the [crayon](https://cran.r-project.org/package=crayon) package to add custom formattings to your output.

```{r}
#' @importFrom pillar pillar_shaft
#' @export
pillar_shaft.latlon <- function(x, ...) {
  out <- format_latlon(x, formatter = deg_min_color)
  pillar::new_pillar_shaft_simple(out, align = "left", na_indent = 5)
}

deg_min_color <- function(x, direction) {
  pm <- if (direction == "lat") c("N", "S") else c("E", "W")

  sign <- sign(x)
  x <- abs(x)
  deg <- trunc(x)
  x <- x - deg
  rad <- round(x * 60)
  ret <- sprintf(
    "%d%s%.2d%s%s",
    deg,
    pillar::style_subtle("째"),
    rad,
    pillar::style_subtle("'"),
    pm[ifelse(sign >= 0, 1, 2)]
  )
  format(ret, justify = "right")
}

data
```

Currently, ANSI escapes are not rendered in vignettes, so the display here isn't much different from earlier examples.
This may change in the future.



## Truncation

If there is not enough space to render the values, the formatted values are truncated with an ellipsis.
This doesn't currently apply to our class, because we haven't specified a minimum width for our values:

```{r}
print(data, width = 30)
```

If we specify a minimum width when constructing the shaft, the `loc` column will be truncated:

```{r}
#' @importFrom pillar pillar_shaft
#' @export
pillar_shaft.latlon <- function(x, ...) {
  out <- format_latlon(x)
  pillar::new_pillar_shaft_simple(out, align = "right", min_width = 10)
}

print(data, width = 30)
```


## Adaptive rendering

Truncation may be useful for character data, but for lat-lon data we may prefer to show full degrees and remove the minutes if the available space is not enough to show accurate values.
A more sophisticated implementation of the `pillar_shaft()` method is required to achieve this:

```{r}
#' @importFrom pillar pillar_shaft
#' @export
pillar_shaft.latlon <- function(x, ...) {
  deg <- format_latlon(x, formatter = deg)
  deg_min <- format_latlon(x)

  pillar::new_pillar_shaft(
    list(deg = deg, deg_min = deg_min),
    width = pillar::get_max_extent(deg_min),
    min_width = pillar::get_max_extent(deg),
    class = "pillar_shaft_latlon"
  )
}
```

Here, `pillar_shaft()` returns an object of the `"pillar_shaft_latlon"` class created by the generic `new_pillar_shaft()` constructor.
This object contains the necessary information to render the values, and also minimum and maximum width values.
For simplicity, both formattings are pre-rendered, and the minimum and maximum widths are computed from there.
(`get_max_extent()` is a helper that computes the maximum display width occupied by the values in a character vector.)

For completeness, the code that implements the degree-only formatting looks like this:

```{r}
deg <- function(x, direction) {
  pm <- if (direction == "lat") c("N", "S") else c("E", "W")

  sign <- sign(x)
  x <- abs(x)
  deg <- round(x)

  ret <- sprintf("%d째%s", deg, pm[ifelse(sign >= 0, 1, 2)])
  format(ret, justify = "right")
}
```

All that's left to do is to implement a `format()` method for our new `"pillar_shaft_latlon"` class.
This method will be called with a `width` argument, which then determines which of the formattings to choose.
The formatting of our choice is passed to the `new_ornament()` function:

```{r}
#' @export
format.pillar_shaft_latlon <- function(x, width, ...) {
  if (get_max_extent(x$deg_min) <= width) {
    ornament <- x$deg_min
  } else {
    ornament <- x$deg
  }

  pillar::new_ornament(ornament, align = "left")
}

data
print(data, width = 30)
```

`new_ornament()` also accepts ANSI escapes for highlighted output.


## Testing

If you want to test the output of your code, you can compare it with a known state recorded in a text file.
The `testthat::verify_output()` function offers an easy way to test output-generating functions.
It takes care about details such as Unicode, ANSI escapes, and output width.
Furthermore it won't make the tests fail on CRAN.
This is important because your output may rely on details out of your control, which should be fixed eventually but should not lead to your package being removed from CRAN.

The tests work best with the testthat package:

```{r}
library(testthat)
```

```{r include = FALSE}
unlink("latlon.txt")
```

The code below will compare the output of `pillar_shaft(data$loc)` with known output stored in the `latlon.txt` file.
There is no need to put it in a `test_that()` block.

The first run warns because the file doesn't exist yet.


```{r error = TRUE, warning = TRUE}
verify_output("latlon.txt", {
  pillar_shaft(data$loc)
})
```

From the second run on, the printing will be compared with the file:

```{r}
verify_output("latlon.txt", {
  pillar_shaft(data$loc)
})
```

By default, the file does not contain ANSI escapes.
See `?verify_output` for more options.

```{r}
cat(readLines("latlon.txt"), sep = "\n")
```

Changing the code or the format method will give an error on the next run and update the reference file.
Inspect the changes carefully before committing the new test and the updated reference file to version control.

```{r error = TRUE}
verify_output("latlon.txt", {
  pillar_shaft(data$loc)
  print(pillar_shaft(data$loc), width = 12)
})
```

```{r}
cat(readLines("latlon.txt"), sep = "\n")
```

From the second run on, no errors are shown again.

```{r error = TRUE}
verify_output("latlon.txt", {
  pillar_shaft(data$loc)
  print(pillar_shaft(data$loc), width = 12)
})
```

```{r include = FALSE}
unlink("latlon.txt")
```
