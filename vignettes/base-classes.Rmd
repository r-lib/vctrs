---
title: "Base classes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Base classes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette shows how a handful of popular base classes might be implemented using the vctrs framework. This is not a suggestion about how they _should_ be implemented, as the real implementations need to handle considerably more edge cass, but an exploration of the vctrs framework to make sure it is complete. I hope it also might be helpful pedagogically, as you can see the implementation of classes that you're already familiar with.

```{r setup}
library(vctrs)
```

## Factors

A factor is an integer vector with a character vector `levels` attribute. Note that we don't check that x has valid values (i.e. greater than 0 and less than `length(levels)`), and we don't check that the `levels` are unique. Since these checks involve values (not types), they are not appropriate for a low-level constructor.

```{r}
new_fctr <- function(x = integer(), levels = character()) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))
  
  new_vctr(x, levels = levels, class = "fctr")
}
```

(We omit the optional `contrasts` attribute because it's rarely used.)

Usually it is constructed from a character vector. Compared to the base implemented this builds levels in the order they are found in the data, rather than alphabetically. Alphabetical order is a little dangerous because it varies from system to system.

```{r}
fctr <- function(x = character(), levels = NULL) {
  x <- vec_cast(x, character())
  if (is.null(levels)) {
    levels <- vec_unique(x)
  } else {
    levels <- vec_cast(levels, character())
  }
  
  idx <- vec_match(x, levels)
  
  new_vctr(idx, levels = levels, class = "fctr")
}
```

The format method displays the level, and we include the levels in a footer. In real code, you would need to carefully think about what do if there are many levels, very long levels, or levels containing special values (like `\n`).

```{r}
format.fctr <- function(x, ...) {
  attr(x, "levels")[x]
}

vec_print_footer.fctr <- function(x, ...) {
  cat("Levels: ", paste0(attr(x, "levels"), collapse = ", "), "\n", sep = "")
}

# Check that a zero-length fctr behaves well
fctr()

# Construct a more realistic factor
x <- fctr(c("a", "b", "c", "c", "b", NA))
x

data.frame(x)
```

(Note that we treat missing values differently to `factor()`; placing in the levels by default.)

Next we define `vec_type2()`. We have to expand base R semantics here: I've decided to take the union of factors with different levels, and keep the levels as is when combining with a character vector (similarly to `[<-.factor`).

```{r}
vec_type2.fctr <- function(x, y) UseMethod("vec_type2.fctr", y)
vec_type2.fctr.fctr <- function(x, y) {
  new_fctr(levels = union(attr(x, "levels"), attr(y, "levels")))
}
vec_type2.fctr.character <- function(x, y) {
  vec_subset(x, 0L) 
}
vec_type2.character.fctr <- function(x, y) {
  vec_subset(y, 0L) 
}

vec_type2(
  fctr(levels = c("x", "y")), 
  fctr(levels = c("a", "x", "y", "z"))
)
```

`vec_cast()` allows us to cast between these types:

```{r}
vec_cast.fctr <- function(x, to) UseMethod("vec_cast.fctr")

vec_cast.character.factor <- function(x, to) {
  attr(x, "levels")[vec_data(x)]
}

vec_cast.fctr.character <- function(x, to) {
  idx <- vec_match(x, attr(to, "levels"))
  if (any(is.na(idx))) {
    warn_lossy_cast(x, to, which(is.na(idx)))
  }
  
  new_fctr(idx, levels = attr(to, "levels"))
}

vec_cast.fctr.fctr <- function(x, to) {
  level_idx <- vec_match(attr(x, "levels"), attr(to, "levels"))
  if (any(is.na(level_idx))) {
    warn_lossy_cast(x, to)
  }
  
  new_fctr(level_idx[vec_data(x)], levels = attr(to, "levels"))
}

vec_cast(c("x", "y", "z"), fctr(c("x", "y")))

vec_cast(fctr(c("x", "y", "z")), fctr(c("x", "y")))
```

```{r}
x <- fctr(c("x", "y", "z"))
x[[1]] <- "y"
x[2] <- "x"
x[3] <- "a"
x
```

We can make `as.integer()` work by defining `vec_cast.integer.fctr()`. I think it's good practice to ensure casts always have an inverse; I don't think there's an equivalent to `vec_cast.fctr.integer()` in base R.

```{r}
vec_cast.integer.fctr <- function(x, to) {
  vec_data(x)
}

vec_cast.fctr.integer <- function(x, to) {
  nlevels <- length(attr(to, "levels"))
  bad_val <- x < 1L | x > nlevels
  
  if (any(bad_val)) {
    x[bad_val] <- NA
    warn_lossy_cast(x, to, which(bad_val), "Integer values out of range")
  }
  
  new_fctr(x, attr(to, "levels"))
}

as.integer(x)
```



