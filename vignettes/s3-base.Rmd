---
title: "S3 base classes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Base classes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette shows how a handful of popular base classes might be implemented using the vctrs framework. This is not a suggestion about how they _should_ be implemented, as the real implementations need to handle considerably more edge cass, but an exploration of the vctrs framework to make sure it is complete. I hope it also might be helpful pedagogically, as you can see the implementation of classes that you're already familiar with.

```{r setup}
library(vctrs)
```

## Factors

A factor is an integer vector with a character vector `levels` attribute. Note that we don't check that x has valid values (i.e. greater than 0 and less than `length(levels)`), and we don't check that the `levels` are unique. Since these checks involve values (not types), they are not appropriate for a low-level constructor.

```{r}
new_fctr <- function(x = integer(), levels = character()) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))
  
  new_vctr(x, levels = levels, class = "fctr")
}
```

(We omit the optional `contrasts` attribute because it's rarely used.)

Usually it is constructed from a character vector. Compared to the base implemented this builds levels in the order they are found in the data, rather than alphabetically. Alphabetical order is a little dangerous because it varies from system to system.

```{r}
fctr <- function(x = character(), levels = NULL) {
  x <- vec_cast(x, character())
  if (is.null(levels)) {
    levels <- vec_unique(x)
  } else {
    levels <- vec_cast(levels, character())
  }
  
  idx <- vec_match(x, levels)
  
  new_vctr(idx, levels = levels, class = "fctr")
}
```

The format method displays the level, and we include the levels in a footer. In real code, you would need to carefully think about what do if there are many levels, very long levels, or levels containing special values (like `\n`).

```{r}
format.fctr <- function(x, ...) {
  attr(x, "levels")[x]
}

obj_print_footer.fctr <- function(x, ...) {
  cat("Levels: ", paste0(attr(x, "levels"), collapse = ", "), "\n", sep = "")
}

# Check that a zero-length fctr behaves well
fctr()

# Construct a more realistic factor
x <- fctr(c("a", "b", "c", "c", "b", NA))
x

data.frame(x)
```

(Note that we treat missing values differently to `factor()`; placing in the levels by default.)

Next we define `vec_type2()`. We have to expand base R semantics here: I've decided to take the union of factors with different levels, and keep the levels as is when combining with a character vector (similarly to `[<-.factor`).

```{r}
vec_type2.fctr <- function(x, y) UseMethod("vec_type2.fctr", y)
vec_type2.fctr.fctr <- function(x, y) {
  new_fctr(levels = union(attr(x, "levels"), attr(y, "levels")))
}
vec_type2.fctr.character <- function(x, y) {
  x[[0L]]
}
vec_type2.character.fctr <- function(x, y) {
  y[[0L]]
}

vec_type2(
  fctr(levels = c("x", "y")), 
  fctr(levels = c("a", "x", "y", "z"))
)
```

`vec_cast()` allows us to cast between these types:

```{r}
vec_cast.fctr <- function(x, to) UseMethod("vec_cast.fctr")

vec_cast.character.factor <- function(x, to) {
  attr(x, "levels")[vec_data(x)]
}

vec_cast.fctr.character <- function(x, to) {
  idx <- vec_match(x, attr(to, "levels"))
  if (any(is.na(idx))) {
    warn_lossy_cast(x, to, which(is.na(idx)))
  }
  
  new_fctr(idx, levels = attr(to, "levels"))
}

vec_cast.fctr.fctr <- function(x, to) {
  level_idx <- vec_match(attr(x, "levels"), attr(to, "levels"))
  if (any(is.na(level_idx))) {
    warn_lossy_cast(x, to)
  }
  
  new_fctr(level_idx[vec_data(x)], levels = attr(to, "levels"))
}

vec_cast(c("x", "y", "z"), fctr(c("x", "y")))

vec_cast(fctr(c("x", "y", "z")), fctr(c("x", "y")))
```

```{r}
x <- fctr(c("x", "y", "z"))
x[[1]] <- "y"
x[2] <- "x"
x[3] <- "a"
x
```

We can make `as.integer()` work by defining `vec_cast.integer.fctr()`. I think it's good practice to ensure casts always have an inverse; I don't think there's an equivalent to `vec_cast.fctr.integer()` in base R.

```{r}
vec_cast.integer.fctr <- function(x, to) {
  vec_data(x)
}

vec_cast.fctr.integer <- function(x, to) {
  nlevels <- length(attr(to, "levels"))
  bad_val <- x < 1L | x > nlevels
  
  if (any(bad_val)) {
    x[bad_val] <- NA
    warn_lossy_cast(x, to, which(bad_val), "Integer values out of range")
  }
  
  new_fctr(x, attr(to, "levels"))
}

as.integer(x)
```

### Ordered factors

Ordered factors are a subclass of factors, so first we need to make `fctr` extensible by adding `...` and `class` to the low-level constructor:

```{r}
new_fctr <- function(x = integer(), levels = character(), ..., class = character()) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))
  
  new_vctr(x, levels = levels, ..., class = c(class, "fctr"))
}
```

We can then define the constructors for the ordrd class. We cheat a little but using the user-facing constructor fctr.

```{r}
new_ordrd <- function(x = integer(), levels = character()) {
  new_fctr(x = x, levels = levels, class = "ordrd")
}
ordrd <- function(x = character(), levels = NULL) {
  v <- fctr(x, levels)
  new_ordrd(vec_data(v), attr(v, "levels"))
}

x <- ordrd(letters[1:3])
x
```

Then we add a `obj_print_footer` method to distinguish between ordered and unordered factors:

```{r}
obj_print_footer.ordrd <- function(x, ...) {
  cat("Levels: ", paste0(attr(x, "levels"), collapse = " > "), "\n", sep = "")
}
x
```

In base R, factors and ordered factors behave differently in two main way:

* In linear models, factors and ordered factors get different default 
  constrasts. This is rarely encountered and could be solved with a 
  `default_contrast()` generic so I won't discuss further.
  
* Even though factors are sortable, `min()`, `max()`, `<` and `>` throw
  errors. I think this is inconsistent - if you can sort something it implies
  an ordering, and hence that there's a minimum and maximum value. Ordered
  factors don't have these restrictions. 

## Date/times

R comes with three interlated date/time classes:

* POSIXct
* Date
* difftime

I'll ignore POSIXlt as its primary purpose is to extract human meaningful components of a date-time (i.e. weekday, month, year).

### Classes

A date is a double. To focus on the key ideas, I'll shim over the base Date methods for printing as parsing.

```{r}
new_date <- function(x) {
  stopifnot(is.double(x))
  new_vctr(x, class = "date")
}

date <- function(x) {
  stopifnot(is.character(x))
  
  x <- vec_data(as.Date(x, format = "%Y-%m-%d"))
  new_date(x)
}

format.date <- function(x) {
  format(as.Date(vec_data(x), origin = "1970-01-01"))
}

x <- date(c("2020-01-01", NA))
x
```

A datetime is a double with a timezone. The timezone affects the display of the object, not the time it represents. A default timezone of `""` reflects the current timezone.

```{r}
new_datetime <- function(x, tzone = "") {
  stopifnot(is.double(x))
  stopifnot(is.character(tzone), length(tzone) == 1L)
  
  new_vctr(x, class = "datetime")
}

datetime <- function(x, tzone = "") {
  stopifnot(is.character(x))
  
  x <- vec_data(as.POSIXct(x))
  new_datetime(x, tzone = tzone)
}

format.datetime <- function(x) {
  format(as.POSIXct(vec_data(x), origin = "1970-01-01"))
}

x <- datetime(c("2020-01-01 10:00", NA))
x
```

A duration is a double with units. Unfortunately the base implementation doesn't use units simply as a formatting convenience, but it actually affects the underlying value. I think this is suboptimal design, so in my redesign I use the units just for formatting.

```{r}
new_duration <- function(x = double(), unit = c("sec", "min", "hour", "day")) {
  stopifnot(is.double(x))
  unit <- match.arg(unit)
  
  new_vctr(x, unit = unit, class = "duration")
} 

duration <- function(x = double(), unit = c("sec", "min", "hour", "day")) {
  x <- vec_cast(x, double())
  new_duration(x, unit = unit)
}

unit_to_s <- function(x) {
  switch(x,
    sec = 1,
    min = 60,
    hour = 60 * 60,
    day = 24 * 60 * 60
  )
}

format.duration <- function(x, ...) {
  unit <- attr(x, "unit")
  y <- vec_data(x) / unit_to_s(unit)
  
  out <- paste0(format(y), substr(unit, 1, 1))
  out[is.na(x)] <- NA
  out
}

duration(c(10, NA))
duration(864000, "day")
```

### Coercions

### Arithmetic

The inter-relationships between the three classes are complex:

* Subtracting a date/time from a date/time yields a duration.
* Adding a duration to a date/time yields a data time.
* You can subtract a duration from a date/time, but you can't subtract
  a date/time from a duration. 
* You can divide a duration by another duration to yield a unit-less
  number
  
The full complexity is too much to recreate here, but you can see the implementation in <https://github.com/r-lib/vctrs/blob/master/R/type-date-time.R>
