% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unstructure.R
\name{vec_unstructure}
\alias{vec_unstructure}
\title{Unstructure a vector}
\usage{
vec_unstructure(x)
}
\arguments{
\item{x}{An object that meets vctrs's \link[=theory_faq_native_storage]{native storage requirements}.}
}
\description{
\code{vec_unstructure()} takes a vector that meets the \link[=theory_faq_native_storage]{native storage requirements} of vctrs and removes all extraneous
attributes, retaining only those that are natively supported by vctrs. Only
the following attributes are retained:
\itemize{
\item For atomic vectors, \code{names}
\item For arrays, \code{dim} and \code{dimnames}
\item For data frames, \code{names}, \code{row.names}, and a \code{class} of \code{"data.frame"}
}
}
\details{
Removing extraneous attributes is useful for avoiding unexpected side
effects, for example:
\itemize{
\item \code{\link[=vec_proxy]{vec_proxy()}} calls \code{vec_unstructure()} on the proxy before returning it.
This ensures that internal manipulation of the proxy avoids any unexpected
S3 dispatch. Additionally, it means that the a future call to
\code{\link[=vec_restore]{vec_restore()}} receives a minimal \code{x} object to build upon.
\item When implementing S3 methods for generics like \code{+} or \code{is.finite()}, it is
often useful to \code{vec_unstructure()} your custom object to remove its class,
call the generic again on the native type to use base R's native
implementation, and then optionally regenerate your custom type with a
\verb{new_<my_type>()} constructor (which you would likely do for \code{+}, but would
not do for \code{is.finite()}, which just returns a logical vector).
}

\code{vec_unstructure()} is roughly the inverse of \code{\link[base:structure]{base::structure()}}.
}
\examples{
# Atomic vectors without attributes are returned unmodified
vec_unstructure(1)

# Atomic vectors with attributes are unstructured back to their natively
# supported form, only `names` are retained here:
x <- structure(1, names = "a", foo = "bar", class = "myclass")
x
vec_unstructure(x)

# Arrays retain `dim` and `dimnames` but all other attributes are lost
x <- array(1:4, c(2, 2))
rownames(x) <- c("a", "b")
attr(x, "foo") <- "bar"
x
vec_unstructure(x)

# Data frames count as a native storage type in vctrs, so bare data frames
# are returned unmodified
x <- data_frame(x = 1:5, y = 6:10)
vec_unstructure(x)

if (require("tibble")) {
  # Tibbles meet the native storage requirement, but have extraneous
  # attributes that are stripped away
  x <- tibble(x = 1:5, y = 6:10)
  x
  vec_unstructure(x)
}

# Note that native storage types are orthogonal to proxies.
# Calling `vec_unstructure()` on a rcrd returns the underlying list storage,
# while the proxy of this type (meant for C manipulation) is a data frame.
x <- new_rcrd(list(a = 1:5, b = 6:10))
vec_unstructure(x)
vec_proxy(x)

# Types that don't meet the native storage requirements result in an error
try(vec_unstructure(NULL))
try(vec_unstructure(environment()))
}
