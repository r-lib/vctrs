% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/faq-developer.R
\name{theory-faq-native-storage}
\alias{theory-faq-native-storage}
\alias{theory_faq_native_storage}
\title{FAQ - Native storage types}
\description{
This page describes the native storage types supported by vctrs at C
level. Every vctrs algorithm, like the one underlying \code{vec_match()}, is
guaranteed to work with the native storage types.

Supported native storage types:
\itemize{
\item Logical (\code{LGLSXP})
\item Integer (\code{INTSXP})
\item Double (\code{REALSXP})
\item Complex (\code{CPLSXP})
\item Raw (\code{RAWSXP})
\item Character (\code{STRSXP})
\item List (\code{VECSXP})
\item Arrays, denoted by the presence of a \code{dim} attribute and one of the
above storage types.
\item Data frames, denoted by the presence of \code{names} and \code{row.names}
attributes, a \code{class} attribute of \code{"data.frame"}, and a storage type
of list (\code{VECSXP}). Data frame columns may contain any storage type
mentioned here, including arrays and additional data frames.
}

In addition to the required attributes mentioned above, the only other
attribute that is natively supported by vctrs on these storage types is
their names:
\itemize{
\item For atomics, the \code{names} attribute
\item For arrays, the \code{dimnames} attribute
\item For data frames, the \code{row.names} attribute
}
\subsection{\code{vec_unstructure()}}{

\code{vec_unstructure()} takes an object that meets the native storage
requirements and strips away all extraneous attributes, leaving behind
only the attributes that are natively supported, as described above.
This is often useful for avoiding unexpected S3 dispatch on classed
objects from within vctrs algorithms.
}

\subsection{\code{vec_proxy()}}{

\code{vec_proxy()} takes an arbitrary vector supported by vctrs (as defined
by \code{obj_is_vector()}) and returns an object that meets vctrsâ€™s native
storage requirements. It is the job of the class author to define the
mapping from custom vector class to a vctrs native storage type. If the
custom vector builds on top of a native storage type, then a
\code{vec_proxy()} method can return its input unmodified. The result of a
\code{vec_proxy()} method is then further processed by \code{vec_unstructure()} to
strip away extraneous attributes. This is then manipulated by the C
level algorithms of vctrs, which support all native storage types.
}
}
