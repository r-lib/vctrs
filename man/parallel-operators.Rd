% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallel.R
\name{parallel-operators}
\alias{parallel-operators}
\alias{list_pany}
\alias{list_pall}
\title{Parallel \code{any()} and \code{all()}}
\usage{
list_pany(
  x,
  ...,
  missing = NULL,
  size = NULL,
  x_arg = caller_arg(x),
  error_call = current_env()
)

list_pall(
  x,
  ...,
  missing = NULL,
  size = NULL,
  x_arg = caller_arg(x),
  error_call = current_env()
)
}
\arguments{
\item{x}{A list of logical vectors of equal size.}

\item{...}{These dots are for future extensions and must be empty.}

\item{missing}{Handling of missing values. One of:
\itemize{
\item \code{NULL}, no special behavior is applied. Missings are treated the same way
as \code{|} or \code{&}.
\item \code{FALSE} to treat missing values as \code{FALSE}.
\item \code{TRUE} to treat missing values as \code{TRUE}.
}}

\item{size}{An optional output size. Only useful to specify if \code{x} could be
an empty list.}

\item{x_arg}{Argument name used in error messages.}

\item{error_call}{The execution environment of a currently
running function, e.g. \code{caller_env()}. The function will be
mentioned in error messages as the source of the error. See the
\code{call} argument of \code{\link[rlang:abort]{abort()}} for more information.}
}
\value{
A logical vector the same size as the vectors in \code{x}.
}
\description{
These functions are variants of \code{\link[=any]{any()}} and \code{\link[=all]{all()}} that work in parallel on
multiple inputs at once. They work similarly to how \code{\link[=pmin]{pmin()}} and \code{\link[=pmax]{pmax()}} are
parallel variants of \code{\link[=min]{min()}} and \code{\link[=max]{max()}}.
}
\details{
\code{list_pany()} and \code{list_pall()} are consistent with \code{\link[=any]{any()}} and \code{\link[=all]{all()}} when
there are no inputs to process in parallel:
\itemize{
\item \code{any()} returns \code{FALSE} with no inputs. Similarly,
\code{list_pany(list(), size = 1)} returns \code{FALSE}.
\item \code{all()} returns \code{TRUE} with no inputs. Similarly,
\code{list_pall(list(), size = 1)} returns \code{TRUE}.
}
}
\examples{
a <- c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, NA, NA, NA)
b <- c(TRUE, FALSE, NA, TRUE, FALSE, NA, TRUE, FALSE, NA)
x <- list(a, b)

# Default behavior treats missings like `|` does
list_pany(x)
a | b

# Default behavior treats missings like `&` does
list_pall(x)
a & b

# Remove missings from the computation, like `na_rm = TRUE`
list_pany(x, missing = FALSE)
(a & !is.na(a)) | (b & !is.na(b))

list_pall(x, missing = TRUE)
(a | is.na(a)) & (b | is.na(b))

# `list_pall()` can be used to implement a `dplyr::filter()` style API
df <- data_frame(id = seq_along(a), a = a, b = b)

keep_rows <- function(x, ...) {
  vec_slice(x, list_pall(list(...), missing = FALSE))
}
drop_rows <- function(x, ...) {
  vec_slice(x, !list_pall(list(...), missing = FALSE))
}

# "Keep / Drop the rows when both a and b are TRUE"
# These form complements of one another, even with `NA`s.
keep_rows(df, a, b)
drop_rows(df, a, b)

# Same empty behavior as `any()` and `all()`
list_pany(list(), size = 1)
any()

list_pall(list(), size = 1)
all()
}
