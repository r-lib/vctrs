% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/list-transpose.R
\name{list_transpose}
\alias{list_transpose}
\title{Transpose a list of vectors}
\usage{
list_transpose(
  x,
  ...,
  null = NULL,
  size = NULL,
  ptype = NULL,
  x_arg = caller_arg(x),
  error_call = current_env()
)
}
\arguments{
\item{x}{A list of vectors.
\itemize{
\item Each vector will be \link[=theory-faq-recycling]{recycled} to the common size
before transposing.
\item Each vector will be \link[=theory-faq-coercion]{cast} to the common type before
transposing.
}}

\item{...}{These dots are for future extensions and must be empty.}

\item{null}{A value to replace \code{NULL} elements with before transposing.

If left unspecified, any \code{NULL} elements in \code{x} result in an error.

If specified:
\itemize{
\item Will be \link[=theory-faq-recycling]{recycled} to the common size of \code{x} before
transposing.
\item Will be \link[=theory-faq-coercion]{cast} to the common type of \code{x} before
transposing.
}}

\item{size}{The expected size of each element of \code{x}. If not provided,
computed automatically by \code{\link[=vec_size_common]{vec_size_common()}}.

If no vector inputs are provided, the common size cannot be determined
automatically and \code{size} must be provided, otherwise an error will be
thrown.}

\item{ptype}{The expected type of each element of \code{x}. If not provided,
computed automatically by \code{\link[=vec_ptype_common]{vec_ptype_common()}}.

If no vector inputs are provided, the common type cannot be determined
automatically and \code{ptype} must be provided, otherwise an error will be
thrown.}

\item{x_arg}{Argument name used in error messages.}

\item{error_call}{The execution environment of a currently
running function, e.g. \code{caller_env()}. The function will be
mentioned in error messages as the source of the error. See the
\code{call} argument of \code{\link[rlang:abort]{abort()}} for more information.}
}
\value{
A list of vectors with the following invariants:

For the list:
\itemize{
\item \verb{vec_ptype(list_transpose(x)) == <list>}
\item \code{vec_size(list_transpose(x)) == vec_size_common(!!!x)}
}

For the list elements:
\itemize{
\item \code{vec_ptype(list_transpose(x)[[i]]) == vec_ptype_common(!!!x)}
\item \code{vec_size(list_transpose(x)[[i]]) == vec_size(x)}
}
}
\description{
\code{list_transpose()} takes a list of vectors, transposes it, and
returns a new list of vectors. To perform a transpose, three pieces of
information are required:
\itemize{
\item The \emph{list size}. This is always known, and is \code{vec_size(x)}.
\item The \emph{element size}. This is computed as \code{vec_size_common(!!!x)}. If \code{x}
does not contain any vector inputs, then \code{size} must be provided, otherwise
an error is thrown.
\item The \emph{element type}. This is computed as \code{vec_ptype_common(!!!x)}. If \code{x}
does not contain any vector inputs, then \code{ptype} must be provided,
otherwise an error is thrown.
}

Supplying both \code{size} and \code{ptype} is recommended when programming with
\code{list_transpose()}, as this removes all ambiguity and ensures an error is
never thrown.

To predict the output from \code{list_transpose()}, swap the list size with the
element size. For example:
\itemize{
\item Input: List size 2, Element size 3, Element type integer
\item Output: List size 3, Element size 2, Element type integer
}
}
\examples{
# I: List size 3, Element size 2, Element type integer
# O: List size 2, Element size 3, Element type integer
list_transpose(list(1:2, 3:4, 5:6))

# With data frames
x <- data_frame(a = 1:2, b = letters[1:2])
y <- data_frame(a = 3:4, b = letters[3:4])
list_transpose(list(x, y))

# Size 1 elements are recycled
list_transpose(list(1, 2:3, 4))

# ---------------------------------------------------------------------------
# `NULL` handling

# `NULL` values aren't allowed in `list_transpose()`
x <- list(1:3, NULL, 5:7, NULL)
try(list_transpose(x))

# Replace them with `null`, which will be recycled to the common size,
# and cast to the common type
list_transpose(x, null = NA)
list_transpose(x, null = -(1:3))

# ---------------------------------------------------------------------------
# Unknown size and type

# `list_transpose()` refuses to guess the element size and element type when
# no vector inputs have been provided.

# I: List size 0, Element size ?, Element type ?
# O: List size ?, Element size 0, Element type ?
try(list_transpose(list()))

# I: List size 0, Element size 2, Element type ?
# O: List size 2, Element size 0, Element type ?
try(list_transpose(list(), size = 2L))

# Explicitly supplying both `size` and `ptype` removes all ambiguity

# I: List size 0, Element size 2, Element type integer
# O: List size 2, Element size 0, Element type integer
list_transpose(list(), size = 2L, ptype = integer())

# `NULL` does not contribute to the element size or element type, so a list
# of `NULL` also has an unknown element size and element type and will fail
# unless `size` and `ptype` are provided.

# I: List size 2, Element size ?, Element type ?
# O: List size ?, Element size 2, Element type ?
try(list_transpose(list(NULL, NULL), null = NA))

# I: List size 2, Element size 3, Element type double
# O: List size 3, Element size 2, Element type double
list_transpose(list(NULL, NULL), null = NA, size = 3, ptype = double())

# ---------------------------------------------------------------------------
# Size 0 elements

# With size 0 elements, the invariants are a bit tricky! This must return a
# size 0 list, but then you lose expected type (integer) and size (2)
# information about the elements. Losing that information makes it difficult
# to reverse the transposition.

# I: List size 2, Element size 0, Element type integer
# O: List size 0, Element size 2, Element type integer (but 0 elements)
x <- list(integer(), integer())
out <- list_transpose(x)
out

# Note how transposing a second time fails because it can't infer the element
# size or element type.

# I: List size 0, Element size ?, Element type ?
# O: List size ?, Element size 0, Element type ?
list_transpose(out)

# To work around this, provide the expected `size` and `ptype` manually

# I: List size 0, Element size 2, Element type integer
# O: List size 2, Element size 0, Element type integer
list_transpose(out, size = 2L, ptype = integer())

# ---------------------------------------------------------------------------
# Padding

# If you'd like to pad with a missing value rather than erroring,
# you might do something like this, which left-pads
x <- list(1, 2:5, 6:7)
try(list_transpose(x))

sizes <- list_sizes(x)
size <- max(sizes)
index <- which(sizes != size)

x[index] <- lapply(
  index,
  function(i) vec_c(rep(NA, times = size - sizes[[i]]), x[[i]])
)
x

list_transpose(x)
}
