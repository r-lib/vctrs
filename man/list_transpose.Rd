% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/list-transpose.R
\name{list_transpose}
\alias{list_transpose}
\title{Transpose a list of vectors}
\usage{
list_transpose(
  x,
  ...,
  null = NULL,
  size = NULL,
  ptype = NULL,
  x_arg = caller_arg(x),
  error_call = current_env()
)
}
\arguments{
\item{x}{A list of vectors.
\itemize{
\item Each vector will be \link[=theory-faq-recycling]{recycled} to the common size
before transposing.
\item Each vector will be \link[=theory-faq-coercion]{cast} to the common type before
transposing.
}}

\item{...}{These dots are for future extensions and must be empty.}

\item{null}{A value to replace \code{NULL} elements with before transposing.

If left unspecified, any \code{NULL} elements in \code{x} result in an error.

If specified:
\itemize{
\item Will be \link[=theory-faq-recycling]{recycled} to the common size of \code{x} before
transposing.
\item Will participate in determining the common type, and will be
\link[=theory-faq-coercion]{cast} to that type before transposing.
}

Note that \code{null} can alter the output type, but cannot alter the output
size. See the examples for consequences of this.}

\item{size}{The expected size of each element of \code{x}. If not provided,
computed automatically by \code{\link[=vec_size_common]{vec_size_common()}}.}

\item{ptype}{The expected type of each element of \code{x}. If not provided,
computed automatically by \code{\link[=vec_ptype_common]{vec_ptype_common()}}.}

\item{x_arg}{Argument name used in error messages.}

\item{error_call}{The execution environment of a currently
running function, e.g. \code{caller_env()}. The function will be
mentioned in error messages as the source of the error. See the
\code{call} argument of \code{\link[rlang:abort]{abort()}} for more information.}
}
\value{
A list of vectors with the following invariants:

For the list:
\itemize{
\item \verb{vec_ptype(list_transpose(x)) == <list>}
\item \code{vec_size(list_transpose(x)) == vec_size_common(!!!x)}
}

For the list elements:
\itemize{
\item \code{vec_ptype(list_transpose(x)[[i]]) == vec_ptype_common(!!!x)}
\item \code{vec_size(list_transpose(x)[[i]]) == vec_size(x)}
}
}
\description{
\code{list_transpose()} takes a list of vectors, transposes it, and returns a new
list of vectors.

To predict the output from \code{list_transpose()}, swap the size of the list
with the size of the list elements. For example:
\itemize{
\item Input: List of size 2, elements of size 3
\item Output: List of size 3, elements of size 2
}
}
\examples{
# I: List size 3, Element size 2
# O: List size 2, Element size 3
list_transpose(list(1:2, 3:4, 5:6))

# With data frames
x <- data_frame(a = 1:2, b = letters[1:2])
y <- data_frame(a = 3:4, b = letters[3:4])
list_transpose(list(x, y))

# Size 1 elements are recycled
list_transpose(list(1, 2:3, 4))

# ---------------------------------------------------------------------------
# Using `size` and `ptype`

# With size 0 elements, the invariants are a bit tricky!
# This must return a size 0 list, but then you lose expected
# type (integer) and size (2) information about the elements.
# Losing that information makes it difficult to reverse the
# transposition.
#
# I: List size 2, Element size 0
# O: List size 0, Element size 2
x <- list(integer(), integer())
out <- list_transpose(x)
out

# Note how transposing a second time doesn't recover the original list
list_transpose(out)

# To work around this, provide the lost `size` and `ptype` manually
list_transpose(out, size = vec_size(x), ptype = vec_ptype_common(!!!x))

# ---------------------------------------------------------------------------
# Padding

# If you'd like to pad with a missing value rather than erroring,
# you might do something like this, which left-pads
x <- list(1, 2:5, 6:7)
try(list_transpose(x))

sizes <- list_sizes(x)
size <- max(sizes)
index <- which(sizes != size)

x[index] <- lapply(
  index,
  function(i) vec_c(rep(NA, times = size - sizes[[i]]), x[[i]])
)
x

list_transpose(x)

# ---------------------------------------------------------------------------
# `NULL` handling

# `NULL` values aren't allowed in `list_transpose()`
x <- list(1:3, NULL, 5:7, NULL)
try(list_transpose(x))

# Replace them with `null`
list_transpose(x, null = NA)
list_transpose(x, null = -(1:3))

# When you don't know the list element size up front, but you still want
# to replace `NULL`s with something, use a size 1 `null` value which will
# get recycled to the element size after it has been computed
list_transpose(list(), null = NA)
list_transpose(list(1, NULL, 3), null = NA)
list_transpose(list(1, NULL, 3:4), null = NA)

# When you do know the list element size up front, it's best to also provide
# that information as `size`, as this helps direct the recycling process
# for `null`, particularly in the cases of an empty list, a list of `NULL`s,
# or a list of size 1 elements. You typically know the list element size if
# you are providing a `null` of size != 1, because otherwise you wouldn't
# have been able to make `null` in the first place!
size <- 2L
null <- 3:4

# `size` overrides the inferred element size of 0
#
# I: List size 0, Element size 0
# O: List size 0, Element size 0
try(list_transpose(list(), null = null))
# I: List size 0, Element size 2
# O: List size 2, Element size 0
list_transpose(list(), null = null, size = size)

# Same idea here
#
# I: List size 1, Element size 0
# O: List size 0, Element size 1
try(list_transpose(list(NULL), null = null))
# I: List size 1, Element size 2
# O: List size 2, Element size 1
list_transpose(list(NULL), null = null, size = size)

# `size` overrides the inferred element size of 1
#
# I: List size 2, Element size 1
# O: List size 1, Element size 2
try(list_transpose(list(1, 2), null = null))
# I: List size 2, Element size 2
# O: List size 2, Element size 2
list_transpose(list(1, 2), null = null, size = size)

# The reason that `list_transpose()` recycles `null` to the common size
# rather than letting `null` participate in common size determination is
# due to this example. When supplying a size 1 `null`, most of the time
# you don't know the element size, and you just want `null` to recycle to
# whatever the required size will be. If `null` participated in determining
# the common size, the output of this would be `list(logical())` rather than
# `list()` because the element size would be computed as 1. Since a size 1
# `null` is much more common than a size !=1 `null`, we've optimized for this
# case at the cost of needing to specify `size` explicitly in some scenarios.
list_transpose(list(), null = NA)
}
